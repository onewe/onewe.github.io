<h1 id="一前言">一、前言</h1>

<p>​	资源统一抽象为<code class="language-plaintext highlighter-rouge">Resource</code>对象.可曾记得在 spring 配置文件中的这种写法:<code class="language-plaintext highlighter-rouge">classpath:com/sjr/test/bean/MyTestBean.xml</code>,那么这种写法的意思是从classpath路径下加载xml,那么spring是如何定位到文件的?</p>

<p>​	上面这种写法相当于是个协议,在spring中默认支持9种文件协议.</p>

<ul>
  <li>
    <p>URL_PROTOCOL_FILE</p>

    <p>从文件系统中加载文件</p>
  </li>
  <li>
    <p>URL_PROTOCOL_JAR</p>

    <p>从jar包中加载文件</p>
  </li>
  <li>
    <p>URL_PROTOCOL_WAR</p>

    <p>从war包中加载文件</p>
  </li>
  <li>
    <p>URL_PROTOCOL_ZIP</p>

    <p>从zip中加载文件</p>
  </li>
  <li>
    <p>URL_PROTOCOL_WSJAR</p>

    <p>从wsjar中加载文件</p>
  </li>
  <li>
    <p>URL_PROTOCOL_VFSZIP</p>

    <p>从vfszip中加载文件</p>
  </li>
  <li>
    <p>URL_PROTOCOL_VFSFILE</p>

    <p>从vfsfile中加载文件</p>
  </li>
  <li>
    <p>URL_PROTOCOL_VFS</p>

    <p>从vfs中加载文件</p>
  </li>
</ul>

<h1 id="二分析">二、分析</h1>

<p>​	这个故事要从一段代码开始</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSpringResourceLoader</span><span class="o">(){</span>
		<span class="nc">DefaultResourceLoader</span> <span class="n">defaultResourceLoader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DefaultResourceLoader</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">());</span>
		<span class="nc">BeanFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XmlBeanFactory</span><span class="o">(</span><span class="n">defaultResourceLoader</span><span class="o">.</span><span class="na">getResource</span><span class="o">(</span><span class="s">"classpath:com/sjr/test/bean/MyTestBean.xml"</span><span class="o">));</span>
		<span class="kd">final</span> <span class="nc">MyTestBean</span> <span class="n">testBean</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"myTestBean"</span><span class="o">,</span><span class="nc">MyTestBean</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
		<span class="kd">final</span> <span class="nc">String</span> <span class="n">testStr</span> <span class="o">=</span> <span class="n">testBean</span><span class="o">.</span><span class="na">getTestStr</span><span class="o">();</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">testStr</span><span class="o">);</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>​	之前的代码,我们是直接使用的<code class="language-plaintext highlighter-rouge">ClassPathResource</code>来加载文件,这里使用的<code class="language-plaintext highlighter-rouge">DefaultResourceLoader</code>对象来加载文件.那<code class="language-plaintext highlighter-rouge">DefaultResourceLoader</code>有什么用处呢?</p>

<ol>
  <li>自动检测文件该如何加载</li>
</ol>

 	2. 简化文件加载操作流程

<h2 id="21-defaultresourceloader">2.1 DefaultResourceLoader</h2>

<p>​	<code class="language-plaintext highlighter-rouge">DefaultResourceLoader</code> 是<code class="language-plaintext highlighter-rouge">ResourceLoader</code>的默认实现.</p>

<p><img src="https://gitee.com/oneww/onew_image/raw/master/DefaultResourceLoader.png" alt="images" /></p>

<p>上图可以看到 <code class="language-plaintext highlighter-rouge">DefaultResourceLoader</code> 还有3个子类进行了功能的扩展.先看看<code class="language-plaintext highlighter-rouge">ResourceLoader</code>这个接口.</p>

<h2 id="22-resourceloader">2.2 ResourceLoader</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ResourceLoader</span> <span class="o">{</span>

	<span class="cm">/**
	 *  classpath: 前缀常量
	 * */</span>
	<span class="nc">String</span> <span class="no">CLASSPATH_URL_PREFIX</span> <span class="o">=</span> <span class="nc">ResourceUtils</span><span class="o">.</span><span class="na">CLASSPATH_URL_PREFIX</span><span class="o">;</span>


	<span class="cm">/**
	 * 通过 路径 获取 Resource 对象
	 */</span>
	<span class="nc">Resource</span> <span class="nf">getResource</span><span class="o">(</span><span class="nc">String</span> <span class="n">location</span><span class="o">);</span>

	<span class="cm">/**
	 * 获取类加载器
	 */</span>
	<span class="nd">@Nullable</span>
	<span class="nc">ClassLoader</span> <span class="nf">getClassLoader</span><span class="o">();</span>

<span class="o">}</span>

</code></pre></div></div>

<p>​	从代码可以看出,该接口只有2个方法,一个是通过路径获取 <code class="language-plaintext highlighter-rouge">Resource</code> 对象,另外一个是获取类加载器.那么在来看看 <code class="language-plaintext highlighter-rouge">DefaultResourceLoader</code> 的默认实现代码吧.</p>

<h2 id="23-defaultresourceloader-具体实现">2.3 DefaultResourceLoader 具体实现</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultResourceLoader</span> <span class="kd">implements</span> <span class="nc">ResourceLoader</span> <span class="o">{</span>

	<span class="nd">@Nullable</span>
	<span class="kd">private</span> <span class="nc">ClassLoader</span> <span class="n">classLoader</span><span class="o">;</span>
	<span class="c1">// 协议解析器 set</span>
	<span class="kd">private</span> <span class="kd">final</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">ProtocolResolver</span><span class="o">&gt;</span> <span class="n">protocolResolvers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;(</span><span class="mi">4</span><span class="o">);</span>
	<span class="c1">// 缓存</span>
	<span class="kd">private</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Class</span><span class="o">&lt;?&gt;,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Resource</span><span class="o">,</span> <span class="o">?&gt;&gt;</span> <span class="n">resourceCaches</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;&gt;(</span><span class="mi">4</span><span class="o">);</span>


	<span class="cm">/**
	 * 使用默认构造器,默认构造器中使用默认的类加载器
	 */</span>
	<span class="kd">public</span> <span class="nf">DefaultResourceLoader</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">classLoader</span> <span class="o">=</span> <span class="nc">ClassUtils</span><span class="o">.</span><span class="na">getDefaultClassLoader</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * 使用指定的类加载器
	 */</span>
	<span class="kd">public</span> <span class="nf">DefaultResourceLoader</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">ClassLoader</span> <span class="n">classLoader</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">classLoader</span> <span class="o">=</span> <span class="n">classLoader</span><span class="o">;</span>
	<span class="o">}</span>


	<span class="cm">/**
	 * 设置类加载器
	 */</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setClassLoader</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">ClassLoader</span> <span class="n">classLoader</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">classLoader</span> <span class="o">=</span> <span class="n">classLoader</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * 获取类加载器
	 */</span>
	<span class="nd">@Override</span>
	<span class="nd">@Nullable</span>
	<span class="kd">public</span> <span class="nc">ClassLoader</span> <span class="nf">getClassLoader</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">classLoader</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="k">this</span><span class="o">.</span><span class="na">classLoader</span> <span class="o">:</span> <span class="nc">ClassUtils</span><span class="o">.</span><span class="na">getDefaultClassLoader</span><span class="o">());</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * 添加协议解析器
	 */</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">addProtocolResolver</span><span class="o">(</span><span class="nc">ProtocolResolver</span> <span class="n">resolver</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">resolver</span><span class="o">,</span> <span class="s">"ProtocolResolver must not be null"</span><span class="o">);</span>
		<span class="k">this</span><span class="o">.</span><span class="na">protocolResolvers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">resolver</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * 获取协议解析器集合
	 */</span>
	<span class="kd">public</span> <span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">ProtocolResolver</span><span class="o">&gt;</span> <span class="nf">getProtocolResolvers</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">protocolResolvers</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * 获取资源缓存
	 */</span>
	<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Resource</span><span class="o">,</span> <span class="no">T</span><span class="o">&gt;</span> <span class="nf">getResourceCache</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">valueType</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Resource</span><span class="o">,</span> <span class="no">T</span><span class="o">&gt;)</span> <span class="k">this</span><span class="o">.</span><span class="na">resourceCaches</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">valueType</span><span class="o">,</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;&gt;());</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * 清除所有资源缓存
	 */</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">clearResourceCaches</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">resourceCaches</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * 获取资源
	 * **/</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nc">Resource</span> <span class="nf">getResource</span><span class="o">(</span><span class="nc">String</span> <span class="n">location</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="s">"Location must not be null"</span><span class="o">);</span>
		<span class="c1">// 遍历所有协议解析器</span>
		<span class="k">for</span> <span class="o">(</span><span class="nc">ProtocolResolver</span> <span class="n">protocolResolver</span> <span class="o">:</span> <span class="n">getProtocolResolvers</span><span class="o">())</span> <span class="o">{</span>
			<span class="c1">// 解析资源</span>
			<span class="nc">Resource</span> <span class="n">resource</span> <span class="o">=</span> <span class="n">protocolResolver</span><span class="o">.</span><span class="na">resolve</span><span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
			<span class="c1">// 如果资源解析到则返回 resource 对象</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">resource</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">return</span> <span class="n">resource</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="c1">// 判断是否是/开头</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"/"</span><span class="o">))</span> <span class="o">{</span>
			<span class="c1">// 获取classpath上下文中的资源</span>
			<span class="k">return</span> <span class="nf">getResourceByPath</span><span class="o">(</span><span class="n">location</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="c1">// 判断是否是classpath:开头路径,如果是则从classpath中获取资源</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="no">CLASSPATH_URL_PREFIX</span><span class="o">))</span> <span class="o">{</span>
			<span class="k">return</span> <span class="k">new</span> <span class="nf">ClassPathResource</span><span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="no">CLASSPATH_URL_PREFIX</span><span class="o">.</span><span class="na">length</span><span class="o">()),</span> <span class="n">getClassLoader</span><span class="o">());</span>
		<span class="o">}</span>
		<span class="k">else</span> <span class="o">{</span>
			<span class="k">try</span> <span class="o">{</span>
				<span class="c1">// 尝试把路径转化为url</span>
				<span class="c1">// Try to parse the location as a URL...</span>
				<span class="no">URL</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="n">location</span><span class="o">);</span>
				<span class="c1">// 判断是文件资源 还是url资源</span>
				<span class="k">return</span> <span class="o">(</span><span class="nc">ResourceUtils</span><span class="o">.</span><span class="na">isFileURL</span><span class="o">(</span><span class="n">url</span><span class="o">)</span> <span class="o">?</span> <span class="k">new</span> <span class="nc">FileUrlResource</span><span class="o">(</span><span class="n">url</span><span class="o">)</span> <span class="o">:</span> <span class="k">new</span> <span class="nc">UrlResource</span><span class="o">(</span><span class="n">url</span><span class="o">));</span>
			<span class="o">}</span>
			<span class="k">catch</span> <span class="o">(</span><span class="nc">MalformedURLException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
				<span class="c1">// No URL -&gt; resolve as resource path.</span>
				<span class="c1">// 非url 尝试从 classpath 上下文中获取资源</span>
				<span class="k">return</span> <span class="nf">getResourceByPath</span><span class="o">(</span><span class="n">location</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * 通过路径获取 Resource 对象
	 * 从 classPath 中加载文件
	 */</span>
	<span class="kd">protected</span> <span class="nc">Resource</span> <span class="nf">getResourceByPath</span><span class="o">(</span><span class="nc">String</span> <span class="n">path</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">ClassPathContextResource</span><span class="o">(</span><span class="n">path</span><span class="o">,</span> <span class="n">getClassLoader</span><span class="o">());</span>
	<span class="o">}</span>


	<span class="kd">protected</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ClassPathContextResource</span> <span class="kd">extends</span> <span class="nc">ClassPathResource</span> <span class="kd">implements</span> <span class="nc">ContextResource</span> <span class="o">{</span>

		<span class="kd">public</span> <span class="nf">ClassPathContextResource</span><span class="o">(</span><span class="nc">String</span> <span class="n">path</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">ClassLoader</span> <span class="n">classLoader</span><span class="o">)</span> <span class="o">{</span>
			<span class="kd">super</span><span class="o">(</span><span class="n">path</span><span class="o">,</span> <span class="n">classLoader</span><span class="o">);</span>
		<span class="o">}</span>

		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getPathWithinContext</span><span class="o">()</span> <span class="o">{</span>
			<span class="k">return</span> <span class="nf">getPath</span><span class="o">();</span>
		<span class="o">}</span>
		
    <span class="cm">/**
    * 创建相对路径的 Resource 对象
    */</span>
		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="nc">Resource</span> <span class="nf">createRelative</span><span class="o">(</span><span class="nc">String</span> <span class="n">relativePath</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">String</span> <span class="n">pathToUse</span> <span class="o">=</span> <span class="nc">StringUtils</span><span class="o">.</span><span class="na">applyRelativePath</span><span class="o">(</span><span class="n">getPath</span><span class="o">(),</span> <span class="n">relativePath</span><span class="o">);</span>
			<span class="k">return</span> <span class="k">new</span> <span class="nf">ClassPathContextResource</span><span class="o">(</span><span class="n">pathToUse</span><span class="o">,</span> <span class="n">getClassLoader</span><span class="o">());</span>
		<span class="o">}</span>
	<span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>

<p>​	以上代码的逻辑比较简单明了,核心逻辑在 <code class="language-plaintext highlighter-rouge">getResource</code> 这个方法中.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="kd">public</span> <span class="nc">Resource</span> <span class="nf">getResource</span><span class="o">(</span><span class="nc">String</span> <span class="n">location</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="s">"Location must not be null"</span><span class="o">);</span>
		<span class="c1">// 遍历所有协议解析器</span>
		<span class="k">for</span> <span class="o">(</span><span class="nc">ProtocolResolver</span> <span class="n">protocolResolver</span> <span class="o">:</span> <span class="n">getProtocolResolvers</span><span class="o">())</span> <span class="o">{</span>
			<span class="c1">// 解析资源</span>
			<span class="nc">Resource</span> <span class="n">resource</span> <span class="o">=</span> <span class="n">protocolResolver</span><span class="o">.</span><span class="na">resolve</span><span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
			<span class="c1">// 如果资源解析到则返回 resource 对象</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">resource</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">return</span> <span class="n">resource</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="c1">// 判断是否是/开头</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"/"</span><span class="o">))</span> <span class="o">{</span>
			<span class="c1">// 获取classpath上下文中的资源</span>
			<span class="k">return</span> <span class="nf">getResourceByPath</span><span class="o">(</span><span class="n">location</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="c1">// 判断是否是classpath:开头路径,如果是则从classpath中获取资源</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="no">CLASSPATH_URL_PREFIX</span><span class="o">))</span> <span class="o">{</span>
			<span class="k">return</span> <span class="k">new</span> <span class="nf">ClassPathResource</span><span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="no">CLASSPATH_URL_PREFIX</span><span class="o">.</span><span class="na">length</span><span class="o">()),</span> <span class="n">getClassLoader</span><span class="o">());</span>
		<span class="o">}</span>
		<span class="k">else</span> <span class="o">{</span>
			<span class="k">try</span> <span class="o">{</span>
				<span class="c1">// 尝试把路径转化为url</span>
				<span class="c1">// Try to parse the location as a URL...</span>
				<span class="no">URL</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="n">location</span><span class="o">);</span>
				<span class="c1">// 判断是文件资源 还是url资源</span>
				<span class="k">return</span> <span class="o">(</span><span class="nc">ResourceUtils</span><span class="o">.</span><span class="na">isFileURL</span><span class="o">(</span><span class="n">url</span><span class="o">)</span> <span class="o">?</span> <span class="k">new</span> <span class="nc">FileUrlResource</span><span class="o">(</span><span class="n">url</span><span class="o">)</span> <span class="o">:</span> <span class="k">new</span> <span class="nc">UrlResource</span><span class="o">(</span><span class="n">url</span><span class="o">));</span>
			<span class="o">}</span>
			<span class="k">catch</span> <span class="o">(</span><span class="nc">MalformedURLException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
				<span class="c1">// No URL -&gt; resolve as resource path.</span>
				<span class="c1">// 非url 尝试从 classpath 上下文中获取资源</span>
				<span class="k">return</span> <span class="nf">getResourceByPath</span><span class="o">(</span><span class="n">location</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>​	逻辑流程为以下几步:</p>

<ol>
  <li>
    <p>判断是否设置了 协议解析器,如果设置了,则遍历所有的协议解析,</p>

    <p>并解析文件,如果解析成功则返回 Resource 对象否则执行第二步.</p>

    <ol>
      <li>判断路径是否是 <code class="language-plaintext highlighter-rouge">/ </code> 开头,若是则从classPath 加载文件,调用</li>
    </ol>

    <p><code class="language-plaintext highlighter-rouge">getResourceByPath</code>方法,返回 <code class="language-plaintext highlighter-rouge">Resource</code> 对象</p>

    <ol>
      <li>
        <p>判断是否是 <code class="language-plaintext highlighter-rouge">classpath:</code> 开头,若是则从 classPath 加载文件</p>
      </li>
      <li>
        <p>若是以上几步都失败,则尝试把路径转为URL,如果成功则返回</p>
      </li>
    </ol>

    <p><code class="language-plaintext highlighter-rouge">FileUrlResource</code> 或 <code class="language-plaintext highlighter-rouge">UrlResource</code> 对象</p>

    <ol>
      <li>最后挣扎以下,从classPath 加载文件</li>
    </ol>
  </li>
</ol>

<h2 id="24-fileurlresource">2.4 FileUrlResource</h2>

<p>​	开篇说道 spring 默认支持 9中协议(如果把 classPath 也算上的话),那么除了 常用的 classPath 以外,其他的怎么使用呢?其他的笔者本人都没用过多少,就来看看 file 协议吧.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
	<span class="nd">@Test</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSpringResourceLoaderForFileProtocol</span><span class="o">(){</span>
		<span class="nc">DefaultResourceLoader</span> <span class="n">defaultResourceLoader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DefaultResourceLoader</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">());</span>
		<span class="nc">BeanFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XmlBeanFactory</span><span class="o">(</span><span class="n">defaultResourceLoader</span><span class="o">.</span><span class="na">getResource</span><span class="o">(</span><span class="s">"file:///src/test/resources/com/sjr/test/bean/MyTestBean.xml"</span><span class="o">));</span>
		<span class="kd">final</span> <span class="nc">MyTestBean</span> <span class="n">testBean</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"myTestBean"</span><span class="o">,</span><span class="nc">MyTestBean</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
		<span class="kd">final</span> <span class="nc">String</span> <span class="n">testStr</span> <span class="o">=</span> <span class="n">testBean</span><span class="o">.</span><span class="na">getTestStr</span><span class="o">();</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">testStr</span><span class="o">);</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>​	相当于是个绝对路径了.其他协议可以查查资料.</p>

<h1 id="三自定义文件协议解析器">三、自定义文件协议解析器</h1>

<p>​	在<code class="language-plaintext highlighter-rouge">DefaultResourceLoader</code> 中的核心代码中有段遍历解析器的代码,来瞧瞧.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="c1">// 遍历所有协议解析器</span>
		<span class="k">for</span> <span class="o">(</span><span class="nc">ProtocolResolver</span> <span class="n">protocolResolver</span> <span class="o">:</span> <span class="n">getProtocolResolvers</span><span class="o">())</span> <span class="o">{</span>
			<span class="c1">// 解析资源</span>
			<span class="nc">Resource</span> <span class="n">resource</span> <span class="o">=</span> <span class="n">protocolResolver</span><span class="o">.</span><span class="na">resolve</span><span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
			<span class="c1">// 如果资源解析到则返回 resource 对象</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">resource</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">return</span> <span class="n">resource</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
</code></pre></div></div>

<p>​	通过这段代码,可以实现自定义文件协议解析器的逻辑,方便扩展.<code class="language-plaintext highlighter-rouge">ProtocolResolver</code>是个接口,里面就一个方法,非常简单.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ProtocolResolver</span> <span class="o">{</span>

	<span class="cm">/**
	 * 解析
	 */</span>
	<span class="nd">@Nullable</span>
	<span class="nc">Resource</span> <span class="nf">resolve</span><span class="o">(</span><span class="nc">String</span> <span class="n">location</span><span class="o">,</span> <span class="nc">ResourceLoader</span> <span class="n">resourceLoader</span><span class="o">);</span>

<span class="o">}</span>

</code></pre></div></div>

<p>​	该接口也是个函数接口(可以使用Lambda表达式).来实现一个协议试一试.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 实现ProtocolResolver 接口 自定义解析逻辑</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SjrProtocolResolver</span> <span class="kd">implements</span> <span class="nc">ProtocolResolver</span> <span class="o">{</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nc">Resource</span> <span class="nf">resolve</span><span class="o">(</span><span class="nc">String</span> <span class="n">location</span><span class="o">,</span> <span class="nc">ResourceLoader</span> <span class="n">resourceLoader</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">resourceLoader</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
			<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">if</span><span class="o">(</span><span class="n">location</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">location</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"sjr"</span><span class="o">)){</span>
			<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="kd">final</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">location</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">"sjr:"</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">resourceLoader</span><span class="o">.</span><span class="na">getResource</span><span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">4</span><span class="o">));</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSpringProtocolResolverOfAdv</span><span class="o">(){</span>
		<span class="nc">DefaultResourceLoader</span> <span class="n">defaultResourceLoader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DefaultResourceLoader</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">());</span>
		<span class="n">defaultResourceLoader</span><span class="o">.</span><span class="na">addProtocolResolver</span><span class="o">(</span><span class="k">new</span> <span class="nc">SjrProtocolResolver</span><span class="o">());</span>
		<span class="nc">BeanFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XmlBeanFactory</span><span class="o">(</span><span class="n">defaultResourceLoader</span><span class="o">.</span><span class="na">getResource</span><span class="o">(</span><span class="s">"sjr:com/sjr/test/bean/MyTestBean.xml"</span><span class="o">));</span>
		<span class="kd">final</span> <span class="nc">MyTestBean</span> <span class="n">testBean</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"myTestBean"</span><span class="o">,</span><span class="nc">MyTestBean</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
		<span class="kd">final</span> <span class="nc">String</span> <span class="n">testStr</span> <span class="o">=</span> <span class="n">testBean</span><span class="o">.</span><span class="na">getTestStr</span><span class="o">();</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">testStr</span><span class="o">);</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>​	这样就完成了自定义协议的解析.</p>

<p>​	<code class="language-plaintext highlighter-rouge">DefaultResourceLoader</code> 还有三个子类:</p>

<ul>
  <li>
    <p>ServletContextResourceLoader</p>

    <p>返回<code class="language-plaintext highlighter-rouge">ServletContextResource</code>,从<code class="language-plaintext highlighter-rouge">ServletContext</code>获取资源.</p>
  </li>
  <li>
    <p>FileSystemResourceLoader</p>

    <p>返回<code class="language-plaintext highlighter-rouge">FileSystemContextResource</code> ,从文件系统中获取资源,</p>

    <p>其本质上是<code class="language-plaintext highlighter-rouge">FileSystemResource</code>,实现了<code class="language-plaintext highlighter-rouge">ContextResource</code>接口</p>
  </li>
  <li>
    <p>ClassRelativeResourceLoader</p>

    <p>返回<code class="language-plaintext highlighter-rouge">ClassRelativeContextResource</code> ,从classPath获取资源,</p>

    <p>其本质上是<code class="language-plaintext highlighter-rouge">ClassPathResource</code>,实现了<code class="language-plaintext highlighter-rouge">ContextResource</code>接口</p>

    <p>这三个子类,都是做的简单扩展,逻辑简单,有兴趣可以去看看.</p>
  </li>
</ul>

<h1 id="四小结">四、小结</h1>

<p>​	文件是加载到,那么spring 是怎么解析xml文件的呢?</p>
