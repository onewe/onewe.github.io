<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://onew.me/feed.xml" rel="self" type="application/atom+xml" /><link href="https://onew.me/" rel="alternate" type="text/html" hreflang="zh" /><updated>2021-01-19T22:30:22+08:00</updated><id>https://onew.me/feed.xml</id><title type="html">ä¸€æ°´å¼€å‘ç¬”è®°</title><subtitle>java,å¤šçº¿ç¨‹,jvm,redis,redisdesktopmanager,postgresql
</subtitle><author><name>onew</name><email>admin@onew.me</email></author><entry><title type="html">WebLogic Metaspace OOM è§£å†³æ¡ˆä¾‹</title><link href="https://onew.me/java/2021/01/19/Weblogic-Metaspace-OOM.html" rel="alternate" type="text/html" title="WebLogic Metaspace OOM è§£å†³æ¡ˆä¾‹" /><published>2021-01-19T22:01:25+08:00</published><updated>2021-01-19T22:01:25+08:00</updated><id>https://onew.me/java/2021/01/19/Weblogic-Metaspace-OOM</id><content type="html" xml:base="https://onew.me/java/2021/01/19/Weblogic-Metaspace-OOM.html">&lt;h1 id=&quot;weblogic-metaspace-oom-è§£å†³æ¡ˆä¾‹&quot;&gt;WebLogic Metaspace OOM è§£å†³æ¡ˆä¾‹&lt;/h1&gt;

&lt;h2 id=&quot;ä¸€å‰è¨€&quot;&gt;ä¸€ã€å‰è¨€&lt;/h2&gt;

&lt;p&gt;â€‹	ä¼°è®¡ä¹Ÿåªæœ‰æˆ‘è¿™ä¹ˆæƒ¨äº†ï¼Œéƒ½0202å¹´äº†è¿˜åœ¨ç”¨weblogicè¿™ç§ä¸Šå¤ç¥å™¨ã€‚æ•…äº‹è¦ä»å‰æ®µæ—¶é—´è¯´èµ·,è‡³äºæ˜¯å¤šä¹…æ—¶é—´ï¼Œæˆ‘ä¹Ÿå¿˜è®°äº†ã€‚&lt;/p&gt;

&lt;p&gt;â€‹	æŸæ—¥ï¼Œçº¿ä¸Šå‘å¸ƒç‰ˆæœ¬,åœ¨weblogicæ§åˆ¶å°æ›´æ–°çš„æ—¶å€™,ç›´æ¥å¡æ­»æ— å“åº”ã€‚ä¸€æ‰“å¼€æ—¥å¿—ä¸€ç§ï¼Œå¥½å®¶ä¼™ï¼ŒOOMäº†ï¼Œè¿˜æ˜¯ä¸ªmetaspaceçš„OOMã€‚&lt;/p&gt;

&lt;p&gt;â€‹	è¿™ç©æ„å„¿å°±æœ‰ç‚¹å¥‡æ€ªäº†ï¼ŒmetaspaceæŒ‰é“ç†æ˜¯å­˜æ”¾çš„ç±»ä¿¡æ¯ï¼Œå­—é¢é‡ï¼ˆLiteralï¼‰ã€ç±»é™æ€å˜é‡ï¼ˆClass Staticï¼‰ã€ç¬¦å·å¼•ç”¨ï¼ˆSymbols Referenceï¼‰ç­‰ç›¸å…³ä¿¡æ¯ã€‚ç±»ç›¸å…³ä¿¡æ¯åœ¨metaspaceé‡Œé¢åˆåˆ†ä¸º2å—åŒºåŸŸ,&lt;strong&gt;Klass MetaSpace&lt;/strong&gt;å’Œ&lt;strong&gt;NoKlass MetaSpace&lt;/strong&gt;ã€‚è¿™å°±ä¸ç»†è®²äº†ï¼Œä¸ç„¶æ‰¯ä¸å®Œã€‚&lt;/p&gt;

&lt;p&gt;â€‹	ä¹Ÿå°±è¯´ä¸€èˆ¬æƒ…å†µä¸‹è¿™ç©æ„å„¿æ˜¯ä¸ä¼šOOMæ‰çš„ï¼ˆé™¤å¼€metaspaceå¤§å°è®¾ç½®ä¸åˆç†çš„æƒ…å†µï¼‰&lt;/p&gt;

&lt;h2 id=&quot;äºŒåˆ†æ&quot;&gt;äºŒã€åˆ†æ&lt;/h2&gt;

&lt;p&gt;â€‹	ç»“åˆå®é™…æƒ…å†µMetaspace OOM å¯èƒ½çš„æƒ…å†µæ˜¯ï¼Œä»¥ä¸‹2ç§æƒ…å†µï¼š&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- å¤§é‡ä½¿ç”¨åå°„ï¼Œç”±äºJVMçš„ä¼˜åŒ–æœºåˆ¶ï¼Œä¼šå®šä¹‰ä¸€äº›ç±»å‡ºæ¥ï¼Œå¯¼è‡´ç±»åŠ è½½æ•°é‡å¢å¤šã€‚
- JAXB BUG å¯¼è‡´ï¼Œç½‘ä¸Šæœ‰å¾ˆå¤šæ–‡ç« åœ¨åˆ†æ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;21-æƒ…å†µä¸€&quot;&gt;2.1 æƒ…å†µä¸€ï¼š&lt;/h3&gt;

&lt;p&gt;â€‹	çš„ç¡®é¡¹ç›®é‡Œé¢å­˜åœ¨å¤§é‡çš„åå°„ï¼Œå†è¯´äº†ä½¿ç”¨äº†spring æ¡†æ¶ï¼Œåå°„æ˜¯é¿å…ä¸äº†çš„ï¼Œè¿™ä¸ªæ²¡åŠæ³•ã€‚ä½†æ˜¯è¿™ç§æƒ…å†µè¯´ä¸é€šï¼Œå°±ç®—ç±»å¤§é‡çš„å¢é•¿ï¼Œä½†ä»æœªè§è¿‡æœ‰å¸è½½ç±»çš„æƒ…å†µã€‚æ’é™¤ï½ï¼&lt;/p&gt;

&lt;h3 id=&quot;22-æƒ…å†µäºŒ&quot;&gt;2.2 æƒ…å†µäºŒï¼š&lt;/h3&gt;

&lt;p&gt;â€‹	JAXB è¿™ä¸ªæƒ…å†µçš„ç¡®å¯èƒ½å­˜åœ¨ï¼Œæ¯•ç«Ÿæ˜¯è€é¡¹ç›®ï¼Œä½†è¿™ä¸ªæ²¡æœ‰å®é™…çš„è¯æ®ï¼Œéœ€è¦è¿›ä¸€æ­¥çš„è¿›è¡Œåˆ†æã€‚&lt;/p&gt;

&lt;h3 id=&quot;23-ä»€ä¹ˆæ—¶å€™å¸è½½ç±»&quot;&gt;2.3 ä»€ä¹ˆæ—¶å€™å¸è½½ç±»ï¼Ÿ&lt;/h3&gt;

&lt;p&gt;â€‹	å¸è½½ç±»è¦æ»¡è¶³3ä¸ªæ¡ä»¶ï¼ŒGCæ‰ä¼šå¯¹å…¶è¿›è¡Œå¸è½½ï¼Œå¹¶å›æ”¶ç©ºé—´ï¼š&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- è¯¥ç±»æ‰€æœ‰çš„å®ä¾‹å·²ç»è¢«å›æ”¶
- åŠ è½½è¯¥ç±»çš„CLassLoaderå·²ç»è¢«å›æ”¶
- è¯¥ç±»å¯¹åº”çš„CLasså¯¹è±¡æ²¡æœ‰ä»»ä½•å¼•ç”¨
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;çœ‹å¾—å‡ºï¼Œå¸è½½ä¸€ä¸ªç±»æ¡ä»¶æ¯”è¾ƒè‹›åˆ»ï¼Œé‚£å°±æŒ‰ç…§ä¸Šè¿°3ä¸ªæ¡ä»¶è¿›è¡Œé—®é¢˜æ’æŸ¥ã€‚&lt;/p&gt;

&lt;h2 id=&quot;ä¸‰æ’æŸ¥&quot;&gt;ä¸‰ã€æ’æŸ¥&lt;/h2&gt;

&lt;h3 id=&quot;31-å¤ç°&quot;&gt;3.1 å¤ç°&lt;/h3&gt;

&lt;p&gt;â€‹	è§£å†³é—®é¢˜çš„å‰ææ˜¯èƒ½å¤Ÿå¤ç°é—®é¢˜ï¼Œå¥½åœ¨è¿™æ¬¡é—®é¢˜æ¯”è¾ƒå®¹æ˜“å¤ç°å‡ºæ¥ã€‚&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ç¯å¢ƒï¼š
	- weblogic 12c
    &lt;ul&gt;
      &lt;li&gt;jdk 1.8&lt;/li&gt;
      &lt;li&gt;metaspace 512M maxMetaspace1024M&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;æ­¥éª¤ï¼š
    &lt;ul&gt;
      &lt;li&gt;åœ¨æ§åˆ¶å°ä¸­ä½¿ç”¨æ›´æ–°åŠŸèƒ½ï¼Œé‡å¤éƒ¨ç½²å¤šæ¬¡&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;è§‚å¯Ÿï¼š
    &lt;ul&gt;
      &lt;li&gt;ä½¿ç”¨jdkè‡ªå¸¦&lt;em&gt;Java VisualVM&lt;/em&gt;ï¼Œè§‚å¯Ÿmetaspaceå†…å­˜çš„å¢é•¿ï¼Œä»¥åŠä¸€ä¸ªclassçš„åŠ è½½æ•°é‡å’Œå¸è½½æ•°é‡&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ç°è±¡ï¼š
    &lt;ul&gt;
      &lt;li&gt;classä¸€ç›´åœ¨å¢é•¿ï¼Œæ²¡æœ‰å‡ºç°è¿‡å¤§å¹…åº¦çš„ä¸‹è·Œ&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/6I8w1m7fhSo9Grx.png&quot; alt=&quot;6I8w1m7fhSo9Grx&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;æ€»å…±æ›´æ–°äº†2æ¬¡è½½å…¥äº†7W+çš„ç±»ï¼Œå¸è½½å´ä¸åˆ°3Kï¼Œè¿™ä¸ªç»“æœå°±ç¦»è°±ã€‚&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;32-å†…å­˜åˆ†æ&quot;&gt;3.2 å†…å­˜åˆ†æ&lt;/h3&gt;

&lt;p&gt;â€‹	æŠŠheap dumpä¸‹æ¥ï¼Œçœ‹çœ‹ã€‚åˆ°åº•æ˜¯å•¥å¯¼è‡´æ²¡æœ‰å¸è½½ã€‚å‰æ–‡è¯´äº†ï¼Œå¸è½½ä¸€ä¸ªç±»è¦æ»¡è¶³3ä¸ªæ¡ä»¶ã€‚é‚£å°±æŒ‰ç…§3ä¸ªæ¡ä»¶è¿›è¡Œåˆ†æã€‚&lt;/p&gt;

&lt;p&gt;â€‹	ä½†åŠ è½½ç±»æ˜¯åœ¨å¤ªå¤šï¼Œä¸å¯èƒ½ä¸€ä¸ªä¸€ä¸ªçš„å»åˆ†æã€‚ä»3ä¸ªæ¡ä»¶æ¥çœ‹ï¼Œåˆ†æclassloaderæ˜¯æœ€é è°±çš„ï¼Œæ¯•ç«Ÿæ‰€æœ‰ç±»çš„åŠ è½½éƒ½æ˜¯ç”±classloaderè¿›è¡ŒåŠ è½½çš„ï¼Œè€Œä¸”classloaderæ•°é‡ç›¸å¯¹è¾ƒå°‘ã€‚&lt;/p&gt;

&lt;p&gt;â€‹	é€šè¿‡matåˆ†æï¼Œæ£€æµ‹å‡ºæœ‰3ä¸ªé—®é¢˜,2ä¸ªéƒ½æ˜¯ChangeAwareCloaderï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/Mwg4flXxK9pU5HL.png&quot; alt=&quot;Mwg4flXxK9pU5HL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;çœ‹æ¥æ–¹å‘æ²¡é”™ï¼Œå»weblogicå®˜æ–¹çœ‹äº†ä¸€ä¸‹ï¼Œä¸Šå›¾ä¸­çš„classloaderæ˜¯è´Ÿè´£æ›´æ–°classçš„ã€‚ç‚¹å¼€è¯¦æƒ…çœ‹ä¸€ä¸‹ï¼Œå‘ç°æ˜¯nacosçš„çº¿ç¨‹holdä½äº†classloaderå¯¼è‡´ï¼Œå˜¿å˜¿ç ´æ¡ˆäº†ã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/wOGNxqotD6rgu18.png&quot; alt=&quot;wOGNxqotD6rgu18&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;33-è¿™è¯¥æ­»çš„çº¿ç¨‹&quot;&gt;3.3 è¿™è¯¥æ­»çš„çº¿ç¨‹&lt;/h3&gt;

&lt;p&gt;â€‹	é€šè¿‡ä¸Šé¢çš„åˆ†æï¼Œå‘ç°æ˜¯nacosåœ¨springåœæ­¢çš„æ—¶å€™å¹¶æ²¡æœ‰åœæ­¢ç›¸å…³çº¿ç¨‹ï¼Œå¯¼è‡´è¯¥çº¿ç¨‹ä¸€ç›´åœ¨åå°æ´»è·ƒã€‚ç”±äºçº¿ç¨‹æ²¡æœ‰é€€å‡ºï¼Œé‚£ä¹ˆç›¸åº”çš„classloaderå°±ä¸èƒ½è¢«å›æ”¶ã€‚&lt;/p&gt;

&lt;p&gt;â€‹	æˆ‘TMåæ‰‹ä¸€ä¸ª&lt;a href=&quot;https://github.com/alibaba/spring-cloud-alibaba/pull/1892&quot;&gt;pr&lt;/a&gt;åˆ°nacosã€‚&lt;/p&gt;

&lt;h3 id=&quot;34-éªŒè¯&quot;&gt;3.4 éªŒè¯&lt;/h3&gt;

&lt;p&gt;â€‹	é—®é¢˜åŸå› æ‰¾åˆ°äº†ï¼Œå°±æ›¿æ¢æ‰åŸç”±é¡¹ç›®çš„nacosï¼Œæ¢ä¸Šä¸€ä¸ªåœæ­¢springçš„æ—¶å€™é”€æ¯nacosçº¿ç¨‹ç‰ˆæœ¬ï¼ŒéªŒè¯ä¸€ä¸‹æ˜¯å¦è§£å†³ã€‚&lt;/p&gt;

&lt;p&gt;â€‹	ç”±äºæ˜¯çº¿ç¨‹å¼•èµ·çš„ï¼Œæ‰€ä»¥åœ¨éªŒè¯çš„è¿‡ç¨‹ä¸­ï¼Œè¦æ ¼å¤–æ³¨æ„ï¼Œnacosçº¿ç¨‹æ˜¯å¦è¢«æ­£å¸¸å…³é—­ã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/7Csbdgv84VhxZwt.jpg&quot; alt=&quot;7Csbdgv84VhxZwt&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ä¸Šå›¾ä¸ºweblogicä¸€ä¸ªçº¿ç¨‹æˆªå›¾ã€‚å¯ä»¥çœ‹åˆ°nacosç›¸å…³çš„çº¿ç¨‹æœ‰6ä¸ªã€‚æ­¤æ—¶åœæ­¢åº”ç”¨ï¼Œnacosçº¿ç¨‹å·²ç»è¢«æ­£å¸¸çš„é”€æ¯äº†ã€‚&lt;/p&gt;

&lt;p&gt;â€‹	çº¿ç¨‹å·²ç»è¢«æ­£å¸¸é”€æ¯ï¼Œå†æ¥éªŒè¯æ˜¯å¦èƒ½å¤Ÿæ­£å¸¸å¸è½½classã€‚é‡å¤éƒ¨ç½²2æ¬¡ï¼Œå†è¿›è¡Œè§‚å¯Ÿã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/8WXGmiIpM2fdDaK.png&quot; alt=&quot;8WXGmiIpM2fdDaK&quot; /&gt;&lt;/p&gt;

&lt;p&gt;â€‹	è¿˜æ˜¯ç¦»è°±ï¼Œä¾æ—§æ²¡æœ‰è¢«å¸è½½ï¼Œçœ‹æ¥é—®é¢˜æ²¡æœ‰è¢«æ ¹æœ¬è§£å†³ã€‚ä¼šä¸ä¼šæ˜¯è¿˜æœ‰å•¥çº¿ç¨‹æ²¡æœ‰è¢«å…³é—­å‘¢ã€‚å†å»æ‰¾æ‰¾çœ‹çœ‹ã€‚å…ˆåœæ­¢åº”ç”¨ï¼Œçœ‹çœ‹å“ªäº›çº¿ç¨‹è¿˜åœ¨åå°è¿è¡Œã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/V1Za2sfGzMFmyx7.jpg&quot; alt=&quot;V1Za2sfGzMFmyx7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;æ‰’äº†ä¸€ä¸‹ï¼Œè¿˜æœ‰ä¸€ä¸ªçº¿ç¨‹æ²¡æœ‰æ­£å¸¸é”€æ¯ã€‚æ”¹æ”¹ä»£ç å†è¯•ä¸€ä¸‹å§0.0.&lt;/p&gt;

&lt;h3 id=&quot;35-è¿˜æ˜¯è¿™è¯¥æ­»çš„çº¿ç¨‹&quot;&gt;3.5 è¿˜æ˜¯è¿™è¯¥æ­»çš„çº¿ç¨‹&lt;/h3&gt;

&lt;p&gt;â€‹	è™½ç„¶æŠŠnacosçš„çº¿ç¨‹ç»™é”€æ¯äº†ï¼Œä½†è¿˜æœ‰ä¸šåŠ¡çº¿ç¨‹è¿˜åœ¨è·‘ï¼Œå†æµ‹è¯•ä¸€æŠŠï¼Œçœ‹çœ‹èƒ½ä¸èƒ½æ­£å¸¸çš„å›æ”¶classã€‚ç»è¿‡æµ‹è¯•æ²¡æœ‰å‡ºç°å¯ä»¥çš„çº¿ç¨‹äº†ã€‚æ„Ÿè§‰è‡ªå·±åˆè¡Œäº†ã€‚&lt;/p&gt;

&lt;p&gt;â€‹	ç»§ç»­æµ‹è¯•ï¼Œé‡å¤éƒ¨ç½²ï¼ŒéªŒè¯æ˜¯å¦èƒ½å¤Ÿæ­£å¸¸å¸è½½classã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/EhGkgSMz71sbZeC.png&quot; alt=&quot;EhGkgSMz71sbZeC&quot; /&gt;&lt;/p&gt;

&lt;p&gt;è¿˜æ˜¯ç¦»è°±ï¼ŒåŠ è½½äº†7Wå¤šçš„ç±»ï¼Œå¸è½½æ‰4Kå¤šç‚¹ï¼Œè¿™è¿˜æ˜¯ä¸æ­£å¸¸ã€‚æœç„¶ï¼Œè¿™ä¸ªå·¥ç¨‹çš„é—®é¢˜å¾ˆå¤šå‘€ã€‚&lt;/p&gt;

&lt;h3 id=&quot;36-é‡æ–°åˆ†æå†…å­˜è®¨åŒçš„ç›‘æ§&quot;&gt;3.6 é‡æ–°åˆ†æå†…å­˜,è®¨åŒçš„ç›‘æ§&lt;/h3&gt;

&lt;p&gt;â€‹	çº¿ç¨‹çš„é—®é¢˜è§£å†³äº†ï¼Œä½†é—®é¢˜ä¾æ—§ï¼Œåªèƒ½å†dumpä¸€ä»½å†…å­˜çœ‹çœ‹ã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/u6wdjzoRpvADNYT.png&quot; alt=&quot;u6wdjzoRpvADNYT&quot; /&gt;&lt;/p&gt;

&lt;p&gt;é—®é¢˜è¿˜æ˜¯åœ¨classLoaderä¸Šï¼Œå»è¯¦æƒ…çœ‹çœ‹ã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/YPCexIzNHrbq3Ud.png&quot; alt=&quot;YPCexIzNHrbq3Ud&quot; /&gt;&lt;/p&gt;

&lt;p&gt;classloaderè¢«Loggerç»™holdä½äº†ï¼Œè¿™æœ‰ç‚¹å¥‡æ€ªäº†ã€‚ç”±ä¸Šå›¾å¯ä»¥çœ‹å‡ºï¼ŒchangeAwareClassLoaderåŠ è½½äº†LoggingHandlerï¼Œåœ¨Loggerä¸­å¼•ç”¨äº†LoggingHandlerï¼Œè¿™ä¸ªLoggeræ˜¯ç³»ç»Ÿç±»ï¼Œ&lt;/p&gt;

&lt;p&gt;â€‹	ç”±äºLoggeræ˜¯ç³»ç»Ÿç±»ï¼Œç”±jvmçš„&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bootstrap ClassLoader&lt;/code&gt;åŠ è½½ï¼Œè¿™ä¸ªclassloaderçš„ç”Ÿå‘½å‘¨æœŸå°±å¾ˆé•¿äº†ï¼Œåªæœ‰jvmè¿›ç¨‹é€€å‡ºï¼Œæ‰ä¼šè¢«é”€æ¯æ‰ã€‚&lt;/p&gt;

&lt;p&gt;â€‹	åªèƒ½ç¿»ä¸€ä¸‹LoggingHandlerçš„ä»£ç ï¼Œçœ‹ä¸‹ä¸ºå•¥è¦å»è·ŸLoggeræ‰¯ä¸Šå…³ç³»ã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/DNiQLXeBqAIna6K.png&quot; alt=&quot;DNiQLXeBqAIna6K&quot; /&gt;&lt;/p&gt;

&lt;p&gt;è¿™ä¸ªç©æ„å„¿åœ¨å¯åŠ¨çš„æ—¶å€™å›å»æ³¨å†Œä¸€ä¸‹ï¼Œè·å–çš„æ˜¯ç³»ç»Ÿçš„Loggerï¼Œæ€ªä¸å¾—ä¼šæ‰¯ä¸Šå…³ç³»ã€‚ä¸çŸ¥é“ä¸ºå•¥æ²¡æœ‰è¢«å–æ¶ˆæ³¨å†Œï¼Œå–æ¶ˆæ³¨å†Œçš„æ–¹æ³•å€’æ˜¯æœ‰ä¸ªã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/Erv2pmXdNyPRlGq.png&quot; alt=&quot;Erv2pmXdNyPRlGq&quot; /&gt;&lt;/p&gt;

&lt;p&gt;çŒœæµ‹æ˜¯jaråŒ…ç‰ˆæœ¬å†²çªå¯¼è‡´å‡ºç°äº†å¼‚å¸¸ï¼Œå°±æ²¡æœ‰æŠŠå–æ¶ˆæ³¨å†Œæµç¨‹ç»™èµ°å®Œã€‚é—®äº†ä¸€ä¸‹åŒäº‹ï¼Œè¯´è¿™ä¸ªLoggingHandleræ˜¯å±äºä¸€ä¸ªç›‘æ§ï¼Œè¿™ä¸ªç›‘æ§æ¯”è¾ƒè€ï¼Œå¯ä»¥ç›´æ¥ä¸‹æ‰ã€‚é‚£å°±ä¸å»çº ç»“ä¸ºå•¥æ²¡æœ‰å–æ¶ˆæ³¨å†Œäº†ï¼Œç›´æ¥ä¸‹æ‰çœ‹ç–—æ•ˆã€‚&lt;/p&gt;

&lt;h3 id=&quot;37-é‡æ–°éªŒè¯&quot;&gt;3.7 é‡æ–°éªŒè¯&lt;/h3&gt;

&lt;p&gt;â€‹	æŠŠç›‘æ§çš„jaråŒ…ä¸‹æ‰ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½è¾¾åˆ°é¢„æœŸçš„æ•ˆæœã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/ZhkNoL9AjsxR5dn.png&quot; alt=&quot;ZhkNoL9AjsxR5dn&quot; /&gt;&lt;/p&gt;

&lt;p&gt;weblogicåˆå§‹çŠ¶æ€ï¼Œä¸€ç‰‡ç¥¥å’Œã€‚&lt;/p&gt;

&lt;p&gt;é‡å¤éƒ¨ç½²3æ¬¡ï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/seum7EkIF83Qb1i.png&quot; alt=&quot;seum7EkIF83Qb1i&quot; /&gt;&lt;/p&gt;

&lt;p&gt;è¿˜æ˜¯æ²¡å¸è½½ï¼Œç¦»è°±ï¼Œçœ‹æ¥è¦ç¿»è½¦äº†ã€‚ä¸æ€¥é™ªä»–è€è€ï¼Œç­‰ä»–ä¸ª10åˆ†é’Ÿï¼Œçœ‹ä»–è‡ªå·±æŠ•é™ã€‚æ˜¯ä¸æ˜¯è§‰å¾—æ˜¯ç„å­¦ğŸ˜‚ã€‚å¯¹ï¼Œè¿˜çœŸä¸æ˜¯ç„å­¦ï¼Œæœ‰äº›ä¸œè¥¿æ²¡æœ‰åŠæ—¶é‡Šæ”¾ï¼Œæ˜¯å› ä¸ºåœ¨finalizeé˜Ÿåˆ—ä¸­æ’é˜Ÿå‘¢ï¼Œç­‰ä¸€ä¸‹å°±å¥½ã€‚&lt;/p&gt;

&lt;p&gt;10åˆ†é’Ÿä¹‹åï¼Œä¸å¯¹åº”è¯¥æ˜¯å‡ºå»åƒé¥­è¿‡åï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/5ybVJMqUr3I1WjR.png&quot; alt=&quot;5ybVJMqUr3I1WjR&quot; /&gt;&lt;/p&gt;

&lt;p&gt;metaspaceçš„å ç”¨æ°´å¹³å·²å›å½’åˆ°æ­£å¸¸çš„æ°´å¹³ï¼Œç±»å¸è½½ä»4000åˆ°äº†28000ã€‚&lt;/p&gt;

&lt;p&gt;åå¤éƒ¨ç½²åï¼Œmetaspaceå†…å­˜ä¹Ÿç¨³å®šåˆ°600Mã€‚okï¼Œå®Œç¾è§£å†³ã€‚&lt;/p&gt;

&lt;p&gt;â€‹&lt;/p&gt;</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="java" /><category term="java" /><category term="Weblogic" /><category term="metaspace oom" /><summary type="html">WebLogic Metaspace OOM è§£å†³æ¡ˆä¾‹ ä¸€ã€å‰è¨€ â€‹ ä¼°è®¡ä¹Ÿåªæœ‰æˆ‘è¿™ä¹ˆæƒ¨äº†ï¼Œéƒ½0202å¹´äº†è¿˜åœ¨ç”¨weblogicè¿™ç§ä¸Šå¤ç¥å™¨ã€‚æ•…äº‹è¦ä»å‰æ®µæ—¶é—´è¯´èµ·,è‡³äºæ˜¯å¤šä¹…æ—¶é—´ï¼Œæˆ‘ä¹Ÿå¿˜è®°äº†ã€‚ â€‹ æŸæ—¥ï¼Œçº¿ä¸Šå‘å¸ƒç‰ˆæœ¬,åœ¨weblogicæ§åˆ¶å°æ›´æ–°çš„æ—¶å€™,ç›´æ¥å¡æ­»æ— å“åº”ã€‚ä¸€æ‰“å¼€æ—¥å¿—ä¸€ç§ï¼Œå¥½å®¶ä¼™ï¼ŒOOMäº†ï¼Œè¿˜æ˜¯ä¸ªmetaspaceçš„OOMã€‚ â€‹ è¿™ç©æ„å„¿å°±æœ‰ç‚¹å¥‡æ€ªäº†ï¼ŒmetaspaceæŒ‰é“ç†æ˜¯å­˜æ”¾çš„ç±»ä¿¡æ¯ï¼Œå­—é¢é‡ï¼ˆLiteralï¼‰ã€ç±»é™æ€å˜é‡ï¼ˆClass Staticï¼‰ã€ç¬¦å·å¼•ç”¨ï¼ˆSymbols Referenceï¼‰ç­‰ç›¸å…³ä¿¡æ¯ã€‚ç±»ç›¸å…³ä¿¡æ¯åœ¨metaspaceé‡Œé¢åˆåˆ†ä¸º2å—åŒºåŸŸ,Klass MetaSpaceå’ŒNoKlass MetaSpaceã€‚è¿™å°±ä¸ç»†è®²äº†ï¼Œä¸ç„¶æ‰¯ä¸å®Œã€‚ â€‹ ä¹Ÿå°±è¯´ä¸€èˆ¬æƒ…å†µä¸‹è¿™ç©æ„å„¿æ˜¯ä¸ä¼šOOMæ‰çš„ï¼ˆé™¤å¼€metaspaceå¤§å°è®¾ç½®ä¸åˆç†çš„æƒ…å†µï¼‰ äºŒã€åˆ†æ â€‹ ç»“åˆå®é™…æƒ…å†µMetaspace OOM å¯èƒ½çš„æƒ…å†µæ˜¯ï¼Œä»¥ä¸‹2ç§æƒ…å†µï¼š - å¤§é‡ä½¿ç”¨åå°„ï¼Œç”±äºJVMçš„ä¼˜åŒ–æœºåˆ¶ï¼Œä¼šå®šä¹‰ä¸€äº›ç±»å‡ºæ¥ï¼Œå¯¼è‡´ç±»åŠ è½½æ•°é‡å¢å¤šã€‚ - JAXB BUG å¯¼è‡´ï¼Œç½‘ä¸Šæœ‰å¾ˆå¤šæ–‡ç« åœ¨åˆ†æ 2.1 æƒ…å†µä¸€ï¼š â€‹ çš„ç¡®é¡¹ç›®é‡Œé¢å­˜åœ¨å¤§é‡çš„åå°„ï¼Œå†è¯´äº†ä½¿ç”¨äº†spring æ¡†æ¶ï¼Œåå°„æ˜¯é¿å…ä¸äº†çš„ï¼Œè¿™ä¸ªæ²¡åŠæ³•ã€‚ä½†æ˜¯è¿™ç§æƒ…å†µè¯´ä¸é€šï¼Œå°±ç®—ç±»å¤§é‡çš„å¢é•¿ï¼Œä½†ä»æœªè§è¿‡æœ‰å¸è½½ç±»çš„æƒ…å†µã€‚æ’é™¤ï½ï¼ 2.2 æƒ…å†µäºŒï¼š â€‹ JAXB è¿™ä¸ªæƒ…å†µçš„ç¡®å¯èƒ½å­˜åœ¨ï¼Œæ¯•ç«Ÿæ˜¯è€é¡¹ç›®ï¼Œä½†è¿™ä¸ªæ²¡æœ‰å®é™…çš„è¯æ®ï¼Œéœ€è¦è¿›ä¸€æ­¥çš„è¿›è¡Œåˆ†æã€‚ 2.3 ä»€ä¹ˆæ—¶å€™å¸è½½ç±»ï¼Ÿ â€‹ å¸è½½ç±»è¦æ»¡è¶³3ä¸ªæ¡ä»¶ï¼ŒGCæ‰ä¼šå¯¹å…¶è¿›è¡Œå¸è½½ï¼Œå¹¶å›æ”¶ç©ºé—´ï¼š - è¯¥ç±»æ‰€æœ‰çš„å®ä¾‹å·²ç»è¢«å›æ”¶ - åŠ è½½è¯¥ç±»çš„CLassLoaderå·²ç»è¢«å›æ”¶ - è¯¥ç±»å¯¹åº”çš„CLasså¯¹è±¡æ²¡æœ‰ä»»ä½•å¼•ç”¨ çœ‹å¾—å‡ºï¼Œå¸è½½ä¸€ä¸ªç±»æ¡ä»¶æ¯”è¾ƒè‹›åˆ»ï¼Œé‚£å°±æŒ‰ç…§ä¸Šè¿°3ä¸ªæ¡ä»¶è¿›è¡Œé—®é¢˜æ’æŸ¥ã€‚ ä¸‰ã€æ’æŸ¥ 3.1 å¤ç° â€‹ è§£å†³é—®é¢˜çš„å‰ææ˜¯èƒ½å¤Ÿå¤ç°é—®é¢˜ï¼Œå¥½åœ¨è¿™æ¬¡é—®é¢˜æ¯”è¾ƒå®¹æ˜“å¤ç°å‡ºæ¥ã€‚ ç¯å¢ƒï¼š - weblogic 12c jdk 1.8 metaspace 512M maxMetaspace1024M æ­¥éª¤ï¼š åœ¨æ§åˆ¶å°ä¸­ä½¿ç”¨æ›´æ–°åŠŸèƒ½ï¼Œé‡å¤éƒ¨ç½²å¤šæ¬¡ è§‚å¯Ÿï¼š ä½¿ç”¨jdkè‡ªå¸¦Java VisualVMï¼Œè§‚å¯Ÿmetaspaceå†…å­˜çš„å¢é•¿ï¼Œä»¥åŠä¸€ä¸ªclassçš„åŠ è½½æ•°é‡å’Œå¸è½½æ•°é‡ ç°è±¡ï¼š classä¸€ç›´åœ¨å¢é•¿ï¼Œæ²¡æœ‰å‡ºç°è¿‡å¤§å¹…åº¦çš„ä¸‹è·Œ æ€»å…±æ›´æ–°äº†2æ¬¡è½½å…¥äº†7W+çš„ç±»ï¼Œå¸è½½å´ä¸åˆ°3Kï¼Œè¿™ä¸ªç»“æœå°±ç¦»è°±ã€‚ 3.2 å†…å­˜åˆ†æ â€‹ æŠŠheap dumpä¸‹æ¥ï¼Œçœ‹çœ‹ã€‚åˆ°åº•æ˜¯å•¥å¯¼è‡´æ²¡æœ‰å¸è½½ã€‚å‰æ–‡è¯´äº†ï¼Œå¸è½½ä¸€ä¸ªç±»è¦æ»¡è¶³3ä¸ªæ¡ä»¶ã€‚é‚£å°±æŒ‰ç…§3ä¸ªæ¡ä»¶è¿›è¡Œåˆ†æã€‚ â€‹ ä½†åŠ è½½ç±»æ˜¯åœ¨å¤ªå¤šï¼Œä¸å¯èƒ½ä¸€ä¸ªä¸€ä¸ªçš„å»åˆ†æã€‚ä»3ä¸ªæ¡ä»¶æ¥çœ‹ï¼Œåˆ†æclassloaderæ˜¯æœ€é è°±çš„ï¼Œæ¯•ç«Ÿæ‰€æœ‰ç±»çš„åŠ è½½éƒ½æ˜¯ç”±classloaderè¿›è¡ŒåŠ è½½çš„ï¼Œè€Œä¸”classloaderæ•°é‡ç›¸å¯¹è¾ƒå°‘ã€‚ â€‹ é€šè¿‡matåˆ†æï¼Œæ£€æµ‹å‡ºæœ‰3ä¸ªé—®é¢˜,2ä¸ªéƒ½æ˜¯ChangeAwareCloaderï¼š çœ‹æ¥æ–¹å‘æ²¡é”™ï¼Œå»weblogicå®˜æ–¹çœ‹äº†ä¸€ä¸‹ï¼Œä¸Šå›¾ä¸­çš„classloaderæ˜¯è´Ÿè´£æ›´æ–°classçš„ã€‚ç‚¹å¼€è¯¦æƒ…çœ‹ä¸€ä¸‹ï¼Œå‘ç°æ˜¯nacosçš„çº¿ç¨‹holdä½äº†classloaderå¯¼è‡´ï¼Œå˜¿å˜¿ç ´æ¡ˆäº†ã€‚ 3.3 è¿™è¯¥æ­»çš„çº¿ç¨‹ â€‹ é€šè¿‡ä¸Šé¢çš„åˆ†æï¼Œå‘ç°æ˜¯nacosåœ¨springåœæ­¢çš„æ—¶å€™å¹¶æ²¡æœ‰åœæ­¢ç›¸å…³çº¿ç¨‹ï¼Œå¯¼è‡´è¯¥çº¿ç¨‹ä¸€ç›´åœ¨åå°æ´»è·ƒã€‚ç”±äºçº¿ç¨‹æ²¡æœ‰é€€å‡ºï¼Œé‚£ä¹ˆç›¸åº”çš„classloaderå°±ä¸èƒ½è¢«å›æ”¶ã€‚ â€‹ æˆ‘TMåæ‰‹ä¸€ä¸ªpråˆ°nacosã€‚ 3.4 éªŒè¯ â€‹ é—®é¢˜åŸå› æ‰¾åˆ°äº†ï¼Œå°±æ›¿æ¢æ‰åŸç”±é¡¹ç›®çš„nacosï¼Œæ¢ä¸Šä¸€ä¸ªåœæ­¢springçš„æ—¶å€™é”€æ¯nacosçº¿ç¨‹ç‰ˆæœ¬ï¼ŒéªŒè¯ä¸€ä¸‹æ˜¯å¦è§£å†³ã€‚ â€‹ ç”±äºæ˜¯çº¿ç¨‹å¼•èµ·çš„ï¼Œæ‰€ä»¥åœ¨éªŒè¯çš„è¿‡ç¨‹ä¸­ï¼Œè¦æ ¼å¤–æ³¨æ„ï¼Œnacosçº¿ç¨‹æ˜¯å¦è¢«æ­£å¸¸å…³é—­ã€‚ ä¸Šå›¾ä¸ºweblogicä¸€ä¸ªçº¿ç¨‹æˆªå›¾ã€‚å¯ä»¥çœ‹åˆ°nacosç›¸å…³çš„çº¿ç¨‹æœ‰6ä¸ªã€‚æ­¤æ—¶åœæ­¢åº”ç”¨ï¼Œnacosçº¿ç¨‹å·²ç»è¢«æ­£å¸¸çš„é”€æ¯äº†ã€‚ â€‹ çº¿ç¨‹å·²ç»è¢«æ­£å¸¸é”€æ¯ï¼Œå†æ¥éªŒè¯æ˜¯å¦èƒ½å¤Ÿæ­£å¸¸å¸è½½classã€‚é‡å¤éƒ¨ç½²2æ¬¡ï¼Œå†è¿›è¡Œè§‚å¯Ÿã€‚ â€‹ è¿˜æ˜¯ç¦»è°±ï¼Œä¾æ—§æ²¡æœ‰è¢«å¸è½½ï¼Œçœ‹æ¥é—®é¢˜æ²¡æœ‰è¢«æ ¹æœ¬è§£å†³ã€‚ä¼šä¸ä¼šæ˜¯è¿˜æœ‰å•¥çº¿ç¨‹æ²¡æœ‰è¢«å…³é—­å‘¢ã€‚å†å»æ‰¾æ‰¾çœ‹çœ‹ã€‚å…ˆåœæ­¢åº”ç”¨ï¼Œçœ‹çœ‹å“ªäº›çº¿ç¨‹è¿˜åœ¨åå°è¿è¡Œã€‚ æ‰’äº†ä¸€ä¸‹ï¼Œè¿˜æœ‰ä¸€ä¸ªçº¿ç¨‹æ²¡æœ‰æ­£å¸¸é”€æ¯ã€‚æ”¹æ”¹ä»£ç å†è¯•ä¸€ä¸‹å§0.0. 3.5 è¿˜æ˜¯è¿™è¯¥æ­»çš„çº¿ç¨‹ â€‹ è™½ç„¶æŠŠnacosçš„çº¿ç¨‹ç»™é”€æ¯äº†ï¼Œä½†è¿˜æœ‰ä¸šåŠ¡çº¿ç¨‹è¿˜åœ¨è·‘ï¼Œå†æµ‹è¯•ä¸€æŠŠï¼Œçœ‹çœ‹èƒ½ä¸èƒ½æ­£å¸¸çš„å›æ”¶classã€‚ç»è¿‡æµ‹è¯•æ²¡æœ‰å‡ºç°å¯ä»¥çš„çº¿ç¨‹äº†ã€‚æ„Ÿè§‰è‡ªå·±åˆè¡Œäº†ã€‚ â€‹ ç»§ç»­æµ‹è¯•ï¼Œé‡å¤éƒ¨ç½²ï¼ŒéªŒè¯æ˜¯å¦èƒ½å¤Ÿæ­£å¸¸å¸è½½classã€‚ è¿˜æ˜¯ç¦»è°±ï¼ŒåŠ è½½äº†7Wå¤šçš„ç±»ï¼Œå¸è½½æ‰4Kå¤šç‚¹ï¼Œè¿™è¿˜æ˜¯ä¸æ­£å¸¸ã€‚æœç„¶ï¼Œè¿™ä¸ªå·¥ç¨‹çš„é—®é¢˜å¾ˆå¤šå‘€ã€‚ 3.6 é‡æ–°åˆ†æå†…å­˜,è®¨åŒçš„ç›‘æ§ â€‹ çº¿ç¨‹çš„é—®é¢˜è§£å†³äº†ï¼Œä½†é—®é¢˜ä¾æ—§ï¼Œåªèƒ½å†dumpä¸€ä»½å†…å­˜çœ‹çœ‹ã€‚ é—®é¢˜è¿˜æ˜¯åœ¨classLoaderä¸Šï¼Œå»è¯¦æƒ…çœ‹çœ‹ã€‚ classloaderè¢«Loggerç»™holdä½äº†ï¼Œè¿™æœ‰ç‚¹å¥‡æ€ªäº†ã€‚ç”±ä¸Šå›¾å¯ä»¥çœ‹å‡ºï¼ŒchangeAwareClassLoaderåŠ è½½äº†LoggingHandlerï¼Œåœ¨Loggerä¸­å¼•ç”¨äº†LoggingHandlerï¼Œè¿™ä¸ªLoggeræ˜¯ç³»ç»Ÿç±»ï¼Œ â€‹ ç”±äºLoggeræ˜¯ç³»ç»Ÿç±»ï¼Œç”±jvmçš„Bootstrap ClassLoaderåŠ è½½ï¼Œè¿™ä¸ªclassloaderçš„ç”Ÿå‘½å‘¨æœŸå°±å¾ˆé•¿äº†ï¼Œåªæœ‰jvmè¿›ç¨‹é€€å‡ºï¼Œæ‰ä¼šè¢«é”€æ¯æ‰ã€‚ â€‹ åªèƒ½ç¿»ä¸€ä¸‹LoggingHandlerçš„ä»£ç ï¼Œçœ‹ä¸‹ä¸ºå•¥è¦å»è·ŸLoggeræ‰¯ä¸Šå…³ç³»ã€‚ è¿™ä¸ªç©æ„å„¿åœ¨å¯åŠ¨çš„æ—¶å€™å›å»æ³¨å†Œä¸€ä¸‹ï¼Œè·å–çš„æ˜¯ç³»ç»Ÿçš„Loggerï¼Œæ€ªä¸å¾—ä¼šæ‰¯ä¸Šå…³ç³»ã€‚ä¸çŸ¥é“ä¸ºå•¥æ²¡æœ‰è¢«å–æ¶ˆæ³¨å†Œï¼Œå–æ¶ˆæ³¨å†Œçš„æ–¹æ³•å€’æ˜¯æœ‰ä¸ªã€‚ çŒœæµ‹æ˜¯jaråŒ…ç‰ˆæœ¬å†²çªå¯¼è‡´å‡ºç°äº†å¼‚å¸¸ï¼Œå°±æ²¡æœ‰æŠŠå–æ¶ˆæ³¨å†Œæµç¨‹ç»™èµ°å®Œã€‚é—®äº†ä¸€ä¸‹åŒäº‹ï¼Œè¯´è¿™ä¸ªLoggingHandleræ˜¯å±äºä¸€ä¸ªç›‘æ§ï¼Œè¿™ä¸ªç›‘æ§æ¯”è¾ƒè€ï¼Œå¯ä»¥ç›´æ¥ä¸‹æ‰ã€‚é‚£å°±ä¸å»çº ç»“ä¸ºå•¥æ²¡æœ‰å–æ¶ˆæ³¨å†Œäº†ï¼Œç›´æ¥ä¸‹æ‰çœ‹ç–—æ•ˆã€‚ 3.7 é‡æ–°éªŒè¯ â€‹ æŠŠç›‘æ§çš„jaråŒ…ä¸‹æ‰ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½è¾¾åˆ°é¢„æœŸçš„æ•ˆæœã€‚ weblogicåˆå§‹çŠ¶æ€ï¼Œä¸€ç‰‡ç¥¥å’Œã€‚ é‡å¤éƒ¨ç½²3æ¬¡ï¼š è¿˜æ˜¯æ²¡å¸è½½ï¼Œç¦»è°±ï¼Œçœ‹æ¥è¦ç¿»è½¦äº†ã€‚ä¸æ€¥é™ªä»–è€è€ï¼Œç­‰ä»–ä¸ª10åˆ†é’Ÿï¼Œçœ‹ä»–è‡ªå·±æŠ•é™ã€‚æ˜¯ä¸æ˜¯è§‰å¾—æ˜¯ç„å­¦ğŸ˜‚ã€‚å¯¹ï¼Œè¿˜çœŸä¸æ˜¯ç„å­¦ï¼Œæœ‰äº›ä¸œè¥¿æ²¡æœ‰åŠæ—¶é‡Šæ”¾ï¼Œæ˜¯å› ä¸ºåœ¨finalizeé˜Ÿåˆ—ä¸­æ’é˜Ÿå‘¢ï¼Œç­‰ä¸€ä¸‹å°±å¥½ã€‚ 10åˆ†é’Ÿä¹‹åï¼Œä¸å¯¹åº”è¯¥æ˜¯å‡ºå»åƒé¥­è¿‡åï¼š metaspaceçš„å ç”¨æ°´å¹³å·²å›å½’åˆ°æ­£å¸¸çš„æ°´å¹³ï¼Œç±»å¸è½½ä»4000åˆ°äº†28000ã€‚ åå¤éƒ¨ç½²åï¼Œmetaspaceå†…å­˜ä¹Ÿç¨³å®šåˆ°600Mã€‚okï¼Œå®Œç¾è§£å†³ã€‚ â€‹</summary></entry><entry><title type="html">spring-boot2 idea jsp 404 é—®é¢˜æ¢ç©¶(tomcatå¯åŠ¨æµç¨‹æ¢ç©¶)</title><link href="https://onew.me/spring/2020/03/14/debug-spring-boot2-jsp.html" rel="alternate" type="text/html" title="spring-boot2 idea jsp 404 é—®é¢˜æ¢ç©¶(tomcatå¯åŠ¨æµç¨‹æ¢ç©¶)" /><published>2020-03-14T09:20:25+08:00</published><updated>2020-03-14T09:20:25+08:00</updated><id>https://onew.me/spring/2020/03/14/debug-spring-boot2-jsp</id><content type="html" xml:base="https://onew.me/spring/2020/03/14/debug-spring-boot2-jsp.html"># ä¸€ã€å‰è¨€

â€‹	æœ€è¿‘æœ‰å°æœ‹å‹åœ¨å­¦ä¹ spring bootçš„æ—¶å€™é‡åˆ°äº†ä¸€ä¸ªé—®é¢˜,æŒ‰ç…§æ•™ç¨‹ä¸Šæ“ä½œå§‹ç»ˆæ˜¯404.äºæ˜¯å°±ç™¾äº‹ä¸å¾—å…¶è§£.é—®æˆ‘çš„æ—¶å€™,æˆ‘ä¹Ÿä¸€è„¸è’™B,æ¯•ç«Ÿjspè¿™ç©æ„å„¿å¥½ä¹…éƒ½æ²¡ç¢°åˆ°è¿‡äº†,ä¹‹å‰ç¢°jspçš„æ—¶å€™è¿˜æ˜¯åœ¨sshçš„æ—¶å€™.

â€‹	æ—¢ç„¶é‡åˆ°é—®é¢˜å°±æ¥åˆ†æä¸€ä¸‹å‘—,è¶ç€æœ€è¿‘åœ¨çœ‹springçš„æºç .



# äºŒã€æ¡ˆå‘ç°åœº

ymal:

```yml
server:
  port: 9090
spring:
  mvc:
    view:
      prefix: /WEB-INF/jsp/
      suffix: .jsp
```

pom:

```xml
 &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
            &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;

    &lt;/build&gt;
```

ä»£ç :

```java
@Controller
@EnableAutoConfiguration
public class App {

    public static void main(String[] args) {
        SpringApplication.run(App.class,args);
    }

    @RequestMapping(&quot;/test&quot;)
    public String test(){
        return &quot;index&quot;;
    }

}
```

â€‹	æŒ‰ç…§ä»¥ä¸Šä»£ç ,åº”è¯¥æ˜¯æ²¡æœ‰ä»€ä¹ˆé—®é¢˜çš„,æ¯•ç«Ÿäººå®¶çš„æ•™ç¨‹ä¹Ÿæ˜¯è¿™ä¹ˆåšçš„,åªä¸è¿‡åˆ«äººæ˜¯ç”¨eclipse,ä»–æ˜¯ç”¨çš„ideaç½¢äº†.æˆ‘ä¹Ÿæ‡’å¾—å»åˆ†æä¸ºå•¥eclipseæ²¡å¾—é—®é¢˜äº†,ç›´æ¥æ¥çœ‹çœ‹ä¸ºå•¥ä¼šæœ‰è¿™ä¸ªé—®é¢˜.



# ä¸‰ã€åˆ†æ

â€‹	ä¼—æ‰€å‘¨çŸ¥,spring bootåªæ˜¯åœ¨springä¸Šé¢åŒ…äº†ä¸€å±‚çš®,é‡Œé¢è¿˜æ˜¯åˆ©ç”¨äº†springçš„ä¸€äº›æœºåˆ¶æ¥å®Œæˆ,å½“ç„¶åŠ è½½è‡ªåŠ¨åŒ–é…ç½®,å¼€ç®±å³ç”¨,æ„Ÿè§‰å¾ˆæ™ºèƒ½.

â€‹	springbootä¸ºæˆ‘ä»¬å¼€å‘è€…çœå»äº†å¾ˆå¤šé…ç½®ä¸Šçš„éº»çƒ¦,å¤§éƒ¨åˆ†éƒ½é»˜è®¤é…ç½®å¥½äº†,ä½†æ˜¯è™½ç„¶ä¾¿åˆ©äº†å¼€å‘è€…,ä½†ä¹Ÿå¸¦æ¥äº†ä¸€äº›éº»çƒ¦,å°±å¦‚è¿™ä¸ªé—®é¢˜,æ•´ä¸ªæ—¥å­è¾“å‡ºçª—å£éƒ½æ²¡æœ‰æ—¥å¿—æ˜¾ç¤ºä¸ºå•¥ä¼šæ˜¯404,æ–‡ä»¶æ˜æ˜åœ¨é‚£,ä¸ºå•¥ä¼šæ‰¾ä¸åˆ°å‘¢?

â€‹	è¦è§£å†³è¿™ä¸ªé—®é¢˜,å°±è¦ä»springBootçš„è‡ªåŠ¨é…ç½®ä¸Šå…¥æ‰‹.æŒ‰ç…§ä¸Šé¢çš„é…ç½®,ç”¨çš„æ˜¯åµŒå…¥å¼çš„tomcat,é‚£ä¹ˆå°±ä»tomcatçš„é…ç½®å¼€å§‹.



## 3.1 ServletWebServerFactoryConfiguration

â€‹	å½“ä½¿ç”¨springbootçš„wenåŠŸèƒ½çš„æ—¶å€™,æœ‰ä¸ªå…³é”®çš„é…ç½®å°±é¿å…ä¸äº†äº†,ä»£ç å¦‚ä¸‹:

```java
@Configuration(proxyBeanMethods = false)
class ServletWebServerFactoryConfiguration {
  
		// åˆ¤æ–­classpathæ˜¯å¦å­˜åœ¨ Servlet,Tomcat,UpgradeProtocolç±»
   // å¦‚æœå­˜åœ¨å°±å¯ç”¨æ­¤é…ç½®
   // å½“ç„¶è¿˜è¦ ServletWebServerFactory æœŸå­ç±»æ²¡æœ‰ åœ¨å®¹å™¨ä¸­
   @Configuration(proxyBeanMethods = false)
   @ConditionalOnClass({ Servlet.class, Tomcat.class, UpgradeProtocol.class })
   @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
   static class EmbeddedTomcat {

      @Bean
      TomcatServletWebServerFactory tomcatServletWebServerFactory(
            ObjectProvider&lt;TomcatConnectorCustomizer&gt; connectorCustomizers,
            ObjectProvider&lt;TomcatContextCustomizer&gt; contextCustomizers,
            ObjectProvider&lt;TomcatProtocolHandlerCustomizer&lt;?&gt;&gt; protocolHandlerCustomizers) {
         // åˆ›å»ºtomcat å·¥å‚
         TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
         factory.getTomcatConnectorCustomizers()
               .addAll(connectorCustomizers.orderedStream().collect(Collectors.toList()));
         factory.getTomcatContextCustomizers()
               .addAll(contextCustomizers.orderedStream().collect(Collectors.toList()));
         factory.getTomcatProtocolHandlerCustomizers()
               .addAll(protocolHandlerCustomizers.orderedStream().collect(Collectors.toList()));
         return factory;
      }

   }

   /**
    * Nested configuration if Jetty is being used.
    * åŒtomcatçš„é€»è¾‘
    */
   @Configuration(proxyBeanMethods = false)
   @ConditionalOnClass({ Servlet.class, Server.class, Loader.class, WebAppContext.class })
   @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
   static class EmbeddedJetty {

      @Bean
      JettyServletWebServerFactory JettyServletWebServerFactory(
            ObjectProvider&lt;JettyServerCustomizer&gt; serverCustomizers) {
         JettyServletWebServerFactory factory = new JettyServletWebServerFactory();
         factory.getServerCustomizers().addAll(serverCustomizers.orderedStream().collect(Collectors.toList()));
         return factory;
      }

   }

   /**
    * Nested configuration if Undertow is being used.
    * åŒtomcatçš„é€»è¾‘
    */
   @Configuration(proxyBeanMethods = false)
   @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class })
   @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
   static class EmbeddedUndertow {

      @Bean
      UndertowServletWebServerFactory undertowServletWebServerFactory(
            ObjectProvider&lt;UndertowDeploymentInfoCustomizer&gt; deploymentInfoCustomizers,
            ObjectProvider&lt;UndertowBuilderCustomizer&gt; builderCustomizers) {
         UndertowServletWebServerFactory factory = new UndertowServletWebServerFactory();
         factory.getDeploymentInfoCustomizers()
               .addAll(deploymentInfoCustomizers.orderedStream().collect(Collectors.toList()));
         factory.getBuilderCustomizers().addAll(builderCustomizers.orderedStream().collect(Collectors.toList()));
         return factory;
      }

   }

}
```

â€‹	è¿™é‡Œå¯ä»¥çœ‹åˆ°,é…ç½®ç±»æŒ‰ç…§classpathä¸­çš„ç±»åˆ›å»ºäº†ä¸åŒçš„`ServletWebServerFactory`,æœ¬æ–‡è¿™é‡ŒåŠ å…¥äº†tomcat,æ‰€ä»¥è¿™é‡Œå°†ä¼šåˆ›å»º`TomcatServletWebServerFactory`.

â€‹	å½“ç„¶å…‰çœ‹è¿™ä¸ªè¿˜æ˜¯ä¸è¡Œçš„,è¦æ˜ç™½ä¸ºå•¥ä¼šè¿™ä¹ˆåˆ›å»º,é‚£ä¹ˆè¿™ä¸€åˆ‡è¦ä»springbootçš„å¯åŠ¨æµç¨‹å¼€å§‹åˆ†ææ‰èƒ½è§£é‡Šæ•´ä¸ªæƒ…å†µ.



# å››ã€SpringBootå¯åŠ¨æµç¨‹åˆ†æ

â€‹	å¤ªé˜³åº•ä¸‹æ— æ–°é²œäº‹,æ¥æ­å¼€åä¸ºæ–¹ä¾¿çš„é¢çº±.å½“ç„¶è¿™åªæ˜¯åˆæ­¥çš„æ¢è®¨.

```java
@EnableAutoConfiguration
public class Main {

    public static void main(String[] args) {
        SpringApplication.run(Main.class,args);
    }
}

```

â€‹	ç†Ÿæ‚‰springBootçš„äººçœ‹åˆ°è¿™æ ·çš„å†™æ³•æ˜¯å¦æ˜¯æ„Ÿåˆ°å¹³æ·¡æ— å¥‡?é‚£ä¹ˆè¿™çŸ­çŸ­çš„ä¸€è¡Œä»£ç åé¢åˆ°åº•å‘ç”Ÿäº†å•¥??

## 4.1 SpringApplication.run

```java
public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) {
		return run(new Class&lt;?&gt;[] { primarySource }, args);
	}

	public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) {
		return new SpringApplication(primarySources).run(args);
	}
```

â€‹	åˆ›å»ºäº†ä¸ª`SpringApplication`å¯¹è±¡åœ¨runï¼Ÿçœ‹çœ‹æ„é€ å‡½æ•°æ˜¯å¦æœ‰å•¥é€»è¾‘.

```java
public SpringApplication(Class&lt;?&gt;... primarySources) {
		this(null, primarySources);
	}
public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {
		this.resourceLoader = resourceLoader;
		Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);
		this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));
		// åˆ¤æ–­ web åº”ç”¨çš„ç±»å‹
		// åˆ¤æ–­ä¾æ®ä¸º æ˜¯å¦å­˜åœ¨æŒ‡å®š DispatcherServlet,DispatcherHandler,ServletContainer,WebApplicationContext,ReactiveWebApplicationContextç­‰ç±»
		// ä½¿ç”¨ class.forName è¿›è¡ŒæŸ¥æ‰¾
  	// åˆ¤æ–­springç¨‹åºçš„ç±»å‹
		this.webApplicationType = WebApplicationType.deduceFromClasspath();
		// åŠ è½½ META-INF/spring.factories é…ç½®æ–‡ä»¶,å¹¶æŠŠ ApplicationContextInitializer ç›¸å…³çš„ç±»å…¨éƒ¨å®ä¾‹åŒ–
		setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
		// åŠ è½½ META-INF/spring.factories é…ç½®æ–‡ä»¶,å¹¶æŠŠ ApplicationListener ç›¸å…³çš„ç±» å…¨éƒ¨å®ä¾‹åŒ–
		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
		// æ£€æŸ¥ main æ–¹æ³•æ‰€åœ¨çš„ç±»
		this.mainApplicationClass = deduceMainApplicationClass();
	}
```

â€‹	åœ¨æ„é€ çš„æ—¶å€™è¿˜æ˜¯åšäº†ä¸å°‘çš„é€»è¾‘,è¿™é‡Œå°±ä¸å¾—ä¸æä¸€ä¸‹springçš„é»‘é­”æ³•äº†,é‚£å°±æ˜¯`SpringFactoriesLoader`,è¿™ä¸ªä¸œè¥¿æœ‰ç‚¹åƒjavaä¸­çš„spiæœºåˆ¶,ä¸ä¹‹ä¸åŒæ˜¯springæ˜¯è¯»å–çš„æ˜¯`META-INF/spring.factories`æ–‡ä»¶.è‡³äºä¸ºå•¥ä¸ç”¨spiè¦è‡ªå·±å•æä¸ª,emmmmmm.

â€‹	æ„é€ çš„é€»è¾‘å¾ˆç®€å•,ä¸æ˜¯å¾ˆå¤æ‚,å°±æ˜¯æ£€æµ‹ä¸€ä¸‹è¦å¯åŠ¨ä»€ä¹ˆç±»å‹çš„spring,å…·ä½“æ“ä½œæ˜¯åœ¨`WebApplicationType.deduceFromClasspath();`,è¿™ä¸ªç±»å‹åˆ¤æ–­è¿˜æ˜¯å¾ˆé‡è¦çš„,åé¢åˆ›å»ºspringä¸Šä¸‹æ–‡çš„æ—¶å€™ä¼šç”¨å¾—ä¸Š.

## 4.2 springApplication.run

â€‹	å¯¹è±¡åˆ›å»ºå¥½äº†,åˆè¦ç»§ç»­runäº†.

```java
public ConfigurableApplicationContext run(String... args) {
		// åˆ›å»ºä¸€ä¸ªç”¨äºè®°å½• å¯åŠ¨-å…³é—­ æ—¶é—´çš„ StopWatch
		StopWatch stopWatch = new StopWatch();
		stopWatch.start();
		ConfigurableApplicationContext context = null;
		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();
		// è®¾ç½®ç¯å¢ƒå˜é‡
		configureHeadlessProperty();
		// åˆ›å»º EventPublishingRunListener
		// ç›¸å½“äºæ˜¯ä¸ªç»„åˆæ¨¡å¼,æ‰€æœ‰listener éƒ½é›†ä¸­åœ¨ SpringApplicationRunListeners ä¸­
		SpringApplicationRunListeners listeners = getRunListeners(args);
		// å¯åŠ¨å®¹å™¨,å‘é€æ—¶é—´
		listeners.starting();
		try {
			// æŠŠ args å°è£…ä¸ºå¯¹è±¡,æ˜ å°„åˆ°ç¯å¢ƒä¸­
			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
			// åˆå§‹åŒ–ç¯å¢ƒ
			ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
			// è®¾ç½®ç¯å¢ƒå˜é‡ spring.beaninfo.ignore
			configureIgnoreBeanInfo(environment);
			// è·å– éœ€è¦æ‰“å°çš„ Banner å¹¶æŠŠ banner æ‰“å°åˆ°æ§åˆ¶å°
			Banner printedBanner = printBanner(environment);
      
      
			// æ ¹æ®ä¸åŒçš„ç±»å‹ åˆ›å»ºä¸åŒçš„ä¸Šä¸‹æ–‡
			context = createApplicationContext();
      
      
			// è·å– æ‰€æœ‰ SpringBootExceptionReporter ç›¸å…³çš„ç±»
			exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
					new Class[] { ConfigurableApplicationContext.class }, context);
			// å‡†å¤‡ä¸Šä¸‹æ–‡
			prepareContext(context, environment, listeners, applicationArguments, printedBanner);
      
      
      
			// åˆ·æ–°ä¸Šä¸‹æ–‡,å‘é€äº‹ä»¶
			refreshContext(context);
      
      
			// æ¨¡æ¿æ–¹æ³•
			afterRefresh(context, applicationArguments);
			// åœæ­¢
			stopWatch.stop();
			if (this.logStartupInfo) {
				new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
			}
			// é€šçŸ¥ç›‘å¬å™¨,å·²ç»å¯åŠ¨
			listeners.started(context);
			// è°ƒç”¨ runnerçš„ run æ–¹æ³•
			callRunners(context, applicationArguments);
		}
		catch (Throwable ex) {
			// å¤„ç†è¿è¡Œæ—¶çš„é”™è¯¯
			handleRunFailure(context, ex, exceptionReporters, listeners);
			throw new IllegalStateException(ex);
		}

		try {
			// é€šçŸ¥ç›‘å¬å™¨,æ­£åœ¨è¿è¡Œ
			listeners.running(context);
		}
		catch (Throwable ex) {
			// å¤„ç†è¿è¡Œæ—¶çš„é”™è¯¯
			handleRunFailure(context, ex, exceptionReporters, null);
			throw new IllegalStateException(ex);
		}
		// è¿”å›ä¸Šä¸‹æ–‡
		return context;
	}
```

â€‹	ç”±äºæœ¬æ–‡ä¸æ˜¯åˆ†æä»£ç çš„æ–‡ç« ,æ‰€ä»¥å…³æ³¨ç‚¹æ”¾åœ¨åˆ›å»ºspringä¸Šä¸‹æ–‡å’Œä¸Šä¸‹æ–‡çš„æ“ä½œä¸Š.åˆ†åˆ«æ˜¯`createApplicationContext`å’Œ`refreshContext`



## 4.3 createApplicationContext

```java
protected ConfigurableApplicationContext createApplicationContext() {
		Class&lt;?&gt; contextClass = this.applicationContextClass;
		if (contextClass == null) {
			try {
				switch (this.webApplicationType) {
				case SERVLET:
					contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);
					break;
				case REACTIVE:
					contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);
					break;
				default:
					contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);
				}
			}
			catch (ClassNotFoundException ex) {
				throw new IllegalStateException(
						&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, ex);
			}
		}
		return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
	}
```

â€‹	è¿™é‡Œçš„ç±»å‹,æ˜¯æŒ‰ç…§ä¹‹å‰æ„é€ æ–¹æ³•ä¸­çš„ç±»å‹è¿›è¡Œåˆ›å»ºçš„,å¦‚æœä¸æ¸…æ¥šçš„å¯ä»¥å¾€ä¸Šç¿»ä¸€å“ˆ.

1. å¦‚æœç±»å‹ä¸º: SERVLET å°±åˆ›å»º AnnotationConfigServletWebServerApplicationContext
2. å¦‚æœç±»å‹ä¸º: REACTIVE å°±åˆ›å»º AnnotationConfigReactiveWebServerApplicationContext
3. é»˜è®¤åˆ›å»º : AnnotationConfigApplicationContext



â€‹	å¾ˆæ˜¾ç„¶è¿™é‡Œçš„ç±»å‹æ˜¯ SERVLET æ‰€ä»¥åˆ›å»ºäº† AnnotationConfigServletWebServerApplicationContext,ç»§æ‰¿å…³ç³»å¦‚ä¸‹.

![images](https://gitee.com/oneww/onew_image/raw/master/AnnotationConfigServletWebServerApplicationContext.png)

â€‹	ç†Ÿæ‚‰springçš„åŒå­¦æ˜¯ä¸æ˜¯æ„Ÿè§‰ä¸`ClassPathXmlApplicationContext`å·®ä¸å¤šï¼Ÿæˆ‘è§‰å¾—æ˜¯å·®ä¸å¤šçš„,åªæ˜¯å¹²äº‹çš„æ–¹å¼æœ‰ç‚¹åŒºåˆ«.

â€‹	è¿™é‡ŒæŠŠå¯¹è±¡åˆ›å»ºå®Œäº†,ç„¶åè¿›è¡Œä¸€é¡¿éªšæ“ä½œ,è®¾ç½®å€¼,ç¯å¢ƒç­‰ç­‰.ä¸å†è¿™é‡Œè¿›è¡Œåˆ†æ.è¦çœ‹çš„å…³é”®ç‚¹æ˜¯`refreshContext`.

## 4.5 refreshContext

â€‹	åˆ·æ–°ä¸Šä¸‹æ–‡,è¿™é‡Œåˆ·æ–°ä¼šæœ‰ä»€ä¹ˆéªšæ“ä½œå‘¢?æ¥ç§ç§å°±çŸ¥é“äº†.

```java
private void refreshContext(ConfigurableApplicationContext context) {
		refresh((ApplicationContext) context);
		if (this.registerShutdownHook) {
			try {
				// æ·»åŠ å…³é—­é’©å­,å…³é—­ç¨‹åºæ—¶,å…³é—­ä¸Šä¸‹æ–‡ é‡Šæ”¾èµ„æº
				context.registerShutdownHook();
			}
			catch (AccessControlException ex) {
				// Not allowed in some environments.
			}
		}
	}
```

â€‹	æ·»åŠ é’©å­è¿™ä¸ªå¯ä»¥ä¸ç”¨ç®¡,ä¸å½±å“é€»è¾‘.

```java
@Deprecated
	protected void refresh(ApplicationContext applicationContext) {
		Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext);
		refresh((ConfigurableApplicationContext) applicationContext);
	}
```

â€‹	è™½ç„¶è¿™ä¸ªæ–¹æ³•è¿‡æ—¶,ä½†springè¿˜æ˜¯æ²¡æœ‰ç›´æ¥åˆ é™¤,çœŸå¤Ÿè‰¯å¿ƒçš„,ä¸åƒæŸFinal,ç›´æ¥åˆ ,çœŸTMSB.

```java
protected void refresh(ConfigurableApplicationContext applicationContext) {
		applicationContext.refresh();
	}
```

â€‹	æ³¨æ„è¿™é‡Œçš„context å®é™…ä¸Šæ˜¯`AnnotationConfigServletWebServerApplicationContext`,è€Œ`AnnotationConfigServletWebServerApplicationContext`æ²¡æœ‰é‡å†™è¿™ä¸ªæ–¹æ³•,æ˜¯ç»§æ‰¿çš„å®ƒçˆ¶ç±»`ServletWebServerApplicationContext`.

```java
// ServletWebServerApplicationContext
@Override
	public final void refresh() throws BeansException, IllegalStateException {
		try {
			super.refresh();
		}
		catch (RuntimeException ex) {
			stopAndReleaseWebServer();
			throw ex;
		}
	}
```

â€‹	`ServletWebServerApplicationContext`çš„çˆ¶ç±»æ˜¯`AbstractApplicationContext`

```java
// AbstractApplicationContext
public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			// å‡†å¤‡åˆ·æ–°ä¸Šä¸‹æ–‡ç¯å¢ƒ
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			// åˆå§‹åŒ–beanFactory,è¿›è¡Œxmlé¢„è¯»å–
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			// å¯¹beanFactoryè¿›è¡Œå¡«å……
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				// å­ç±»è¦†ç›–æ–¹æ³•åšé¢å¤–çš„å¤„ç†
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				// æ¿€æ´»å„ç§beanFactoryProcessors
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				//æ³¨å†Œæ‹¦æˆªbeanåˆ›å»ºçš„beanå¤„ç†å™¨
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				// åˆå§‹åŒ–ä¸Šä¸‹æ–‡çš„æ¶ˆæ¯æº
				initMessageSource();

				// Initialize event multicaster for this context.
				// åˆå§‹åŒ–ä¸Šä¸‹æ–‡çš„æ¶ˆæ¯å¹¿æ’­
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				// ç•™ç»™å­ç±»æ¥åˆå§‹åŒ–å…¶ä»–çš„bean
				onRefresh();

				// Check for listener beans and register them.
				// æ³¨å†Œæ‰€æœ‰beançš„ç›‘å¬å™¨
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				// åˆå§‹åŒ–å»¶è¿ŸåŠ è½½çš„bean
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				// æœ€åä¸€æ­¥,å‘å¸ƒæ¶ˆæ¯
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn(&quot;Exception encountered during context initialization - &quot; +
							&quot;cancelling refresh attempt: &quot; + ex);
				}
				//å‘ç”Ÿå¼‚å¸¸,é”€æ¯æ‰€æœ‰bean
				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				// é‡ç½®flag
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				// é‡ç½®ç¼“å­˜
				resetCommonCaches();
			}
		}
	}
```

â€‹	è¿™é‡Œçš„é‡ç‚¹æ˜¯`onRefresh`,è¿™é‡Œ`onRefresh`æ˜¯ç”±å­ç±»`ServletWebServerApplicationContext`è¿›è¡Œå®ç°çš„.



## 4.6 onRefresh

```java
	// ServletWebServerApplicationContext
	@Override
	protected void onRefresh() {
		super.onRefresh();
		try {
		// åˆ›å»ºserver
			createWebServer();
		}
		catch (Throwable ex) {
			throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);
		}
	}

```

â€‹	ç»ˆäºç»•åˆ°äº†åˆ›å»º server è¿™é‡Œäº†,ä¸çŸ¥å°‘ä¾ æ˜¯å¦è¿˜è®°å¾—é‚£ä¸ªé…ç½®ç±»??`ServletWebServerFactoryConfiguration`.é‚£ä¹ˆç°åœ¨æ‰çœŸæ­£çš„å¼€å§‹äº†.

```java
private void createWebServer() {
		WebServer webServer = this.webServer;
  	// è·å–servlet ä¸Šä¸‹æ–‡
		ServletContext servletContext = getServletContext();
    // å¦‚æœ server ä¸ºç©º æˆ–è€… servletä¸Šä¸‹æ–‡ä¸ºç©º,å°±åˆ›å»ºserver
		if (webServer == null &amp;&amp; servletContext == null) {
			ServletWebServerFactory factory = getWebServerFactory();
			this.webServer = factory.getWebServer(getSelfInitializer());
		}
		else if (servletContext != null) {
			try {
				getSelfInitializer().onStartup(servletContext);
			}
			catch (ServletException ex) {
				throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex);
			}
		}
		initPropertySources();
	}
```

1. åˆ¤æ–­serveræ˜¯å¦åˆ›å»º
2. æœªåˆ›å»ºå°±åˆ›å»º
3. åˆå§‹åŒ–
4. åˆå§‹åŒ–èµ„æº



â€‹	è¿™é‡Œçš„ `getWebServerFactory()` æ–¹æ³•ä»å®¹å™¨ä¸­è·å–çš„,å®¹å™¨é‡Œé¢çš„æ˜¯ä¹‹å‰é…ç½®ç±»ä¸­åˆ›å»ºçš„.

```java
// ä»å®¹å™¨ä¸­è·å– ServletWebServerFactory
protected ServletWebServerFactory getWebServerFactory() {
		// Use bean names so that we don't consider the hierarchy
		String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);
		if (beanNames.length == 0) {
			throw new ApplicationContextException(&quot;Unable to start ServletWebServerApplicationContext due to missing &quot;
					+ &quot;ServletWebServerFactory bean.&quot;);
		}
		if (beanNames.length &gt; 1) {
			throw new ApplicationContextException(&quot;Unable to start ServletWebServerApplicationContext due to multiple &quot;
					+ &quot;ServletWebServerFactory beans : &quot; + StringUtils.arrayToCommaDelimitedString(beanNames));
		}
		return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class);
	}
```



#  äº”ã€tomcatçš„åˆ›å»º

â€‹	å‰é¢åƒè¾›ä¸‡è‹¦çš„è·å–åˆ°äº† tomcatServerçš„å·¥å‚,æ¥ä¸‹æ¥å°±çœ‹çœ‹æ˜¯æ€ä¹ˆåˆ›å»ºçš„å§.

```java
// TomcatServletWebServerFactory
@Override
	public WebServer getWebServer(ServletContextInitializer... initializers) {
		// .. çœç•¥
    // åˆå§‹åŒ–
		prepareContext(tomcat.getHost(), initializers);
		return getTomcatWebServer(tomcat);
	}
```

â€‹	è¿™é‡Œ`ServletContextInitializer`æ˜¯ä¸æ˜¯å’Œ`ServletContainerInitializer`æœ‰ç‚¹ç¥ä¼¼?åˆ«è¯´ä¸ä»”ç»†çœ‹è¿˜æ˜¯ä¼šçœ‹é”™,è‡³äºè¿™ä¸¤ä¸ªæ˜¯å•¥å…³ç³»,è¿™é‡Œå°±ä¸ç¢ç£¨äº†,æ¯•ç«Ÿè¿™ä¸ªä¸æ˜¯é‡ç‚¹.



## 5.1 åˆå§‹åŒ–

```java
// TomcatServletWebServerFactory
protected void prepareContext(Host host, ServletContextInitializer[] initializers) {
		//... çœç•¥
  	// æ·»åŠ ç›‘å¬å™¨
		context.addLifecycleListener(new StaticResourceConfigurer(context));
		ServletContextInitializer[] initializersToUse = mergeInitializers(initializers);
		host.addChild(context);
		configureContext(context, initializersToUse);
		postProcessContext(context);
	}
```

â€‹	åœ¨åˆå§‹åŒ–è¿‡ç¨‹ä¸­æ·»åŠ äº†ä¸€ä¸ªåå­—ä¸ºé™æ€èµ„æºé…ç½®çš„ç›‘å¬å™¨,åå­—éƒ½å¾ˆæ€ªæ€ªçš„å¥½å§.å»çœ‹çœ‹è¿™ä¸ªç›‘å¬å™¨æ˜¯å¹²å˜›çš„.

```java
private final class StaticResourceConfigurer implements LifecycleListener {

		private final Context context;

		private StaticResourceConfigurer(Context context) {
			this.context = context;
		}

		@Override
		public void lifecycleEvent(LifecycleEvent event) {
      // åˆ¤æ–­æ—¶æœº
			if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {
				addResourceJars(getUrlsOfJarsWithMetaInfResources());
			}
		}

		private void addResourceJars(List&lt;URL&gt; resourceJarUrls) {
			for (URL url : resourceJarUrls) {
				String path = url.getPath();
				if (path.endsWith(&quot;.jar&quot;) || path.endsWith(&quot;.jar!/&quot;)) {
					String jar = url.toString();
					if (!jar.startsWith(&quot;jar:&quot;)) {
						// A jar file in the file system. Convert to Jar URL.
						jar = &quot;jar:&quot; + jar + &quot;!/&quot;;
					}
					addResourceSet(jar);
				}
				else {
					addResourceSet(url.toString());
				}
			}
		}

		private void addResourceSet(String resource) {
			try {
				if (isInsideNestedJar(resource)) {
					// It's a nested jar but we now don't want the suffix because Tomcat
					// is going to try and locate it as a root URL (not the resource
					// inside it)
					resource = resource.substring(0, resource.length() - 2);
				}
				URL url = new URL(resource);
				String path = &quot;/META-INF/resources&quot;;
				this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, &quot;/&quot;, url, path);
			}
			catch (Exception ex) {
				// Ignore (probably not a directory)
			}
		}

		private boolean isInsideNestedJar(String dir) {
			return dir.indexOf(&quot;!/&quot;) &lt; dir.lastIndexOf(&quot;!/&quot;);
		}

	}
```

â€‹	ä»è¿™ä¸ªç›‘å¬å™¨çš„ä»£ç é€»è¾‘ä¸Šçœ‹ æ˜¯å¾€`context.getResources`ä¸¢ä¸œè¥¿å‘€.è²Œä¼¼æ˜¯è·¯å¾„å•¥çš„,è¿™ä¼šä¸ä¼šä¸å¼€å¤´çš„404é—®é¢˜æœ‰å…³å‘¢ï¼Ÿ

â€‹	`createWebResourceSet`è¿™ä¸ªæ–¹æ³•å«Œç–‘å¾ˆå¤§,å»çœ‹çœ‹.

```java
// StandardRoot 
public void createWebResourceSet(ResourceSetType type, String webAppMount,
            String base, String archivePath, String internalPath) {
        List&lt;WebResourceSet&gt; resourceList;
        WebResourceSet resourceSet;

        switch (type) {
            case PRE:
                resourceList = preResources;
                break;
            case CLASSES_JAR:
                resourceList = classResources;
                break;
            case RESOURCE_JAR:
                resourceList = jarResources;
                break;
            case POST:
                resourceList = postResources;
                break;
            default:
                throw new IllegalArgumentException(
                        sm.getString(&quot;standardRoot.createUnknownType&quot;, type));
        }
					// ..... çœç•¥
        resourceList.add(resourceSet);
    }
```

â€‹	ä»¥ä¸Šé€»è¾‘ä¸ºæ ¹æ®ä¸åŒçš„ç±»å‹,å¾€ä¸åŒçš„listä¸­æ·»åŠ è·¯å¾„.å¥½å§è¿˜æ˜¯çœ‹ä¸å‡ºæ¥è¿™ä¸ªåˆ°åº•æœ‰ä»€ä¹ˆç”¨,404çš„é—®é¢˜ä¹Ÿæ²¡æ‰¾åˆ°,ä¸å¦‚æœè·Ÿè¸ªä¸€ä¸‹è¯·æ±‚çœ‹çœ‹.



# å…­ã€è¯·æ±‚çš„è·Ÿè¸ª

â€‹	springMVCå¯¹è¯·æ±‚çš„å¤„ç†é€»è¾‘ä¸€èˆ¬ä¸º DispatcherServletæ¥ç®¡è¯·æ±‚-&gt;æŸ¥æ‰¾handler-&gt;æŸ¥æ‰¾handlerDapter-&gt;è§†å›¾è§£æå™¨-&gt;è§£æè§†å›¾-&gt;æ¸²æŸ“è§†å›¾.

â€‹	è™½ç„¶è¿™ä¸ªé€»è¾‘ä¸ä¸å®Œå–„,å¯èƒ½è¿˜æ˜¯é”™çš„,ä½†å·®ä¸å¤š,ç¬”è€…è®¤ä¸ºå“ˆ.

â€‹	é‚£ä¹ˆé—®é¢˜æ¥äº†,åœ¨springMVCä¸­çš„è§†å›¾è§£æå™¨æ˜¯å•¥å‘¢ï¼Ÿçœ‹çœ‹ViewResolverçš„å­ç±»å°±çŸ¥é“æ˜¯InternalResourceViewResolveräº†.ä½†è¿™ä¸ªæ²¡å•¥ç”¨å‘€,å› ä¸ºå…·ä½“çš„æ¸²æŸ“é€»è¾‘æ˜¯åœ¨è§†å›¾å¯¹è±¡é‡Œ,è§£æå™¨åœ¨è¿™é‡Œæ²¡å•¥å¤ªå¤§çš„ç”¨å¤„.æ‰€ä»¥æ¥çœ‹çœ‹jspçš„è§†å›¾`JstlView`ä¸­çš„æ“ä½œå§.

```java
public class JstlView extends InternalResourceView {

	@Nullable
	private MessageSource messageSource;


	/**
	 * Constructor for use as a bean.
	 * @see #setUrl
	 */
	public JstlView() {
	}

	/**
	 * Create a new JstlView with the given URL.
	 * @param url the URL to forward to
	 */
	public JstlView(String url) {
		super(url);
	}

	/**
	 * Create a new JstlView with the given URL.
	 * @param url the URL to forward to
	 * @param messageSource the MessageSource to expose to JSTL tags
	 * (will be wrapped with a JSTL-aware MessageSource that is aware of JSTL's
	 * {@code javax.servlet.jsp.jstl.fmt.localizationContext} context-param)
	 * @see JstlUtils#getJstlAwareMessageSource
	 */
	public JstlView(String url, MessageSource messageSource) {
		this(url);
		this.messageSource = messageSource;
	}


	/**
	 * Wraps the MessageSource with a JSTL-aware MessageSource that is aware
	 * of JSTL's {@code javax.servlet.jsp.jstl.fmt.localizationContext}
	 * context-param.
	 * @see JstlUtils#getJstlAwareMessageSource
	 */
	@Override
	protected void initServletContext(ServletContext servletContext) {
		if (this.messageSource != null) {
			this.messageSource = JstlUtils.getJstlAwareMessageSource(servletContext, this.messageSource);
		}
		super.initServletContext(servletContext);
	}

	/**
	 * Exposes a JSTL LocalizationContext for Spring's locale and MessageSource.
	 * @see JstlUtils#exposeLocalizationContext
	 */
	@Override
	protected void exposeHelpers(HttpServletRequest request) throws Exception {
		if (this.messageSource != null) {
			JstlUtils.exposeLocalizationContext(request, this.messageSource);
		}
		else {
			JstlUtils.exposeLocalizationContext(new RequestContext(request, getServletContext()));
		}
	}

}
```

â€‹	åœ¨jstlViewä¸­å¹¶æ²¡æœ‰çœ‹åˆ°jspçš„å¤„ç†é€»è¾‘,å»çˆ¶ç±»çœ‹çœ‹.

```java
public class InternalResourceView extends AbstractUrlBasedView {
// çœç•¥...

	/**
	 * Render the internal resource given the specified model.
	 * This includes setting the model as request attributes.
	 */
	@Override
	protected void renderMergedOutputModel(
			Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception {

		// Expose the model object as request attributes.
		exposeModelAsRequestAttributes(model, request);

		// Expose helpers as request attributes, if any.
		exposeHelpers(request);

		// Determine the path for the request dispatcher.
		String dispatcherPath = prepareForRendering(request, response);

		// Obtain a RequestDispatcher for the target resource (typically a JSP).
		RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);
		if (rd == null) {
			throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +
					&quot;]: Check that the corresponding file exists within your web application archive!&quot;);
		}

		// If already included or response already committed, perform include, else forward.
		if (useInclude(request, response)) {
			response.setContentType(getContentType());
			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Including [&quot; + getUrl() + &quot;]&quot;);
			}
			rd.include(request, response);
		}

		else {
			// Note: The forwarded resource is supposed to determine the content type itself.
			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Forwarding to [&quot; + getUrl() + &quot;]&quot;);
			}
			rd.forward(request, response);
		}
	}
  
  // çœç•¥....

}
```

â€‹	æ ¸å¿ƒå¤„ç†é€»è¾‘åœ¨`renderMergedOutputModel`,ç»è¿‡`renderMergedOutputModel`æ–¹æ³•ä¸€é¡¿éªšæ“ä½œä»¥å,æœ€åå‘ç°è¯·æ±‚è¢«`RequestDispatcher`æ¥ç®¡äº†.emmm,çº¿ç´¢åˆæ–­äº†,é‚£ä¹ˆæœ€åæ˜¯è¢«è°æ¥ç®¡çš„å‘¢?åœ¨j2eeçš„ä¸–ç•Œé‡Œ,èƒ½è¢«å•¥æ¥ç®¡?ä¸å°±æ˜¯ä¸ªservletæˆ–è€…filterå˜›.

â€‹	é‚£ä¹ˆæ¥ä¸‹æ¥è¦ææ¸…æ¥šæ˜¯è°æ¥ç®¡äº†è¯·æ±‚,å¹¶æ¸²æŸ“äº†jsp,è™½ç„¶ç­”æ¡ˆå¾ˆæ˜¾ç„¶äº†,ä½†è¿˜æ˜¯è¦èµ°ä¸€ä¸‹æµç¨‹.



## 6.1 çŒœæµ‹æ˜¯servletæ¥ç®¡äº†è¯·æ±‚

â€‹	springMVC é‡Œ servlet?é‚£ä¸å°±æ˜¯DispatcherServletå˜›?ä½†æ€»è§‰å¾—ä¸å¯èƒ½,ä¸å¯èƒ½è¯·æ±‚ä»DispatcherServletæ¥åˆå›å»å§?é‚£å°±çœ‹çœ‹åœ¨åˆ›å»ºtomcatçš„æ—¶å€™æœ‰æ²¡æœ‰æ³¨å†Œå…¶ä»–çš„servelt.

```java
// TomcatServletWebServerFactory
protected void prepareContext(Host host, ServletContextInitializer[] initializers) {
		// çœç•¥ ..
		if (isRegisterDefaultServlet()) {
			addDefaultServlet(context);
		}
  
		if (shouldRegisterJspServlet()) {
			addJspServlet(context);
			addJasperInitializer(context);
		}
		// çœç•¥	...
	}

```

â€‹	å¯ä»¥çœ‹åˆ°åœ¨åˆå§‹åŒ–çš„æ—¶å€™,æ³¨å†Œäº†ä¸¤ä¸ªservlet,ä¸€ä¸ªé»˜è®¤çš„servletä¸€ä¸ªæ˜¯jspçš„servlet

```java
// TomcatServletWebServerFactory
private void addDefaultServlet(Context context) {
		Wrapper defaultServlet = context.createWrapper();
		// åç§°
		defaultServlet.setName(&quot;default&quot;);
		defaultServlet.setServletClass(&quot;org.apache.catalina.servlets.DefaultServlet&quot;);
		defaultServlet.addInitParameter(&quot;debug&quot;, &quot;0&quot;);
		defaultServlet.addInitParameter(&quot;listings&quot;, &quot;false&quot;);
		defaultServlet.setLoadOnStartup(1);
		// Otherwise the default location of a Spring DispatcherServlet cannot be set
  	// æ˜¯å¦è¿è¡Œè¦†ç›–,è¿™æ˜¯ä¸ºäº†dispatcherServletåšå‡†å¤‡
  	// æ–¹ä¾¿åœ¨åå…æŠŠè¿™ä¸ªé»˜è®¤çš„servletç»™è¦†ç›–æ‰
		defaultServlet.setOverridable(true);
		context.addChild(defaultServlet);
		context.addServletMappingDecoded(&quot;/&quot;, &quot;default&quot;);
	}

	private void addJspServlet(Context context) {
		Wrapper jspServlet = context.createWrapper();
		jspServlet.setName(&quot;jsp&quot;);
		jspServlet.setServletClass(getJsp().getClassName());
		jspServlet.addInitParameter(&quot;fork&quot;, &quot;false&quot;);
		getJsp().getInitParameters().forEach(jspServlet::addInitParameter);
		jspServlet.setLoadOnStartup(3);
		context.addChild(jspServlet);
    // æ‹¦æˆª *.jsp åç¼€çš„è¯·æ±‚
		context.addServletMappingDecoded(&quot;*.jsp&quot;, &quot;jsp&quot;);
		context.addServletMappingDecoded(&quot;*.jspx&quot;, &quot;jsp&quot;);
	}

```

ä¸¤ä¸ªservlet,ä¸€ä¸ªé»˜è®¤çš„,ä¸€ä¸ªjspçš„.çœ‹åˆ°è¿™å„¿ä¼šä¸ä¼šæœ‰ç‚¹å¥‡æ€ª,ä¸ºå•¥ä¸æ³¨å†ŒdispatcherServlet?emmmä¸æ˜¯å¾ˆæ˜ç™½æ˜‚,ä½†æ˜¯è¿™ä¸ªæ ¸å¿ƒçš„servletæ˜¯ä¸ä¼šè½ä¸‹çš„.

```java
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration(proxyBeanMethods = false)
/**
 * åŒ¹é…å®¹å™¨ä¸º servlet
 * **/
@ConditionalOnWebApplication(type = Type.SERVLET)
/**
 * åˆ¤æ–­ class path è·¯å¾„ä¸‹æœ‰ DispatcherServlet.class
 * **/
@ConditionalOnClass(DispatcherServlet.class)
/***
 * åœ¨ ServletWebServerFactoryAutoConfiguration ä¹‹åç”Ÿæ•ˆ
 * */
@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)
public class DispatcherServletAutoConfiguration {

	/*
	 * The bean name for a DispatcherServlet that will be mapped to the root URL &quot;/&quot;
	 */
	public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = &quot;dispatcherServlet&quot;;

	/*
	 * The bean name for a ServletRegistrationBean for the DispatcherServlet &quot;/&quot;
	 */
	public static final String DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME = &quot;dispatcherServletRegistration&quot;;

	@Configuration(proxyBeanMethods = false)
	@Conditional(DefaultDispatcherServletCondition.class)
	@ConditionalOnClass(ServletRegistration.class)
	// å¯ç”¨é…ç½® WebMvcProperties
	@EnableConfigurationProperties(WebMvcProperties.class)
	protected static class DispatcherServletConfiguration {

		@Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
		public DispatcherServlet dispatcherServlet(WebMvcProperties webMvcProperties) {
			DispatcherServlet dispatcherServlet = new DispatcherServlet();
			dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());
			dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest());
			dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound());
			dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents());
			dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails());
			return dispatcherServlet;
		}

		@Bean
		@ConditionalOnBean(MultipartResolver.class)
		@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)
		public MultipartResolver multipartResolver(MultipartResolver resolver) {
			// Detect if the user has created a MultipartResolver but named it incorrectly
			return resolver;
		}

	}

	@Configuration(proxyBeanMethods = false)
	@Conditional(DispatcherServletRegistrationCondition.class)
	@ConditionalOnClass(ServletRegistration.class)
	@EnableConfigurationProperties(WebMvcProperties.class)
	@Import(DispatcherServletConfiguration.class)
	protected static class DispatcherServletRegistrationConfiguration {

		@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
		@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
		public DispatcherServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet,
				WebMvcProperties webMvcProperties, ObjectProvider&lt;MultipartConfigElement&gt; multipartConfig) {
			DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(dispatcherServlet,
					webMvcProperties.getServlet().getPath());
      // åç§°
			registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
      // å¯åŠ¨é¡ºåº
			registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());
			multipartConfig.ifAvailable(registration::setMultipartConfig);
			return registration;
		}

	}
  // çœç•¥....

}
```

â€‹	åœ¨è‡ªåŠ¨é…ç½®çš„è¿™ä¸ªç±»é‡Œé¢ç”Ÿæˆäº†ä¸€ä¸ª`DispatcherServletRegistrationBean`å¯¹è±¡,è¿™ä¸ªå¯¹è±¡å°±æ˜¯ç”¨äºç»„æµ‹dispatcherServletçš„.`DispatcherServletRegistrationBean`æ˜¯`ServletContextInitializer`çš„å­ç±»,ç”¨äºåˆå§‹åŒ–,æ³¨å†Œç­‰æ“ä½œç­‰.

â€‹	é‚£ä¹ˆè¿™ä¸ªå¯¹è±¡æ˜¯åœ¨ä»€ä¹ˆæ—¶å€™æ³¨å†Œçš„å‘¢?åˆè¦å›åˆ°tomcatåˆ›å»ºçš„æ—¶å€™äº†.

```java
// TomcatServletWebServerFactory
@Override
	public WebServer getWebServer(ServletContextInitializer... initializers) {
    // çœç•¥..
		prepareContext(tomcat.getHost(), initializers);
		return getTomcatWebServer(tomcat);
	}

```

â€‹	åœ¨è°ƒç”¨åˆå§‹åŒ–ä¸Šä¸‹æ–‡çš„æ—¶å€™æŠŠè¿™ä¸ªç©æ„å„¿ç»™ä¼ è¿›å»äº†.

```java
// TomcatServletWebServerFactory
protected void prepareContext(Host host, ServletContextInitializer[] initializers) {
  // çœç•¥...
		ServletContextInitializer[] initializersToUse = mergeInitializers(initializers);
		host.addChild(context);
		configureContext(context, initializersToUse);
		postProcessContext(context);
	}
```

â€‹	è¿™é‡Œåˆå¹¶äº†æ‰€æœ‰çš„`ServletContextInitializer`å¯¹è±¡,ä¼ å…¥åˆ°äº†`configureContext`æ–¹æ³•ä¸­.

```java
// TomcatServletWebServerFactory
protected void configureContext(Context context, ServletContextInitializer[] initializers) {
		TomcatStarter starter = new TomcatStarter(initializers);
		context.addServletContainerInitializer(starter, NO_CLASSES);

	}
```

â€‹	è¿™é‡ŒæŠŠ`ServletContextInitializer`è½¬æˆäº†ä¸€ä¸ª`TomcatStarter`å¯¹è±¡,å¹¶æŠŠè¿™ä¸ªå¯¹è±¡æ·»åŠ åˆ°äº†ä¸Šä¸‹æ–‡ä¸­å».è¿™ä¸ª

`TomcatStarter`å°±å‰å®³äº†.

```java
class TomcatStarter implements ServletContainerInitializer {

	private static final Log logger = LogFactory.getLog(TomcatStarter.class);

	private final ServletContextInitializer[] initializers;

	private volatile Exception startUpException;

	TomcatStarter(ServletContextInitializer[] initializers) {
		this.initializers = initializers;
	}

	@Override
	public void onStartup(Set&lt;Class&lt;?&gt;&gt; classes, ServletContext servletContext) throws ServletException {
		try {
			// åˆå§‹åŒ–æ‰€æœ‰éœ€è¦ åˆå§‹åŒ–çš„ç±»
			for (ServletContextInitializer initializer : this.initializers) {
				initializer.onStartup(servletContext);
			}
		}
		catch (Exception ex) {
			this.startUpException = ex;
			// Prevent Tomcat from logging and re-throwing when we know we can
			// deal with it in the main thread, but log for information here.
			if (logger.isErrorEnabled()) {
				logger.error(&quot;Error starting Tomcat context. Exception: &quot; + ex.getClass().getName() + &quot;. Message: &quot;
						+ ex.getMessage());
			}
		}
	}

	Exception getStartUpException() {
		return this.startUpException;
	}

}
```

â€‹	`TomcatStarter`å®ç°äº†`ServletContainerInitializer`æ¥å£,è¿™ä¸ªæ¥å£å°±å‰å®³äº†,åœ¨servletçš„ç”Ÿå‘½ä¸­æœŸä¸­,ä¼šè°ƒç”¨å®ç°è¿™ä¸ªæ¥å£çš„`onStartup`æ–¹æ³•,è‡³äºä»€ä¹ˆæ˜¯servletçš„ç”Ÿå‘½å‘¨æœŸ,å°±ä¸å¼•å‡ºäº†,ä¼°è®¡ä¸€æ—¶åŠä¼šä¹Ÿè¯´ä¸å®Œ.

â€‹	å—¯,çŸ¥é“è¿™ä¸ªä¸œè¥¿çš„å‰å®³,è¯´äº†è¿™ä¹ˆå¤š,ä¹Ÿæ²¡è¯´`ServletContextInitializer`è¿™ä¸ªä¸œè¥¿å“ªæ¥çš„.ä¸æ˜¯æ–¹æ³•ä¼ è¿›æ¥çš„å˜›?ä¸è¡Œå°±å›å»çœ‹çœ‹.

```java
@Override
	public WebServer getWebServer(ServletContextInitializer... initializers) {
		// çœç•¥...
		return getTomcatWebServer(tomcat);
	}

```

â€‹	å—¯,æ˜¯ä¼ è¿›æ¥çš„,æ€ä¹ˆä¼ è¿›æ¥çš„ï¼Ÿå½“ç„¶æ˜¯åˆ›å»ºçš„æ—¶å€™ä¼ çš„äº†0.0

```java
// ServletWebServerApplicationContext
private void createWebServer() {
		WebServer webServer = this.webServer;
		ServletContext servletContext = getServletContext();
		if (webServer == null &amp;&amp; servletContext == null) {
			ServletWebServerFactory factory = getWebServerFactory();
			this.webServer = factory.getWebServer(getSelfInitializer());
		}
		else if (servletContext != null) {
			try {
				getSelfInitializer().onStartup(servletContext);
			}
			catch (ServletException ex) {
				throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex);
			}
		}
		initPropertySources();
	}
```



## 6.2 ServletContextInitializer æ€ä¹ˆæ¥çš„

```java
// 	ServletWebServerApplicationContext
private org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() {
		return this::selfInitialize;
	}

	private void selfInitialize(ServletContext servletContext) throws ServletException {
		prepareWebApplicationContext(servletContext);
		registerApplicationScope(servletContext);
		WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext);
		for (ServletContextInitializer beans : getServletContextInitializerBeans()) {
			beans.onStartup(servletContext);
		}
	}
```

â€‹	è¿™å°±æ˜¯äº†,é‚£é…ç½®ç±»`DispatcherServletAutoConfiguration`é‡Œé¢çš„`DispatcherServletRegistrationBean`å“ªå»äº†?è¿™é‡Œçš„ç¡®æ²¡æœ‰,ä¸è¿‡åœ¨`getServletContextInitializerBeans()`æ–¹æ³•è¿”å›çš„é›†åˆé‡Œé¢.

```java
// ServletWebServerApplicationContext
protected Collection&lt;ServletContextInitializer&gt; getServletContextInitializerBeans() {
		return new ServletContextInitializerBeans(getBeanFactory());
	}
```

â€‹	`ServletContextInitializerBeans`æ˜¯ä¸€ä¸ªç»§æ‰¿äº†`AbstractCollection`çš„é›†åˆå¯¹è±¡.

```java
// ServletContextInitializerBeans
public ServletContextInitializerBeans(ListableBeanFactory beanFactory,
			Class&lt;? extends ServletContextInitializer&gt;... initializerTypes) {
		this.initializers = new LinkedMultiValueMap&lt;&gt;();
		this.initializerTypes = (initializerTypes.length != 0) ? Arrays.asList(initializerTypes)
				: Collections.singletonList(ServletContextInitializer.class);
		addServletContextInitializerBeans(beanFactory);
		addAdaptableBeans(beanFactory);
		List&lt;ServletContextInitializer&gt; sortedInitializers = this.initializers.values().stream()
				.flatMap((value) -&gt; value.stream().sorted(AnnotationAwareOrderComparator.INSTANCE))
				.collect(Collectors.toList());
		this.sortedList = Collections.unmodifiableList(sortedInitializers);
		logMappings(this.initializers);
	}
```

â€‹	æ ¸å¿ƒé€»è¾‘å°±åœ¨æ„é€ æ–¹æ³•ä¸­çš„`addServletContextInitializerBeans`æ–¹æ³•ä¸­.

```java
// ServletContextInitializerBeans
private void addServletContextInitializerBeans(ListableBeanFactory beanFactory) {
		for (Class&lt;? extends ServletContextInitializer&gt; initializerType : this.initializerTypes) {
			for (Entry&lt;String, ? extends ServletContextInitializer&gt; initializerBean : getOrderedBeansOfType(beanFactory,
					initializerType)) {
				addServletContextInitializerBean(initializerBean.getKey(), initializerBean.getValue(), beanFactory);
			}
		}
	}
	
	private &lt;T&gt; List&lt;Entry&lt;String, T&gt;&gt; getOrderedBeansOfType(ListableBeanFactory beanFactory, Class&lt;T&gt; type) {
		return getOrderedBeansOfType(beanFactory, type, Collections.emptySet());
	}
	private &lt;T&gt; List&lt;Entry&lt;String, T&gt;&gt; getOrderedBeansOfType(ListableBeanFactory beanFactory, Class&lt;T&gt; type,
			Set&lt;?&gt; excludes) {
		String[] names = beanFactory.getBeanNamesForType(type, true, false);
		Map&lt;String, T&gt; map = new LinkedHashMap&lt;&gt;();
		for (String name : names) {
			if (!excludes.contains(name) &amp;&amp; !ScopedProxyUtils.isScopedTarget(name)) {
				T bean = beanFactory.getBean(name, type);
				if (!excludes.contains(bean)) {
					map.put(name, bean);
				}
			}
		}
		List&lt;Entry&lt;String, T&gt;&gt; beans = new ArrayList&lt;&gt;(map.entrySet());
		beans.sort((o1, o2) -&gt; AnnotationAwareOrderComparator.INSTANCE.compare(o1.getValue(), o2.getValue()));
		return beans;
	}
```

â€‹	ä»iocä¸­è·å–æ‰€æœ‰`ServletContextInitialize`çš„å­ç±»,è€Œè¿™ä¸ªbeanå°±åˆšå¥½æ˜¯ä¹‹å‰é…ç½®ç±»ä¸­çš„bean,`DispatcherServletRegistrationBean`.

â€‹	è‡³äºæ³¨å†Œçš„é€»è¾‘å°±ä¸é˜è¿°äº†,å¾ˆç®€å•,é¡ºç€`DispatcherServletRegistrationBean`çš„çˆ¶ç±»`RegistrationBean`çœ‹ä¸‹å»å°±å¥½.



# ä¸ƒã€æ•´ç†çº¿ç´¢

â€‹	å‰é¢è¯´äº†é‚£ä¹ˆå¤šè·Ÿ404å®Œå…¨æ²¡æœ‰å…³ç³»å‘€,å…¶å®å‰é¢æ˜¯åœ¨åšé“ºå«è€Œå·²,çœ‹å®˜åˆ«ç€æ€¥.ç”±å‰æ–‡çš„é€»è¾‘å¯ä»¥çŸ¥é“åœ¨tomcaté‡Œé¢è‡³å°‘æ³¨å†Œäº†2ä¸ªservetl,ä¸€ä¸ªæ˜¯springçš„(åé¢è¦†ç›–çš„),ä¸€ä¸ªæ˜¯jspçš„.é‚£ä¹ˆå®Œå…¨ç”±ç†ç”±çŒœæµ‹,æœ€åç”±JstlViewè½¬å‘çš„è¯·æ±‚åˆ°äº†jspServleté‡Œé¢.æ¥çœ‹çœ‹jspSerlveté‡Œé¢å¹²äº†å•¥?

```java
 // JspServlet
 public void service (HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

       	// çœç•¥....

        try {
            serviceJspFile(request, response, jspUri, precompile);
        } catch (RuntimeException e) {
            throw e;
        } catch (ServletException e) {
            throw e;
        } catch (IOException e) {
            throw e;
        } catch (Throwable e) {
            ExceptionUtils.handleThrowable(e);
            throw new ServletException(e);
        }

    }
```

â€‹	åˆ«é—®æˆ‘ä¸ºå•¥åªè´´äº†serviceè¿™ä¸ªæ–¹æ³•.å…ˆçœ‹çœ‹ç¬¬ä¸€ä¸ªæ–¹æ³•`serviceJspFile`.

```java
// JspServlet 
private void serviceJspFile(HttpServletRequest request,
                                HttpServletResponse response, String jspUri,
                                boolean precompile)
        throws ServletException, IOException {

        JspServletWrapper wrapper = rctxt.getWrapper(jspUri);
        if (wrapper == null) {
            synchronized(this) {
                wrapper = rctxt.getWrapper(jspUri);
                if (wrapper == null) {
                    // Check if the requested JSP page exists, to avoid
                    // creating unnecessary directories and files.
                  	// åˆ¤æ–­ jsp æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                    if (null == context.getResource(jspUri)) {
                        handleMissingResource(request, response, jspUri);
                        return;
                    }
                    wrapper = new JspServletWrapper(config, options, jspUri,
                                                    rctxt);
                    rctxt.addWrapper(jspUri,wrapper);
                }
            }
        }

        try {
            wrapper.service(request, response, precompile);
        } catch (FileNotFoundException fnfe) {
            handleMissingResource(request, response, jspUri);
        }

    }
```

â€‹	è¯º,æ ¸å¿ƒä»£ç è¢«æŠ“äº†.è¿™ä¸ªSerlvetContext,æ—¢ç„¶åœ¨tomcaté‡Œé¢é‚£ä¹ˆå®ƒçš„å®ç°ç±»è‚¯å®šæ˜¯`ApplicationContext`,ä¸ç”¨æ€€ç–‘,ä¸ä¿¡ä½ è·Ÿè·Ÿæµç¨‹çœ‹çœ‹.

â€‹	æ—¢ç„¶æ˜¯`ApplicationContext`ä¸­è·å–èµ„æº,é‚£æ¥çœ‹çœ‹æ˜¯æ€ä¹ˆæ‹¿çš„æ–‡ä»¶å§.

```java
//  ApplicationContext
public URL getResource(String path) throws MalformedURLException {

      	// çœç•¥... 
        WebResourceRoot resources = context.getResources();
        if (resources != null) {
          	// è·å–èµ„æº
            return resources.getResource(validatedPath).getURL();
        }

        return null;
    }

```

â€‹	è½¬æˆ˜åˆ° `WebResourceRoot`é‡Œå»,`WebResourceRoot`æ˜¯ä¸ªæ¥å£,åœ¨æœ¬æ¡ˆä¾‹ä¸­çš„å”¯ä¸€å­ç±»æ˜¯`StandardRoot`.

```java
// StandardRoot
@Override
    public WebResource getResource(String path) {
        return getResource(path, true, false);
    }

    protected WebResource getResource(String path, boolean validate,
            boolean useClassLoaderResources) {
        if (validate) {
            path = validate(path);
        }
				// åˆ¤æ–­æ˜¯å¦å…è®¸ç¼“å­˜,è¿™ä¸ªé»˜è®¤å€¼æ˜¯true
        if (isCachingAllowed()) {
            return cache.getResource(path, useClassLoaderResources);
        } else {
            return getResourceInternal(path, useClassLoaderResources);
        }
    }
```

â€‹	è¿™é‡Œåˆ†ä¸¤ç§æƒ…å†µ,ä¸€ä¸ªæ˜¯ä»æ¢æˆé‡Œé¢è·å–,å¦å¤–åˆ™ä»éç¼“å­˜ä¸­è·å–,ç¼“å­˜é‡Œé¢çš„ä¸–ç•Œå¾ˆç²¾å½©çš„.



## 7.1 ä»ç¼“å­˜é‡Œé¢è·å–

```java
// Cache
protected WebResource getResource(String path, boolean useClassLoaderResources) {

  	// çœç•¥....
		// åˆ¤æ–­æ˜¯å¦è·å–åˆ°ç¼“å­˜
    if (cacheEntry == null) {
        // Local copy to ensure consistency
        int objectMaxSizeBytes = getObjectMaxSizeBytes();
      	// åˆ›å»ºç¼“å­˜å¯¹è±¡
        CachedResource newCacheEntry = new CachedResource(this, root, path, getTtl(),
                objectMaxSizeBytes, useClassLoaderResources);

        // Concurrent callers will end up with the same CachedResource
        // instance
      	// æ”¾å…¥ç¼“å­˜ä¸­
        cacheEntry = resourceCache.putIfAbsent(path, newCacheEntry);
				// äºŒæ¬¡åˆ¤æ–­
        if (cacheEntry == null) {
            // newCacheEntry was inserted into the cache - validate it
            cacheEntry = newCacheEntry;
          	// éªŒè¯èµ„æºçš„åˆæ³•æ€§(è¿™é‡Œå°±çŸ³é”¤äº†)
            cacheEntry.validateResource(useClassLoaderResources);
		// çœç•¥....

    return cacheEntry;
}
```

â€‹	è¿˜å·®2æ­¥

```java
// CachedResource
protected boolean validateResource(boolean useClassLoaderResources) {
       // çœç•¥..
  			// éç©ºæ£€æŸ¥
        if (webResource == null) {
          	// åŠ é”
            synchronized (this) {
              	// åŒé‡æ£€æŸ¥
                if (webResource == null) {
                    webResource = root.getResourceInternal(
                            webAppPath, useClassLoaderResources);
                    getLastModified();
                    getContentLength();
                    nextCheck = ttl + now;
                    // exists() is a relatively expensive check for a file so
                    // use the fact that we know if it exists at this point
                    if (webResource instanceof EmptyResource) {
                        cachedExists = Boolean.FALSE;
                    } else {
                        cachedExists = Boolean.TRUE;
                    }
                    return true;
                }
            }
        }
}
```

â€‹	ç¨‹åºåˆæ¬¡å…è®¸çš„æ—¶å€™,webResourceè‚¯å®šæ˜¯ä¸ºç©ºçš„,åˆ«è¯´ç¼“å­˜äº†.è¿™é‡Œçš„rootæ˜¯`StandardRoot`,åˆè°ƒç”¨å›å»äº†.

```java
// StandardRoot

 private final List&lt;List&lt;WebResourceSet&gt;&gt; allResources =
            new ArrayList&lt;&gt;();
    {
        allResources.add(preResources);
        allResources.add(mainResources);
        allResources.add(classResources);
        allResources.add(jarResources);
        allResources.add(postResources);
    }

protected final WebResource getResourceInternal(String path,
            boolean useClassLoaderResources) {
        WebResource result = null;
        WebResource virtual = null;
        WebResource mainEmpty = null;
        for (List&lt;WebResourceSet&gt; list : allResources) {
            for (WebResourceSet webResourceSet : list) {
                if (!useClassLoaderResources &amp;&amp;  !webResourceSet.getClassLoaderOnly() ||
                        useClassLoaderResources &amp;&amp; !webResourceSet.getStaticOnly()) {
                    result = webResourceSet.getResource(path);
                    if (result.exists()) {
                        return result;
                    }
                    if (virtual == null) {
                        if (result.isVirtual()) {
                            virtual = result;
                        } else if (main.equals(webResourceSet)) {
                            mainEmpty = result;
                        }
                    }
                }
            }
        }
				// çœç•¥...
        // Default is empty resource in main resources
        return mainEmpty;
    }
```

â€‹	è¿™é‡Œéå†ä¸åŒèµ„æºç±»åˆ«,æ¥åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨,å¦‚æœå­˜åœ¨å°±è¿”å›,ç„¶åæ”¾å…¥ç¼“å­˜ä¸­.è‡³äºä»éç¼“å­˜ä¸­è·å–çš„é€»è¾‘å°±ä¸Šé¢`getResourceInternal`çš„é€»è¾‘,å°±ä¸ç½—å—¦äº†.

â€‹	å—¯,è¿™ä¸ªæœ‰å•¥ç”¨å‘¢?è¿˜æ˜¯æœªè§£å†³404çš„é—®é¢˜å‘€,åˆ«æ€¥å¿«äº†.



# å…«ã€è¢«é—å¿˜çš„é™æ€èµ„æºç›‘å¬å™¨(StaticResourceConfigurer)

â€‹	å°‘ä¾ æ˜¯å¦è®°å¾—åœ¨åˆ›å»ºtomcatçš„æ—¶å€™åœ¨servletContextä¸­æ·»åŠ äº†ä¸ªè¿™ä¸ªç›‘å¬å™¨å‘¢?

```java
// TomcatServletWebServerFactory
protected void prepareContext(Host host, ServletContextInitializer[] initializers) {
		// çœç•¥...
		context.addLifecycleListener(new StaticResourceConfigurer(context));
		// çœç•¥...
	}
```

â€‹	å†æ¥çœ‹çœ‹è¿™ä¸ªç›‘å¬å™¨çš„é€»è¾‘å§.

```java
// TomcatServletWebServerFactory$StaticResourceConfigurer
private final class StaticResourceConfigurer implements LifecycleListener {

		private final Context context;

		private StaticResourceConfigurer(Context context) {
			this.context = context;
		}

		@Override
		public void lifecycleEvent(LifecycleEvent event) {
			if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {
				addResourceJars(getUrlsOfJarsWithMetaInfResources());
			}
		}

		private void addResourceJars(List&lt;URL&gt; resourceJarUrls) {
			for (URL url : resourceJarUrls) {
				String path = url.getPath();
				if (path.endsWith(&quot;.jar&quot;) || path.endsWith(&quot;.jar!/&quot;)) {
					String jar = url.toString();
					if (!jar.startsWith(&quot;jar:&quot;)) {
						// A jar file in the file system. Convert to Jar URL.
						jar = &quot;jar:&quot; + jar + &quot;!/&quot;;
					}
					addResourceSet(jar);
				}
				else {
					addResourceSet(url.toString());
				}
			}
		}

		private void addResourceSet(String resource) {
			try {
				if (isInsideNestedJar(resource)) {
					// It's a nested jar but we now don't want the suffix because Tomcat
					// is going to try and locate it as a root URL (not the resource
					// inside it)
					resource = resource.substring(0, resource.length() - 2);
				}
				URL url = new URL(resource);
				String path = &quot;/META-INF/resources&quot;;
				this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, &quot;/&quot;, url, path);
			}
			catch (Exception ex) {
				// Ignore (probably not a directory)
			}
		}

		private boolean isInsideNestedJar(String dir) {
			return dir.indexOf(&quot;!/&quot;) &lt; dir.lastIndexOf(&quot;!/&quot;);
		}

	}

```

â€‹	æ— è®ºé€»è¾‘æ€ä¹ˆå˜åŒ–,æœ€åç›‘å¬å™¨çš„ä»£ç éƒ½ä¼šèµ°åˆ°`this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, &quot;/&quot;, url, path);`è¿™å¥è¯æ¥.

â€‹	çœ‹åˆ°`ResourceSetType.RESOURCE_JAR`è¿™ä¸ªå¸¸é‡æ˜¯å¦æœ‰ç‚¹æ„Ÿè§‰å‘¢?æ²¡æ„Ÿè§‰å°±è„±æ‰è¡£æœå†çœ‹çœ‹.

```java
// StandardRoot 
public void createWebResourceSet(ResourceSetType type, String webAppMount,
            URL url, String internalPath) {
        BaseLocation baseLocation = new BaseLocation(url);
        createWebResourceSet(type, webAppMount, baseLocation.getBasePath(),
                baseLocation.getArchivePath(), internalPath);
    }

    @Override
    public void createWebResourceSet(ResourceSetType type, String webAppMount,
            String base, String archivePath, String internalPath) {
        List&lt;WebResourceSet&gt; resourceList;
        WebResourceSet resourceSet;

        switch (type) {
            case PRE:
                resourceList = preResources;
                break;
            case CLASSES_JAR:
                resourceList = classResources;
                break;
            case RESOURCE_JAR:
                resourceList = jarResources;
                break;
            case POST:
                resourceList = postResources;
                break;
            default:
                throw new IllegalArgumentException(
                        sm.getString(&quot;standardRoot.createUnknownType&quot;, type));
        }
      	// çœç•¥
        resourceList.add(resourceSet);
    }
```

â€‹	æ˜¯ä¸æ˜¯è¿™ä¸€åˆ‡éƒ½å›­å›å»äº†ï¼Ÿæ˜¯ä¸æ˜¯æ„Ÿè§‰ç–‘æƒ‘éƒ½æ²¡äº†?å¦‚æœè¿˜æ˜¯ä¸è§£åœ¨å»çœ‹çœ‹èµ„æºè§£æçš„é‚£å—å„¿.



# ä¹ã€çœŸç›¸

â€‹	ä¸ºç”šä¹ˆæ˜¯404å‘¢?é‚£æ˜¯å› ä¸ºåœ¨StandardRooté‡Œé¢çš„resourceListä¸­ä¸å­˜åœ¨æŒ‡å®šçš„æ ¹è·¯å¾„,æ‰€ä»¥æ˜¯404.åˆè¦æœ‰å°ä¼™ä¼´è¦æ äº†,è¯´MATE-INFOç›®å½•ä¸‹é¢çš„éƒ½æ²¡é—®é¢˜.

â€‹	æ˜¯,æ²¡é—®é¢˜.å› ä¸ºspringBootæŠŠè¿™ä¸ªè·¯å¾„åŠ è¿›å»äº†.ä¸ä¿¡ä½ çœ‹.

```java
// StaticResourceConfigurer
private final class StaticResourceConfigurer implements LifecycleListener {

		private final Context context;

		private StaticResourceConfigurer(Context context) {
			this.context = context;
		}

		@Override
		public void lifecycleEvent(LifecycleEvent event) {
			if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {
				addResourceJars(getUrlsOfJarsWithMetaInfResources());
			}
		}

		private void addResourceJars(List&lt;URL&gt; resourceJarUrls) {
			// çœç•¥
		}

		private void addResourceSet(String resource) {
			// çœç•¥
		}

		private boolean isInsideNestedJar(String dir) {
			return dir.indexOf(&quot;!/&quot;) &lt; dir.lastIndexOf(&quot;!/&quot;);
		}

	}
```

â€‹	åœ¨`getUrlsOfJarsWithMetaInfResources`æ–¹æ³•é‡Œé¢å°±æœ‰è¿™ä¸ªè·¯å¾„.é€»è¾‘ç®€å•å°±ä¸è´´å‡ºæ¥äº†.



## 9.1 å¦‚ä½•è§£å†³404

â€‹	æ ¹æ®ä»¥ä¸Šçš„åˆ†æ,å¯ä»¥å’Œspringä¸€æ ·å¼„ä¸ªç›‘å¬å™¨,åœ¨resourceListæ·»åŠ æŒ‡å®šçš„è·¯å¾„.æœ€ç®€å•æš´åŠ›çš„æ–¹æ³•å¦‚ä¸‹:

```java
@Controller
@EnableAutoConfiguration
@Configuration
public class Main {

    public static void main(String[] args) {
        SpringApplication.run(Main.class,args);
    }

    @RequestMapping(&quot;/test-static&quot;)
    public String testStatic(){
        return &quot;index-static&quot;;
    }

    @RequestMapping(&quot;/test-public&quot;)
    public String testPublic(){
        return &quot;index-public&quot;;
    }

    @RequestMapping(&quot;/test-resources&quot;)
    public String testResources(){
        return &quot;index-resources&quot;;
    }

    @RequestMapping(&quot;/test-meta&quot;)
    public String testMeta(){
        return &quot;index-meta&quot;;
    }

    @Bean
    public TomcatServletWebServerFactory getTomcatServletWebServerFactory(){
        return new AdvTomcatServletWebServerFactory();
    }

}

```

è‡ªå®šä¹‰å·¥å‚:

```java
public class AdvTomcatServletWebServerFactory extends TomcatServletWebServerFactory {

    private Context context;

    public AdvTomcatServletWebServerFactory(){
        getContextLifecycleListeners().add(new AdvResourceListener());
    }
		// è¿™ä¸ªæ–¹æ³•æ˜¯ springç•™ä¸‹çš„æ¨¡æ¿æ–¹æ³•
  	// å¯ä»¥é€šè¿‡è¿™ä¸ªæ–¹æ³•è¿›è¡Œæ‰©å±•
    @Override
    protected void postProcessContext(Context context) {
        this.context = context;
    }

    private  class AdvResourceListener implements LifecycleListener{

        @Override
        public void lifecycleEvent(LifecycleEvent event) {
            if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {
                final URL resource = AdvTomcatServletWebServerFactory.class.getClassLoader().getResource(&quot;.&quot;);
                final WebResourceRoot resources = AdvTomcatServletWebServerFactory.this.context.getResources();
                resources.createWebResourceSet(WebResourceRoot.ResourceSetType.RESOURCE_JAR, &quot;/&quot;, resource, &quot;/static&quot;);
                resources.createWebResourceSet(WebResourceRoot.ResourceSetType.RESOURCE_JAR, &quot;/&quot;, resource, &quot;/public&quot;);
                resources.createWebResourceSet(WebResourceRoot.ResourceSetType.RESOURCE_JAR, &quot;/&quot;, resource, &quot;/resources&quot;);
            }

        }
    }
}
```

â€‹	é€šè¿‡è‡ªå·±çš„å·¥å‚æ›¿æ¢æ‰springçš„å·¥å‚,å®ç°æ³¨å†Œè‡ªå·±çš„ç›‘å¬å™¨,å½“ç„¶æ–¹æ³•è¿˜æœ‰å¾ˆå¤š,å¦‚æœä½ ç†Ÿæ‚‰tomcatçš„å¯åŠ¨æµç¨‹çš„è¯.

# åã€å°ç»“

â€‹	åœ¨springBootçš„æ‡’äººå¥—é¤ä¸‹,å‡ºç°é—®é¢˜å¾€å¾€ä¼šè®©äººé˜²ä¸èƒœé˜²å‘€,æ¯”å¦‚è¿™ä¸ª404,æ ¹æœ¬æ²¡æœ‰ä»»ä½•ä¿¡æ¯è¯´å“ªé‡Œæœ‰é—®é¢˜(é™¤éæ˜¯å¼€äº†debugæ—¥å¿—).

â€‹	æœ¬æ¥å°±æƒ³è°¢è°¢è§£å†³æ–¹æ¡ˆçš„,ç»“æœå†™äº†è¿™ä¹ˆå¤š,åƒé¥­äº†.</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">ä¸€ã€å‰è¨€ â€‹ æœ€è¿‘æœ‰å°æœ‹å‹åœ¨å­¦ä¹ spring bootçš„æ—¶å€™é‡åˆ°äº†ä¸€ä¸ªé—®é¢˜,æŒ‰ç…§æ•™ç¨‹ä¸Šæ“ä½œå§‹ç»ˆæ˜¯404.äºæ˜¯å°±ç™¾äº‹ä¸å¾—å…¶è§£.é—®æˆ‘çš„æ—¶å€™,æˆ‘ä¹Ÿä¸€è„¸è’™B,æ¯•ç«Ÿjspè¿™ç©æ„å„¿å¥½ä¹…éƒ½æ²¡ç¢°åˆ°è¿‡äº†,ä¹‹å‰ç¢°jspçš„æ—¶å€™è¿˜æ˜¯åœ¨sshçš„æ—¶å€™. â€‹ æ—¢ç„¶é‡åˆ°é—®é¢˜å°±æ¥åˆ†æä¸€ä¸‹å‘—,è¶ç€æœ€è¿‘åœ¨çœ‹springçš„æºç . äºŒã€æ¡ˆå‘ç°åœº ymal: server: port: 9090 spring: mvc: view: prefix: /WEB-INF/jsp/ suffix: .jsp pom: &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;tomcat-embed-jasper&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; ä»£ç : @Controller @EnableAutoConfiguration public class App { public static void main(String[] args) { SpringApplication.run(App.class,args); } @RequestMapping(&quot;/test&quot;) public String test(){ return &quot;index&quot;; } } â€‹ æŒ‰ç…§ä»¥ä¸Šä»£ç ,åº”è¯¥æ˜¯æ²¡æœ‰ä»€ä¹ˆé—®é¢˜çš„,æ¯•ç«Ÿäººå®¶çš„æ•™ç¨‹ä¹Ÿæ˜¯è¿™ä¹ˆåšçš„,åªä¸è¿‡åˆ«äººæ˜¯ç”¨eclipse,ä»–æ˜¯ç”¨çš„ideaç½¢äº†.æˆ‘ä¹Ÿæ‡’å¾—å»åˆ†æä¸ºå•¥eclipseæ²¡å¾—é—®é¢˜äº†,ç›´æ¥æ¥çœ‹çœ‹ä¸ºå•¥ä¼šæœ‰è¿™ä¸ªé—®é¢˜. ä¸‰ã€åˆ†æ â€‹ ä¼—æ‰€å‘¨çŸ¥,spring bootåªæ˜¯åœ¨springä¸Šé¢åŒ…äº†ä¸€å±‚çš®,é‡Œé¢è¿˜æ˜¯åˆ©ç”¨äº†springçš„ä¸€äº›æœºåˆ¶æ¥å®Œæˆ,å½“ç„¶åŠ è½½è‡ªåŠ¨åŒ–é…ç½®,å¼€ç®±å³ç”¨,æ„Ÿè§‰å¾ˆæ™ºèƒ½. â€‹ springbootä¸ºæˆ‘ä»¬å¼€å‘è€…çœå»äº†å¾ˆå¤šé…ç½®ä¸Šçš„éº»çƒ¦,å¤§éƒ¨åˆ†éƒ½é»˜è®¤é…ç½®å¥½äº†,ä½†æ˜¯è™½ç„¶ä¾¿åˆ©äº†å¼€å‘è€…,ä½†ä¹Ÿå¸¦æ¥äº†ä¸€äº›éº»çƒ¦,å°±å¦‚è¿™ä¸ªé—®é¢˜,æ•´ä¸ªæ—¥å­è¾“å‡ºçª—å£éƒ½æ²¡æœ‰æ—¥å¿—æ˜¾ç¤ºä¸ºå•¥ä¼šæ˜¯404,æ–‡ä»¶æ˜æ˜åœ¨é‚£,ä¸ºå•¥ä¼šæ‰¾ä¸åˆ°å‘¢? â€‹ è¦è§£å†³è¿™ä¸ªé—®é¢˜,å°±è¦ä»springBootçš„è‡ªåŠ¨é…ç½®ä¸Šå…¥æ‰‹.æŒ‰ç…§ä¸Šé¢çš„é…ç½®,ç”¨çš„æ˜¯åµŒå…¥å¼çš„tomcat,é‚£ä¹ˆå°±ä»tomcatçš„é…ç½®å¼€å§‹. 3.1 ServletWebServerFactoryConfiguration â€‹ å½“ä½¿ç”¨springbootçš„wenåŠŸèƒ½çš„æ—¶å€™,æœ‰ä¸ªå…³é”®çš„é…ç½®å°±é¿å…ä¸äº†äº†,ä»£ç å¦‚ä¸‹: @Configuration(proxyBeanMethods = false) class ServletWebServerFactoryConfiguration { // åˆ¤æ–­classpathæ˜¯å¦å­˜åœ¨ Servlet,Tomcat,UpgradeProtocolç±» // å¦‚æœå­˜åœ¨å°±å¯ç”¨æ­¤é…ç½® // å½“ç„¶è¿˜è¦ ServletWebServerFactory æœŸå­ç±»æ²¡æœ‰ åœ¨å®¹å™¨ä¸­ @Configuration(proxyBeanMethods = false) @ConditionalOnClass({ Servlet.class, Tomcat.class, UpgradeProtocol.class }) @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT) static class EmbeddedTomcat { @Bean TomcatServletWebServerFactory tomcatServletWebServerFactory( ObjectProvider&amp;lt;TomcatConnectorCustomizer&amp;gt; connectorCustomizers, ObjectProvider&amp;lt;TomcatContextCustomizer&amp;gt; contextCustomizers, ObjectProvider&amp;lt;TomcatProtocolHandlerCustomizer&amp;lt;?&amp;gt;&amp;gt; protocolHandlerCustomizers) { // åˆ›å»ºtomcat å·¥å‚ TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(); factory.getTomcatConnectorCustomizers() .addAll(connectorCustomizers.orderedStream().collect(Collectors.toList())); factory.getTomcatContextCustomizers() .addAll(contextCustomizers.orderedStream().collect(Collectors.toList())); factory.getTomcatProtocolHandlerCustomizers() .addAll(protocolHandlerCustomizers.orderedStream().collect(Collectors.toList())); return factory; } } /** * Nested configuration if Jetty is being used. * åŒtomcatçš„é€»è¾‘ */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass({ Servlet.class, Server.class, Loader.class, WebAppContext.class }) @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT) static class EmbeddedJetty { @Bean JettyServletWebServerFactory JettyServletWebServerFactory( ObjectProvider&amp;lt;JettyServerCustomizer&amp;gt; serverCustomizers) { JettyServletWebServerFactory factory = new JettyServletWebServerFactory(); factory.getServerCustomizers().addAll(serverCustomizers.orderedStream().collect(Collectors.toList())); return factory; } } /** * Nested configuration if Undertow is being used. * åŒtomcatçš„é€»è¾‘ */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class }) @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT) static class EmbeddedUndertow { @Bean UndertowServletWebServerFactory undertowServletWebServerFactory( ObjectProvider&amp;lt;UndertowDeploymentInfoCustomizer&amp;gt; deploymentInfoCustomizers, ObjectProvider&amp;lt;UndertowBuilderCustomizer&amp;gt; builderCustomizers) { UndertowServletWebServerFactory factory = new UndertowServletWebServerFactory(); factory.getDeploymentInfoCustomizers() .addAll(deploymentInfoCustomizers.orderedStream().collect(Collectors.toList())); factory.getBuilderCustomizers().addAll(builderCustomizers.orderedStream().collect(Collectors.toList())); return factory; } } } â€‹ è¿™é‡Œå¯ä»¥çœ‹åˆ°,é…ç½®ç±»æŒ‰ç…§classpathä¸­çš„ç±»åˆ›å»ºäº†ä¸åŒçš„ServletWebServerFactory,æœ¬æ–‡è¿™é‡ŒåŠ å…¥äº†tomcat,æ‰€ä»¥è¿™é‡Œå°†ä¼šåˆ›å»ºTomcatServletWebServerFactory. â€‹ å½“ç„¶å…‰çœ‹è¿™ä¸ªè¿˜æ˜¯ä¸è¡Œçš„,è¦æ˜ç™½ä¸ºå•¥ä¼šè¿™ä¹ˆåˆ›å»º,é‚£ä¹ˆè¿™ä¸€åˆ‡è¦ä»springbootçš„å¯åŠ¨æµç¨‹å¼€å§‹åˆ†ææ‰èƒ½è§£é‡Šæ•´ä¸ªæƒ…å†µ. å››ã€SpringBootå¯åŠ¨æµç¨‹åˆ†æ â€‹ å¤ªé˜³åº•ä¸‹æ— æ–°é²œäº‹,æ¥æ­å¼€åä¸ºæ–¹ä¾¿çš„é¢çº±.å½“ç„¶è¿™åªæ˜¯åˆæ­¥çš„æ¢è®¨. @EnableAutoConfiguration public class Main { public static void main(String[] args) { SpringApplication.run(Main.class,args); } } â€‹ ç†Ÿæ‚‰springBootçš„äººçœ‹åˆ°è¿™æ ·çš„å†™æ³•æ˜¯å¦æ˜¯æ„Ÿåˆ°å¹³æ·¡æ— å¥‡?é‚£ä¹ˆè¿™çŸ­çŸ­çš„ä¸€è¡Œä»£ç åé¢åˆ°åº•å‘ç”Ÿäº†å•¥?? 4.1 SpringApplication.run public static ConfigurableApplicationContext run(Class&amp;lt;?&amp;gt; primarySource, String... args) { return run(new Class&amp;lt;?&amp;gt;[] { primarySource }, args); } public static ConfigurableApplicationContext run(Class&amp;lt;?&amp;gt;[] primarySources, String[] args) { return new SpringApplication(primarySources).run(args); } â€‹ åˆ›å»ºäº†ä¸ªSpringApplicationå¯¹è±¡åœ¨runï¼Ÿçœ‹çœ‹æ„é€ å‡½æ•°æ˜¯å¦æœ‰å•¥é€»è¾‘. public SpringApplication(Class&amp;lt;?&amp;gt;... primarySources) { this(null, primarySources); } public SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;... primarySources) { this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&amp;lt;&amp;gt;(Arrays.asList(primarySources)); // åˆ¤æ–­ web åº”ç”¨çš„ç±»å‹ // åˆ¤æ–­ä¾æ®ä¸º æ˜¯å¦å­˜åœ¨æŒ‡å®š DispatcherServlet,DispatcherHandler,ServletContainer,WebApplicationContext,ReactiveWebApplicationContextç­‰ç±» // ä½¿ç”¨ class.forName è¿›è¡ŒæŸ¥æ‰¾ // åˆ¤æ–­springç¨‹åºçš„ç±»å‹ this.webApplicationType = WebApplicationType.deduceFromClasspath(); // åŠ è½½ META-INF/spring.factories é…ç½®æ–‡ä»¶,å¹¶æŠŠ ApplicationContextInitializer ç›¸å…³çš„ç±»å…¨éƒ¨å®ä¾‹åŒ– setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // åŠ è½½ META-INF/spring.factories é…ç½®æ–‡ä»¶,å¹¶æŠŠ ApplicationListener ç›¸å…³çš„ç±» å…¨éƒ¨å®ä¾‹åŒ– setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // æ£€æŸ¥ main æ–¹æ³•æ‰€åœ¨çš„ç±» this.mainApplicationClass = deduceMainApplicationClass(); } â€‹ åœ¨æ„é€ çš„æ—¶å€™è¿˜æ˜¯åšäº†ä¸å°‘çš„é€»è¾‘,è¿™é‡Œå°±ä¸å¾—ä¸æä¸€ä¸‹springçš„é»‘é­”æ³•äº†,é‚£å°±æ˜¯SpringFactoriesLoader,è¿™ä¸ªä¸œè¥¿æœ‰ç‚¹åƒjavaä¸­çš„spiæœºåˆ¶,ä¸ä¹‹ä¸åŒæ˜¯springæ˜¯è¯»å–çš„æ˜¯META-INF/spring.factoriesæ–‡ä»¶.è‡³äºä¸ºå•¥ä¸ç”¨spiè¦è‡ªå·±å•æä¸ª,emmmmmm. â€‹ æ„é€ çš„é€»è¾‘å¾ˆç®€å•,ä¸æ˜¯å¾ˆå¤æ‚,å°±æ˜¯æ£€æµ‹ä¸€ä¸‹è¦å¯åŠ¨ä»€ä¹ˆç±»å‹çš„spring,å…·ä½“æ“ä½œæ˜¯åœ¨WebApplicationType.deduceFromClasspath();,è¿™ä¸ªç±»å‹åˆ¤æ–­è¿˜æ˜¯å¾ˆé‡è¦çš„,åé¢åˆ›å»ºspringä¸Šä¸‹æ–‡çš„æ—¶å€™ä¼šç”¨å¾—ä¸Š. 4.2 springApplication.run â€‹ å¯¹è±¡åˆ›å»ºå¥½äº†,åˆè¦ç»§ç»­runäº†. public ConfigurableApplicationContext run(String... args) { // åˆ›å»ºä¸€ä¸ªç”¨äºè®°å½• å¯åŠ¨-å…³é—­ æ—¶é—´çš„ StopWatch StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&amp;lt;SpringBootExceptionReporter&amp;gt; exceptionReporters = new ArrayList&amp;lt;&amp;gt;(); // è®¾ç½®ç¯å¢ƒå˜é‡ configureHeadlessProperty(); // åˆ›å»º EventPublishingRunListener // ç›¸å½“äºæ˜¯ä¸ªç»„åˆæ¨¡å¼,æ‰€æœ‰listener éƒ½é›†ä¸­åœ¨ SpringApplicationRunListeners ä¸­ SpringApplicationRunListeners listeners = getRunListeners(args); // å¯åŠ¨å®¹å™¨,å‘é€æ—¶é—´ listeners.starting(); try { // æŠŠ args å°è£…ä¸ºå¯¹è±¡,æ˜ å°„åˆ°ç¯å¢ƒä¸­ ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // åˆå§‹åŒ–ç¯å¢ƒ ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // è®¾ç½®ç¯å¢ƒå˜é‡ spring.beaninfo.ignore configureIgnoreBeanInfo(environment); // è·å– éœ€è¦æ‰“å°çš„ Banner å¹¶æŠŠ banner æ‰“å°åˆ°æ§åˆ¶å° Banner printedBanner = printBanner(environment); // æ ¹æ®ä¸åŒçš„ç±»å‹ åˆ›å»ºä¸åŒçš„ä¸Šä¸‹æ–‡ context = createApplicationContext(); // è·å– æ‰€æœ‰ SpringBootExceptionReporter ç›¸å…³çš„ç±» exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); // å‡†å¤‡ä¸Šä¸‹æ–‡ prepareContext(context, environment, listeners, applicationArguments, printedBanner); // åˆ·æ–°ä¸Šä¸‹æ–‡,å‘é€äº‹ä»¶ refreshContext(context); // æ¨¡æ¿æ–¹æ³• afterRefresh(context, applicationArguments); // åœæ­¢ stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); } // é€šçŸ¥ç›‘å¬å™¨,å·²ç»å¯åŠ¨ listeners.started(context); // è°ƒç”¨ runnerçš„ run æ–¹æ³• callRunners(context, applicationArguments); } catch (Throwable ex) { // å¤„ç†è¿è¡Œæ—¶çš„é”™è¯¯ handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); } try { // é€šçŸ¥ç›‘å¬å™¨,æ­£åœ¨è¿è¡Œ listeners.running(context); } catch (Throwable ex) { // å¤„ç†è¿è¡Œæ—¶çš„é”™è¯¯ handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); } // è¿”å›ä¸Šä¸‹æ–‡ return context; } â€‹ ç”±äºæœ¬æ–‡ä¸æ˜¯åˆ†æä»£ç çš„æ–‡ç« ,æ‰€ä»¥å…³æ³¨ç‚¹æ”¾åœ¨åˆ›å»ºspringä¸Šä¸‹æ–‡å’Œä¸Šä¸‹æ–‡çš„æ“ä½œä¸Š.åˆ†åˆ«æ˜¯createApplicationContextå’ŒrefreshContext 4.3 createApplicationContext protected ConfigurableApplicationContext createApplicationContext() { Class&amp;lt;?&amp;gt; contextClass = this.applicationContextClass; if (contextClass == null) { try { switch (this.webApplicationType) { case SERVLET: contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS); break; case REACTIVE: contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); } } catch (ClassNotFoundException ex) { throw new IllegalStateException( &quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, ex); } } return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass); } â€‹ è¿™é‡Œçš„ç±»å‹,æ˜¯æŒ‰ç…§ä¹‹å‰æ„é€ æ–¹æ³•ä¸­çš„ç±»å‹è¿›è¡Œåˆ›å»ºçš„,å¦‚æœä¸æ¸…æ¥šçš„å¯ä»¥å¾€ä¸Šç¿»ä¸€å“ˆ. å¦‚æœç±»å‹ä¸º: SERVLET å°±åˆ›å»º AnnotationConfigServletWebServerApplicationContext å¦‚æœç±»å‹ä¸º: REACTIVE å°±åˆ›å»º AnnotationConfigReactiveWebServerApplicationContext é»˜è®¤åˆ›å»º : AnnotationConfigApplicationContext â€‹ å¾ˆæ˜¾ç„¶è¿™é‡Œçš„ç±»å‹æ˜¯ SERVLET æ‰€ä»¥åˆ›å»ºäº† AnnotationConfigServletWebServerApplicationContext,ç»§æ‰¿å…³ç³»å¦‚ä¸‹. â€‹ ç†Ÿæ‚‰springçš„åŒå­¦æ˜¯ä¸æ˜¯æ„Ÿè§‰ä¸ClassPathXmlApplicationContextå·®ä¸å¤šï¼Ÿæˆ‘è§‰å¾—æ˜¯å·®ä¸å¤šçš„,åªæ˜¯å¹²äº‹çš„æ–¹å¼æœ‰ç‚¹åŒºåˆ«. â€‹ è¿™é‡ŒæŠŠå¯¹è±¡åˆ›å»ºå®Œäº†,ç„¶åè¿›è¡Œä¸€é¡¿éªšæ“ä½œ,è®¾ç½®å€¼,ç¯å¢ƒç­‰ç­‰.ä¸å†è¿™é‡Œè¿›è¡Œåˆ†æ.è¦çœ‹çš„å…³é”®ç‚¹æ˜¯refreshContext. 4.5 refreshContext â€‹ åˆ·æ–°ä¸Šä¸‹æ–‡,è¿™é‡Œåˆ·æ–°ä¼šæœ‰ä»€ä¹ˆéªšæ“ä½œå‘¢?æ¥ç§ç§å°±çŸ¥é“äº†. private void refreshContext(ConfigurableApplicationContext context) { refresh((ApplicationContext) context); if (this.registerShutdownHook) { try { // æ·»åŠ å…³é—­é’©å­,å…³é—­ç¨‹åºæ—¶,å…³é—­ä¸Šä¸‹æ–‡ é‡Šæ”¾èµ„æº context.registerShutdownHook(); } catch (AccessControlException ex) { // Not allowed in some environments. } } } â€‹ æ·»åŠ é’©å­è¿™ä¸ªå¯ä»¥ä¸ç”¨ç®¡,ä¸å½±å“é€»è¾‘. @Deprecated protected void refresh(ApplicationContext applicationContext) { Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext); refresh((ConfigurableApplicationContext) applicationContext); } â€‹ è™½ç„¶è¿™ä¸ªæ–¹æ³•è¿‡æ—¶,ä½†springè¿˜æ˜¯æ²¡æœ‰ç›´æ¥åˆ é™¤,çœŸå¤Ÿè‰¯å¿ƒçš„,ä¸åƒæŸFinal,ç›´æ¥åˆ ,çœŸTMSB. protected void refresh(ConfigurableApplicationContext applicationContext) { applicationContext.refresh(); } â€‹ æ³¨æ„è¿™é‡Œçš„context å®é™…ä¸Šæ˜¯AnnotationConfigServletWebServerApplicationContext,è€ŒAnnotationConfigServletWebServerApplicationContextæ²¡æœ‰é‡å†™è¿™ä¸ªæ–¹æ³•,æ˜¯ç»§æ‰¿çš„å®ƒçˆ¶ç±»ServletWebServerApplicationContext. // ServletWebServerApplicationContext @Override public final void refresh() throws BeansException, IllegalStateException { try { super.refresh(); } catch (RuntimeException ex) { stopAndReleaseWebServer(); throw ex; } } â€‹ ServletWebServerApplicationContextçš„çˆ¶ç±»æ˜¯AbstractApplicationContext // AbstractApplicationContext public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. // å‡†å¤‡åˆ·æ–°ä¸Šä¸‹æ–‡ç¯å¢ƒ prepareRefresh(); // Tell the subclass to refresh the internal bean factory. // åˆå§‹åŒ–beanFactory,è¿›è¡Œxmlé¢„è¯»å– ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. // å¯¹beanFactoryè¿›è¡Œå¡«å…… prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. // å­ç±»è¦†ç›–æ–¹æ³•åšé¢å¤–çš„å¤„ç† postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. // æ¿€æ´»å„ç§beanFactoryProcessors invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. //æ³¨å†Œæ‹¦æˆªbeanåˆ›å»ºçš„beanå¤„ç†å™¨ registerBeanPostProcessors(beanFactory); // Initialize message source for this context. // åˆå§‹åŒ–ä¸Šä¸‹æ–‡çš„æ¶ˆæ¯æº initMessageSource(); // Initialize event multicaster for this context. // åˆå§‹åŒ–ä¸Šä¸‹æ–‡çš„æ¶ˆæ¯å¹¿æ’­ initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. // ç•™ç»™å­ç±»æ¥åˆå§‹åŒ–å…¶ä»–çš„bean onRefresh(); // Check for listener beans and register them. // æ³¨å†Œæ‰€æœ‰beançš„ç›‘å¬å™¨ registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // åˆå§‹åŒ–å»¶è¿ŸåŠ è½½çš„bean finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. // æœ€åä¸€æ­¥,å‘å¸ƒæ¶ˆæ¯ finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } //å‘ç”Ÿå¼‚å¸¸,é”€æ¯æ‰€æœ‰bean // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. // é‡ç½®flag cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... // é‡ç½®ç¼“å­˜ resetCommonCaches(); } } } â€‹ è¿™é‡Œçš„é‡ç‚¹æ˜¯onRefresh,è¿™é‡ŒonRefreshæ˜¯ç”±å­ç±»ServletWebServerApplicationContextè¿›è¡Œå®ç°çš„. 4.6 onRefresh // ServletWebServerApplicationContext @Override protected void onRefresh() { super.onRefresh(); try { // åˆ›å»ºserver createWebServer(); } catch (Throwable ex) { throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex); } } â€‹ ç»ˆäºç»•åˆ°äº†åˆ›å»º server è¿™é‡Œäº†,ä¸çŸ¥å°‘ä¾ æ˜¯å¦è¿˜è®°å¾—é‚£ä¸ªé…ç½®ç±»??ServletWebServerFactoryConfiguration.é‚£ä¹ˆç°åœ¨æ‰çœŸæ­£çš„å¼€å§‹äº†. private void createWebServer() { WebServer webServer = this.webServer; // è·å–servlet ä¸Šä¸‹æ–‡ ServletContext servletContext = getServletContext(); // å¦‚æœ server ä¸ºç©º æˆ–è€… servletä¸Šä¸‹æ–‡ä¸ºç©º,å°±åˆ›å»ºserver if (webServer == null &amp;amp;&amp;amp; servletContext == null) { ServletWebServerFactory factory = getWebServerFactory(); this.webServer = factory.getWebServer(getSelfInitializer()); } else if (servletContext != null) { try { getSelfInitializer().onStartup(servletContext); } catch (ServletException ex) { throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex); } } initPropertySources(); } åˆ¤æ–­serveræ˜¯å¦åˆ›å»º æœªåˆ›å»ºå°±åˆ›å»º åˆå§‹åŒ– åˆå§‹åŒ–èµ„æº â€‹ è¿™é‡Œçš„ getWebServerFactory() æ–¹æ³•ä»å®¹å™¨ä¸­è·å–çš„,å®¹å™¨é‡Œé¢çš„æ˜¯ä¹‹å‰é…ç½®ç±»ä¸­åˆ›å»ºçš„. // ä»å®¹å™¨ä¸­è·å– ServletWebServerFactory protected ServletWebServerFactory getWebServerFactory() { // Use bean names so that we don't consider the hierarchy String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class); if (beanNames.length == 0) { throw new ApplicationContextException(&quot;Unable to start ServletWebServerApplicationContext due to missing &quot; + &quot;ServletWebServerFactory bean.&quot;); } if (beanNames.length &amp;gt; 1) { throw new ApplicationContextException(&quot;Unable to start ServletWebServerApplicationContext due to multiple &quot; + &quot;ServletWebServerFactory beans : &quot; + StringUtils.arrayToCommaDelimitedString(beanNames)); } return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class); } äº”ã€tomcatçš„åˆ›å»º â€‹ å‰é¢åƒè¾›ä¸‡è‹¦çš„è·å–åˆ°äº† tomcatServerçš„å·¥å‚,æ¥ä¸‹æ¥å°±çœ‹çœ‹æ˜¯æ€ä¹ˆåˆ›å»ºçš„å§. // TomcatServletWebServerFactory @Override public WebServer getWebServer(ServletContextInitializer... initializers) { // .. çœç•¥ // åˆå§‹åŒ– prepareContext(tomcat.getHost(), initializers); return getTomcatWebServer(tomcat); } â€‹ è¿™é‡ŒServletContextInitializeræ˜¯ä¸æ˜¯å’ŒServletContainerInitializeræœ‰ç‚¹ç¥ä¼¼?åˆ«è¯´ä¸ä»”ç»†çœ‹è¿˜æ˜¯ä¼šçœ‹é”™,è‡³äºè¿™ä¸¤ä¸ªæ˜¯å•¥å…³ç³»,è¿™é‡Œå°±ä¸ç¢ç£¨äº†,æ¯•ç«Ÿè¿™ä¸ªä¸æ˜¯é‡ç‚¹. 5.1 åˆå§‹åŒ– // TomcatServletWebServerFactory protected void prepareContext(Host host, ServletContextInitializer[] initializers) { //... çœç•¥ // æ·»åŠ ç›‘å¬å™¨ context.addLifecycleListener(new StaticResourceConfigurer(context)); ServletContextInitializer[] initializersToUse = mergeInitializers(initializers); host.addChild(context); configureContext(context, initializersToUse); postProcessContext(context); } â€‹ åœ¨åˆå§‹åŒ–è¿‡ç¨‹ä¸­æ·»åŠ äº†ä¸€ä¸ªåå­—ä¸ºé™æ€èµ„æºé…ç½®çš„ç›‘å¬å™¨,åå­—éƒ½å¾ˆæ€ªæ€ªçš„å¥½å§.å»çœ‹çœ‹è¿™ä¸ªç›‘å¬å™¨æ˜¯å¹²å˜›çš„. private final class StaticResourceConfigurer implements LifecycleListener { private final Context context; private StaticResourceConfigurer(Context context) { this.context = context; } @Override public void lifecycleEvent(LifecycleEvent event) { // åˆ¤æ–­æ—¶æœº if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) { addResourceJars(getUrlsOfJarsWithMetaInfResources()); } } private void addResourceJars(List&amp;lt;URL&amp;gt; resourceJarUrls) { for (URL url : resourceJarUrls) { String path = url.getPath(); if (path.endsWith(&quot;.jar&quot;) || path.endsWith(&quot;.jar!/&quot;)) { String jar = url.toString(); if (!jar.startsWith(&quot;jar:&quot;)) { // A jar file in the file system. Convert to Jar URL. jar = &quot;jar:&quot; + jar + &quot;!/&quot;; } addResourceSet(jar); } else { addResourceSet(url.toString()); } } } private void addResourceSet(String resource) { try { if (isInsideNestedJar(resource)) { // It's a nested jar but we now don't want the suffix because Tomcat // is going to try and locate it as a root URL (not the resource // inside it) resource = resource.substring(0, resource.length() - 2); } URL url = new URL(resource); String path = &quot;/META-INF/resources&quot;; this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, &quot;/&quot;, url, path); } catch (Exception ex) { // Ignore (probably not a directory) } } private boolean isInsideNestedJar(String dir) { return dir.indexOf(&quot;!/&quot;) &amp;lt; dir.lastIndexOf(&quot;!/&quot;); } } â€‹ ä»è¿™ä¸ªç›‘å¬å™¨çš„ä»£ç é€»è¾‘ä¸Šçœ‹ æ˜¯å¾€context.getResourcesä¸¢ä¸œè¥¿å‘€.è²Œä¼¼æ˜¯è·¯å¾„å•¥çš„,è¿™ä¼šä¸ä¼šä¸å¼€å¤´çš„404é—®é¢˜æœ‰å…³å‘¢ï¼Ÿ â€‹ createWebResourceSetè¿™ä¸ªæ–¹æ³•å«Œç–‘å¾ˆå¤§,å»çœ‹çœ‹. // StandardRoot public void createWebResourceSet(ResourceSetType type, String webAppMount, String base, String archivePath, String internalPath) { List&amp;lt;WebResourceSet&amp;gt; resourceList; WebResourceSet resourceSet; switch (type) { case PRE: resourceList = preResources; break; case CLASSES_JAR: resourceList = classResources; break; case RESOURCE_JAR: resourceList = jarResources; break; case POST: resourceList = postResources; break; default: throw new IllegalArgumentException( sm.getString(&quot;standardRoot.createUnknownType&quot;, type)); } // ..... çœç•¥ resourceList.add(resourceSet); } â€‹ ä»¥ä¸Šé€»è¾‘ä¸ºæ ¹æ®ä¸åŒçš„ç±»å‹,å¾€ä¸åŒçš„listä¸­æ·»åŠ è·¯å¾„.å¥½å§è¿˜æ˜¯çœ‹ä¸å‡ºæ¥è¿™ä¸ªåˆ°åº•æœ‰ä»€ä¹ˆç”¨,404çš„é—®é¢˜ä¹Ÿæ²¡æ‰¾åˆ°,ä¸å¦‚æœè·Ÿè¸ªä¸€ä¸‹è¯·æ±‚çœ‹çœ‹. å…­ã€è¯·æ±‚çš„è·Ÿè¸ª â€‹ springMVCå¯¹è¯·æ±‚çš„å¤„ç†é€»è¾‘ä¸€èˆ¬ä¸º DispatcherServletæ¥ç®¡è¯·æ±‚-&amp;gt;æŸ¥æ‰¾handler-&amp;gt;æŸ¥æ‰¾handlerDapter-&amp;gt;è§†å›¾è§£æå™¨-&amp;gt;è§£æè§†å›¾-&amp;gt;æ¸²æŸ“è§†å›¾. â€‹ è™½ç„¶è¿™ä¸ªé€»è¾‘ä¸ä¸å®Œå–„,å¯èƒ½è¿˜æ˜¯é”™çš„,ä½†å·®ä¸å¤š,ç¬”è€…è®¤ä¸ºå“ˆ. â€‹ é‚£ä¹ˆé—®é¢˜æ¥äº†,åœ¨springMVCä¸­çš„è§†å›¾è§£æå™¨æ˜¯å•¥å‘¢ï¼Ÿçœ‹çœ‹ViewResolverçš„å­ç±»å°±çŸ¥é“æ˜¯InternalResourceViewResolveräº†.ä½†è¿™ä¸ªæ²¡å•¥ç”¨å‘€,å› ä¸ºå…·ä½“çš„æ¸²æŸ“é€»è¾‘æ˜¯åœ¨è§†å›¾å¯¹è±¡é‡Œ,è§£æå™¨åœ¨è¿™é‡Œæ²¡å•¥å¤ªå¤§çš„ç”¨å¤„.æ‰€ä»¥æ¥çœ‹çœ‹jspçš„è§†å›¾JstlViewä¸­çš„æ“ä½œå§. public class JstlView extends InternalResourceView { @Nullable private MessageSource messageSource; /** * Constructor for use as a bean. * @see #setUrl */ public JstlView() { } /** * Create a new JstlView with the given URL. * @param url the URL to forward to */ public JstlView(String url) { super(url); } /** * Create a new JstlView with the given URL. * @param url the URL to forward to * @param messageSource the MessageSource to expose to JSTL tags * (will be wrapped with a JSTL-aware MessageSource that is aware of JSTL's * {@code javax.servlet.jsp.jstl.fmt.localizationContext} context-param) * @see JstlUtils#getJstlAwareMessageSource */ public JstlView(String url, MessageSource messageSource) { this(url); this.messageSource = messageSource; } /** * Wraps the MessageSource with a JSTL-aware MessageSource that is aware * of JSTL's {@code javax.servlet.jsp.jstl.fmt.localizationContext} * context-param. * @see JstlUtils#getJstlAwareMessageSource */ @Override protected void initServletContext(ServletContext servletContext) { if (this.messageSource != null) { this.messageSource = JstlUtils.getJstlAwareMessageSource(servletContext, this.messageSource); } super.initServletContext(servletContext); } /** * Exposes a JSTL LocalizationContext for Spring's locale and MessageSource. * @see JstlUtils#exposeLocalizationContext */ @Override protected void exposeHelpers(HttpServletRequest request) throws Exception { if (this.messageSource != null) { JstlUtils.exposeLocalizationContext(request, this.messageSource); } else { JstlUtils.exposeLocalizationContext(new RequestContext(request, getServletContext())); } } } â€‹ åœ¨jstlViewä¸­å¹¶æ²¡æœ‰çœ‹åˆ°jspçš„å¤„ç†é€»è¾‘,å»çˆ¶ç±»çœ‹çœ‹. public class InternalResourceView extends AbstractUrlBasedView { // çœç•¥... /** * Render the internal resource given the specified model. * This includes setting the model as request attributes. */ @Override protected void renderMergedOutputModel( Map&amp;lt;String, Object&amp;gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception { // Expose the model object as request attributes. exposeModelAsRequestAttributes(model, request); // Expose helpers as request attributes, if any. exposeHelpers(request); // Determine the path for the request dispatcher. String dispatcherPath = prepareForRendering(request, response); // Obtain a RequestDispatcher for the target resource (typically a JSP). RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath); if (rd == null) { throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() + &quot;]: Check that the corresponding file exists within your web application archive!&quot;); } // If already included or response already committed, perform include, else forward. if (useInclude(request, response)) { response.setContentType(getContentType()); if (logger.isDebugEnabled()) { logger.debug(&quot;Including [&quot; + getUrl() + &quot;]&quot;); } rd.include(request, response); } else { // Note: The forwarded resource is supposed to determine the content type itself. if (logger.isDebugEnabled()) { logger.debug(&quot;Forwarding to [&quot; + getUrl() + &quot;]&quot;); } rd.forward(request, response); } } // çœç•¥.... } â€‹ æ ¸å¿ƒå¤„ç†é€»è¾‘åœ¨renderMergedOutputModel,ç»è¿‡renderMergedOutputModelæ–¹æ³•ä¸€é¡¿éªšæ“ä½œä»¥å,æœ€åå‘ç°è¯·æ±‚è¢«RequestDispatcheræ¥ç®¡äº†.emmm,çº¿ç´¢åˆæ–­äº†,é‚£ä¹ˆæœ€åæ˜¯è¢«è°æ¥ç®¡çš„å‘¢?åœ¨j2eeçš„ä¸–ç•Œé‡Œ,èƒ½è¢«å•¥æ¥ç®¡?ä¸å°±æ˜¯ä¸ªservletæˆ–è€…filterå˜›. â€‹ é‚£ä¹ˆæ¥ä¸‹æ¥è¦ææ¸…æ¥šæ˜¯è°æ¥ç®¡äº†è¯·æ±‚,å¹¶æ¸²æŸ“äº†jsp,è™½ç„¶ç­”æ¡ˆå¾ˆæ˜¾ç„¶äº†,ä½†è¿˜æ˜¯è¦èµ°ä¸€ä¸‹æµç¨‹. 6.1 çŒœæµ‹æ˜¯servletæ¥ç®¡äº†è¯·æ±‚ â€‹ springMVC é‡Œ servlet?é‚£ä¸å°±æ˜¯DispatcherServletå˜›?ä½†æ€»è§‰å¾—ä¸å¯èƒ½,ä¸å¯èƒ½è¯·æ±‚ä»DispatcherServletæ¥åˆå›å»å§?é‚£å°±çœ‹çœ‹åœ¨åˆ›å»ºtomcatçš„æ—¶å€™æœ‰æ²¡æœ‰æ³¨å†Œå…¶ä»–çš„servelt. // TomcatServletWebServerFactory protected void prepareContext(Host host, ServletContextInitializer[] initializers) { // çœç•¥ .. if (isRegisterDefaultServlet()) { addDefaultServlet(context); } if (shouldRegisterJspServlet()) { addJspServlet(context); addJasperInitializer(context); } // çœç•¥ ... } â€‹ å¯ä»¥çœ‹åˆ°åœ¨åˆå§‹åŒ–çš„æ—¶å€™,æ³¨å†Œäº†ä¸¤ä¸ªservlet,ä¸€ä¸ªé»˜è®¤çš„servletä¸€ä¸ªæ˜¯jspçš„servlet // TomcatServletWebServerFactory private void addDefaultServlet(Context context) { Wrapper defaultServlet = context.createWrapper(); // åç§° defaultServlet.setName(&quot;default&quot;); defaultServlet.setServletClass(&quot;org.apache.catalina.servlets.DefaultServlet&quot;); defaultServlet.addInitParameter(&quot;debug&quot;, &quot;0&quot;); defaultServlet.addInitParameter(&quot;listings&quot;, &quot;false&quot;); defaultServlet.setLoadOnStartup(1); // Otherwise the default location of a Spring DispatcherServlet cannot be set // æ˜¯å¦è¿è¡Œè¦†ç›–,è¿™æ˜¯ä¸ºäº†dispatcherServletåšå‡†å¤‡ // æ–¹ä¾¿åœ¨åå…æŠŠè¿™ä¸ªé»˜è®¤çš„servletç»™è¦†ç›–æ‰ defaultServlet.setOverridable(true); context.addChild(defaultServlet); context.addServletMappingDecoded(&quot;/&quot;, &quot;default&quot;); } private void addJspServlet(Context context) { Wrapper jspServlet = context.createWrapper(); jspServlet.setName(&quot;jsp&quot;); jspServlet.setServletClass(getJsp().getClassName()); jspServlet.addInitParameter(&quot;fork&quot;, &quot;false&quot;); getJsp().getInitParameters().forEach(jspServlet::addInitParameter); jspServlet.setLoadOnStartup(3); context.addChild(jspServlet); // æ‹¦æˆª *.jsp åç¼€çš„è¯·æ±‚ context.addServletMappingDecoded(&quot;*.jsp&quot;, &quot;jsp&quot;); context.addServletMappingDecoded(&quot;*.jspx&quot;, &quot;jsp&quot;); } ä¸¤ä¸ªservlet,ä¸€ä¸ªé»˜è®¤çš„,ä¸€ä¸ªjspçš„.çœ‹åˆ°è¿™å„¿ä¼šä¸ä¼šæœ‰ç‚¹å¥‡æ€ª,ä¸ºå•¥ä¸æ³¨å†ŒdispatcherServlet?emmmä¸æ˜¯å¾ˆæ˜ç™½æ˜‚,ä½†æ˜¯è¿™ä¸ªæ ¸å¿ƒçš„servletæ˜¯ä¸ä¼šè½ä¸‹çš„. @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) @Configuration(proxyBeanMethods = false) /** * åŒ¹é…å®¹å™¨ä¸º servlet * **/ @ConditionalOnWebApplication(type = Type.SERVLET) /** * åˆ¤æ–­ class path è·¯å¾„ä¸‹æœ‰ DispatcherServlet.class * **/ @ConditionalOnClass(DispatcherServlet.class) /*** * åœ¨ ServletWebServerFactoryAutoConfiguration ä¹‹åç”Ÿæ•ˆ * */ @AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class) public class DispatcherServletAutoConfiguration { /* * The bean name for a DispatcherServlet that will be mapped to the root URL &quot;/&quot; */ public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = &quot;dispatcherServlet&quot;; /* * The bean name for a ServletRegistrationBean for the DispatcherServlet &quot;/&quot; */ public static final String DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME = &quot;dispatcherServletRegistration&quot;; @Configuration(proxyBeanMethods = false) @Conditional(DefaultDispatcherServletCondition.class) @ConditionalOnClass(ServletRegistration.class) // å¯ç”¨é…ç½® WebMvcProperties @EnableConfigurationProperties(WebMvcProperties.class) protected static class DispatcherServletConfiguration { @Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME) public DispatcherServlet dispatcherServlet(WebMvcProperties webMvcProperties) { DispatcherServlet dispatcherServlet = new DispatcherServlet(); dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest()); dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest()); dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound()); dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents()); dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails()); return dispatcherServlet; } @Bean @ConditionalOnBean(MultipartResolver.class) @ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) public MultipartResolver multipartResolver(MultipartResolver resolver) { // Detect if the user has created a MultipartResolver but named it incorrectly return resolver; } } @Configuration(proxyBeanMethods = false) @Conditional(DispatcherServletRegistrationCondition.class) @ConditionalOnClass(ServletRegistration.class) @EnableConfigurationProperties(WebMvcProperties.class) @Import(DispatcherServletConfiguration.class) protected static class DispatcherServletRegistrationConfiguration { @Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME) @ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME) public DispatcherServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet, WebMvcProperties webMvcProperties, ObjectProvider&amp;lt;MultipartConfigElement&amp;gt; multipartConfig) { DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(dispatcherServlet, webMvcProperties.getServlet().getPath()); // åç§° registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); // å¯åŠ¨é¡ºåº registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup()); multipartConfig.ifAvailable(registration::setMultipartConfig); return registration; } } // çœç•¥.... } â€‹ åœ¨è‡ªåŠ¨é…ç½®çš„è¿™ä¸ªç±»é‡Œé¢ç”Ÿæˆäº†ä¸€ä¸ªDispatcherServletRegistrationBeanå¯¹è±¡,è¿™ä¸ªå¯¹è±¡å°±æ˜¯ç”¨äºç»„æµ‹dispatcherServletçš„.DispatcherServletRegistrationBeanæ˜¯ServletContextInitializerçš„å­ç±»,ç”¨äºåˆå§‹åŒ–,æ³¨å†Œç­‰æ“ä½œç­‰. â€‹ é‚£ä¹ˆè¿™ä¸ªå¯¹è±¡æ˜¯åœ¨ä»€ä¹ˆæ—¶å€™æ³¨å†Œçš„å‘¢?åˆè¦å›åˆ°tomcatåˆ›å»ºçš„æ—¶å€™äº†. // TomcatServletWebServerFactory @Override public WebServer getWebServer(ServletContextInitializer... initializers) { // çœç•¥.. prepareContext(tomcat.getHost(), initializers); return getTomcatWebServer(tomcat); } â€‹ åœ¨è°ƒç”¨åˆå§‹åŒ–ä¸Šä¸‹æ–‡çš„æ—¶å€™æŠŠè¿™ä¸ªç©æ„å„¿ç»™ä¼ è¿›å»äº†. // TomcatServletWebServerFactory protected void prepareContext(Host host, ServletContextInitializer[] initializers) { // çœç•¥... ServletContextInitializer[] initializersToUse = mergeInitializers(initializers); host.addChild(context); configureContext(context, initializersToUse); postProcessContext(context); } â€‹ è¿™é‡Œåˆå¹¶äº†æ‰€æœ‰çš„ServletContextInitializerå¯¹è±¡,ä¼ å…¥åˆ°äº†configureContextæ–¹æ³•ä¸­. // TomcatServletWebServerFactory protected void configureContext(Context context, ServletContextInitializer[] initializers) { TomcatStarter starter = new TomcatStarter(initializers); context.addServletContainerInitializer(starter, NO_CLASSES); } â€‹ è¿™é‡ŒæŠŠServletContextInitializerè½¬æˆäº†ä¸€ä¸ªTomcatStarterå¯¹è±¡,å¹¶æŠŠè¿™ä¸ªå¯¹è±¡æ·»åŠ åˆ°äº†ä¸Šä¸‹æ–‡ä¸­å».è¿™ä¸ª TomcatStarterå°±å‰å®³äº†. class TomcatStarter implements ServletContainerInitializer { private static final Log logger = LogFactory.getLog(TomcatStarter.class); private final ServletContextInitializer[] initializers; private volatile Exception startUpException; TomcatStarter(ServletContextInitializer[] initializers) { this.initializers = initializers; } @Override public void onStartup(Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; classes, ServletContext servletContext) throws ServletException { try { // åˆå§‹åŒ–æ‰€æœ‰éœ€è¦ åˆå§‹åŒ–çš„ç±» for (ServletContextInitializer initializer : this.initializers) { initializer.onStartup(servletContext); } } catch (Exception ex) { this.startUpException = ex; // Prevent Tomcat from logging and re-throwing when we know we can // deal with it in the main thread, but log for information here. if (logger.isErrorEnabled()) { logger.error(&quot;Error starting Tomcat context. Exception: &quot; + ex.getClass().getName() + &quot;. Message: &quot; + ex.getMessage()); } } } Exception getStartUpException() { return this.startUpException; } } â€‹ TomcatStarterå®ç°äº†ServletContainerInitializeræ¥å£,è¿™ä¸ªæ¥å£å°±å‰å®³äº†,åœ¨servletçš„ç”Ÿå‘½ä¸­æœŸä¸­,ä¼šè°ƒç”¨å®ç°è¿™ä¸ªæ¥å£çš„onStartupæ–¹æ³•,è‡³äºä»€ä¹ˆæ˜¯servletçš„ç”Ÿå‘½å‘¨æœŸ,å°±ä¸å¼•å‡ºäº†,ä¼°è®¡ä¸€æ—¶åŠä¼šä¹Ÿè¯´ä¸å®Œ. â€‹ å—¯,çŸ¥é“è¿™ä¸ªä¸œè¥¿çš„å‰å®³,è¯´äº†è¿™ä¹ˆå¤š,ä¹Ÿæ²¡è¯´ServletContextInitializerè¿™ä¸ªä¸œè¥¿å“ªæ¥çš„.ä¸æ˜¯æ–¹æ³•ä¼ è¿›æ¥çš„å˜›?ä¸è¡Œå°±å›å»çœ‹çœ‹. @Override public WebServer getWebServer(ServletContextInitializer... initializers) { // çœç•¥... return getTomcatWebServer(tomcat); } â€‹ å—¯,æ˜¯ä¼ è¿›æ¥çš„,æ€ä¹ˆä¼ è¿›æ¥çš„ï¼Ÿå½“ç„¶æ˜¯åˆ›å»ºçš„æ—¶å€™ä¼ çš„äº†0.0 // ServletWebServerApplicationContext private void createWebServer() { WebServer webServer = this.webServer; ServletContext servletContext = getServletContext(); if (webServer == null &amp;amp;&amp;amp; servletContext == null) { ServletWebServerFactory factory = getWebServerFactory(); this.webServer = factory.getWebServer(getSelfInitializer()); } else if (servletContext != null) { try { getSelfInitializer().onStartup(servletContext); } catch (ServletException ex) { throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex); } } initPropertySources(); } 6.2 ServletContextInitializer æ€ä¹ˆæ¥çš„ // ServletWebServerApplicationContext private org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() { return this::selfInitialize; } private void selfInitialize(ServletContext servletContext) throws ServletException { prepareWebApplicationContext(servletContext); registerApplicationScope(servletContext); WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext); for (ServletContextInitializer beans : getServletContextInitializerBeans()) { beans.onStartup(servletContext); } } â€‹ è¿™å°±æ˜¯äº†,é‚£é…ç½®ç±»DispatcherServletAutoConfigurationé‡Œé¢çš„DispatcherServletRegistrationBeanå“ªå»äº†?è¿™é‡Œçš„ç¡®æ²¡æœ‰,ä¸è¿‡åœ¨getServletContextInitializerBeans()æ–¹æ³•è¿”å›çš„é›†åˆé‡Œé¢. // ServletWebServerApplicationContext protected Collection&amp;lt;ServletContextInitializer&amp;gt; getServletContextInitializerBeans() { return new ServletContextInitializerBeans(getBeanFactory()); } â€‹ ServletContextInitializerBeansæ˜¯ä¸€ä¸ªç»§æ‰¿äº†AbstractCollectionçš„é›†åˆå¯¹è±¡. // ServletContextInitializerBeans public ServletContextInitializerBeans(ListableBeanFactory beanFactory, Class&amp;lt;? extends ServletContextInitializer&amp;gt;... initializerTypes) { this.initializers = new LinkedMultiValueMap&amp;lt;&amp;gt;(); this.initializerTypes = (initializerTypes.length != 0) ? Arrays.asList(initializerTypes) : Collections.singletonList(ServletContextInitializer.class); addServletContextInitializerBeans(beanFactory); addAdaptableBeans(beanFactory); List&amp;lt;ServletContextInitializer&amp;gt; sortedInitializers = this.initializers.values().stream() .flatMap((value) -&amp;gt; value.stream().sorted(AnnotationAwareOrderComparator.INSTANCE)) .collect(Collectors.toList()); this.sortedList = Collections.unmodifiableList(sortedInitializers); logMappings(this.initializers); } â€‹ æ ¸å¿ƒé€»è¾‘å°±åœ¨æ„é€ æ–¹æ³•ä¸­çš„addServletContextInitializerBeansæ–¹æ³•ä¸­. // ServletContextInitializerBeans private void addServletContextInitializerBeans(ListableBeanFactory beanFactory) { for (Class&amp;lt;? extends ServletContextInitializer&amp;gt; initializerType : this.initializerTypes) { for (Entry&amp;lt;String, ? extends ServletContextInitializer&amp;gt; initializerBean : getOrderedBeansOfType(beanFactory, initializerType)) { addServletContextInitializerBean(initializerBean.getKey(), initializerBean.getValue(), beanFactory); } } } private &amp;lt;T&amp;gt; List&amp;lt;Entry&amp;lt;String, T&amp;gt;&amp;gt; getOrderedBeansOfType(ListableBeanFactory beanFactory, Class&amp;lt;T&amp;gt; type) { return getOrderedBeansOfType(beanFactory, type, Collections.emptySet()); } private &amp;lt;T&amp;gt; List&amp;lt;Entry&amp;lt;String, T&amp;gt;&amp;gt; getOrderedBeansOfType(ListableBeanFactory beanFactory, Class&amp;lt;T&amp;gt; type, Set&amp;lt;?&amp;gt; excludes) { String[] names = beanFactory.getBeanNamesForType(type, true, false); Map&amp;lt;String, T&amp;gt; map = new LinkedHashMap&amp;lt;&amp;gt;(); for (String name : names) { if (!excludes.contains(name) &amp;amp;&amp;amp; !ScopedProxyUtils.isScopedTarget(name)) { T bean = beanFactory.getBean(name, type); if (!excludes.contains(bean)) { map.put(name, bean); } } } List&amp;lt;Entry&amp;lt;String, T&amp;gt;&amp;gt; beans = new ArrayList&amp;lt;&amp;gt;(map.entrySet()); beans.sort((o1, o2) -&amp;gt; AnnotationAwareOrderComparator.INSTANCE.compare(o1.getValue(), o2.getValue())); return beans; } â€‹ ä»iocä¸­è·å–æ‰€æœ‰ServletContextInitializeçš„å­ç±»,è€Œè¿™ä¸ªbeanå°±åˆšå¥½æ˜¯ä¹‹å‰é…ç½®ç±»ä¸­çš„bean,DispatcherServletRegistrationBean. â€‹ è‡³äºæ³¨å†Œçš„é€»è¾‘å°±ä¸é˜è¿°äº†,å¾ˆç®€å•,é¡ºç€DispatcherServletRegistrationBeançš„çˆ¶ç±»RegistrationBeançœ‹ä¸‹å»å°±å¥½. ä¸ƒã€æ•´ç†çº¿ç´¢ â€‹ å‰é¢è¯´äº†é‚£ä¹ˆå¤šè·Ÿ404å®Œå…¨æ²¡æœ‰å…³ç³»å‘€,å…¶å®å‰é¢æ˜¯åœ¨åšé“ºå«è€Œå·²,çœ‹å®˜åˆ«ç€æ€¥.ç”±å‰æ–‡çš„é€»è¾‘å¯ä»¥çŸ¥é“åœ¨tomcaté‡Œé¢è‡³å°‘æ³¨å†Œäº†2ä¸ªservetl,ä¸€ä¸ªæ˜¯springçš„(åé¢è¦†ç›–çš„),ä¸€ä¸ªæ˜¯jspçš„.é‚£ä¹ˆå®Œå…¨ç”±ç†ç”±çŒœæµ‹,æœ€åç”±JstlViewè½¬å‘çš„è¯·æ±‚åˆ°äº†jspServleté‡Œé¢.æ¥çœ‹çœ‹jspSerlveté‡Œé¢å¹²äº†å•¥? // JspServlet public void service (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // çœç•¥.... try { serviceJspFile(request, response, jspUri, precompile); } catch (RuntimeException e) { throw e; } catch (ServletException e) { throw e; } catch (IOException e) { throw e; } catch (Throwable e) { ExceptionUtils.handleThrowable(e); throw new ServletException(e); } } â€‹ åˆ«é—®æˆ‘ä¸ºå•¥åªè´´äº†serviceè¿™ä¸ªæ–¹æ³•.å…ˆçœ‹çœ‹ç¬¬ä¸€ä¸ªæ–¹æ³•serviceJspFile. // JspServlet private void serviceJspFile(HttpServletRequest request, HttpServletResponse response, String jspUri, boolean precompile) throws ServletException, IOException { JspServletWrapper wrapper = rctxt.getWrapper(jspUri); if (wrapper == null) { synchronized(this) { wrapper = rctxt.getWrapper(jspUri); if (wrapper == null) { // Check if the requested JSP page exists, to avoid // creating unnecessary directories and files. // åˆ¤æ–­ jsp æ–‡ä»¶æ˜¯å¦å­˜åœ¨ if (null == context.getResource(jspUri)) { handleMissingResource(request, response, jspUri); return; } wrapper = new JspServletWrapper(config, options, jspUri, rctxt); rctxt.addWrapper(jspUri,wrapper); } } } try { wrapper.service(request, response, precompile); } catch (FileNotFoundException fnfe) { handleMissingResource(request, response, jspUri); } } â€‹ è¯º,æ ¸å¿ƒä»£ç è¢«æŠ“äº†.è¿™ä¸ªSerlvetContext,æ—¢ç„¶åœ¨tomcaté‡Œé¢é‚£ä¹ˆå®ƒçš„å®ç°ç±»è‚¯å®šæ˜¯ApplicationContext,ä¸ç”¨æ€€ç–‘,ä¸ä¿¡ä½ è·Ÿè·Ÿæµç¨‹çœ‹çœ‹. â€‹ æ—¢ç„¶æ˜¯ApplicationContextä¸­è·å–èµ„æº,é‚£æ¥çœ‹çœ‹æ˜¯æ€ä¹ˆæ‹¿çš„æ–‡ä»¶å§. // ApplicationContext public URL getResource(String path) throws MalformedURLException { // çœç•¥... WebResourceRoot resources = context.getResources(); if (resources != null) { // è·å–èµ„æº return resources.getResource(validatedPath).getURL(); } return null; } â€‹ è½¬æˆ˜åˆ° WebResourceRooté‡Œå»,WebResourceRootæ˜¯ä¸ªæ¥å£,åœ¨æœ¬æ¡ˆä¾‹ä¸­çš„å”¯ä¸€å­ç±»æ˜¯StandardRoot. // StandardRoot @Override public WebResource getResource(String path) { return getResource(path, true, false); } protected WebResource getResource(String path, boolean validate, boolean useClassLoaderResources) { if (validate) { path = validate(path); } // åˆ¤æ–­æ˜¯å¦å…è®¸ç¼“å­˜,è¿™ä¸ªé»˜è®¤å€¼æ˜¯true if (isCachingAllowed()) { return cache.getResource(path, useClassLoaderResources); } else { return getResourceInternal(path, useClassLoaderResources); } } â€‹ è¿™é‡Œåˆ†ä¸¤ç§æƒ…å†µ,ä¸€ä¸ªæ˜¯ä»æ¢æˆé‡Œé¢è·å–,å¦å¤–åˆ™ä»éç¼“å­˜ä¸­è·å–,ç¼“å­˜é‡Œé¢çš„ä¸–ç•Œå¾ˆç²¾å½©çš„. 7.1 ä»ç¼“å­˜é‡Œé¢è·å– // Cache protected WebResource getResource(String path, boolean useClassLoaderResources) { // çœç•¥.... // åˆ¤æ–­æ˜¯å¦è·å–åˆ°ç¼“å­˜ if (cacheEntry == null) { // Local copy to ensure consistency int objectMaxSizeBytes = getObjectMaxSizeBytes(); // åˆ›å»ºç¼“å­˜å¯¹è±¡ CachedResource newCacheEntry = new CachedResource(this, root, path, getTtl(), objectMaxSizeBytes, useClassLoaderResources); // Concurrent callers will end up with the same CachedResource // instance // æ”¾å…¥ç¼“å­˜ä¸­ cacheEntry = resourceCache.putIfAbsent(path, newCacheEntry); // äºŒæ¬¡åˆ¤æ–­ if (cacheEntry == null) { // newCacheEntry was inserted into the cache - validate it cacheEntry = newCacheEntry; // éªŒè¯èµ„æºçš„åˆæ³•æ€§(è¿™é‡Œå°±çŸ³é”¤äº†) cacheEntry.validateResource(useClassLoaderResources); // çœç•¥.... return cacheEntry; } â€‹ è¿˜å·®2æ­¥ // CachedResource protected boolean validateResource(boolean useClassLoaderResources) { // çœç•¥.. // éç©ºæ£€æŸ¥ if (webResource == null) { // åŠ é” synchronized (this) { // åŒé‡æ£€æŸ¥ if (webResource == null) { webResource = root.getResourceInternal( webAppPath, useClassLoaderResources); getLastModified(); getContentLength(); nextCheck = ttl + now; // exists() is a relatively expensive check for a file so // use the fact that we know if it exists at this point if (webResource instanceof EmptyResource) { cachedExists = Boolean.FALSE; } else { cachedExists = Boolean.TRUE; } return true; } } } } â€‹ ç¨‹åºåˆæ¬¡å…è®¸çš„æ—¶å€™,webResourceè‚¯å®šæ˜¯ä¸ºç©ºçš„,åˆ«è¯´ç¼“å­˜äº†.è¿™é‡Œçš„rootæ˜¯StandardRoot,åˆè°ƒç”¨å›å»äº†. // StandardRoot private final List&amp;lt;List&amp;lt;WebResourceSet&amp;gt;&amp;gt; allResources = new ArrayList&amp;lt;&amp;gt;(); { allResources.add(preResources); allResources.add(mainResources); allResources.add(classResources); allResources.add(jarResources); allResources.add(postResources); } protected final WebResource getResourceInternal(String path, boolean useClassLoaderResources) { WebResource result = null; WebResource virtual = null; WebResource mainEmpty = null; for (List&amp;lt;WebResourceSet&amp;gt; list : allResources) { for (WebResourceSet webResourceSet : list) { if (!useClassLoaderResources &amp;amp;&amp;amp; !webResourceSet.getClassLoaderOnly() || useClassLoaderResources &amp;amp;&amp;amp; !webResourceSet.getStaticOnly()) { result = webResourceSet.getResource(path); if (result.exists()) { return result; } if (virtual == null) { if (result.isVirtual()) { virtual = result; } else if (main.equals(webResourceSet)) { mainEmpty = result; } } } } } // çœç•¥... // Default is empty resource in main resources return mainEmpty; } â€‹ è¿™é‡Œéå†ä¸åŒèµ„æºç±»åˆ«,æ¥åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨,å¦‚æœå­˜åœ¨å°±è¿”å›,ç„¶åæ”¾å…¥ç¼“å­˜ä¸­.è‡³äºä»éç¼“å­˜ä¸­è·å–çš„é€»è¾‘å°±ä¸Šé¢getResourceInternalçš„é€»è¾‘,å°±ä¸ç½—å—¦äº†. â€‹ å—¯,è¿™ä¸ªæœ‰å•¥ç”¨å‘¢?è¿˜æ˜¯æœªè§£å†³404çš„é—®é¢˜å‘€,åˆ«æ€¥å¿«äº†. å…«ã€è¢«é—å¿˜çš„é™æ€èµ„æºç›‘å¬å™¨(StaticResourceConfigurer) â€‹ å°‘ä¾ æ˜¯å¦è®°å¾—åœ¨åˆ›å»ºtomcatçš„æ—¶å€™åœ¨servletContextä¸­æ·»åŠ äº†ä¸ªè¿™ä¸ªç›‘å¬å™¨å‘¢? // TomcatServletWebServerFactory protected void prepareContext(Host host, ServletContextInitializer[] initializers) { // çœç•¥... context.addLifecycleListener(new StaticResourceConfigurer(context)); // çœç•¥... } â€‹ å†æ¥çœ‹çœ‹è¿™ä¸ªç›‘å¬å™¨çš„é€»è¾‘å§. // TomcatServletWebServerFactory$StaticResourceConfigurer private final class StaticResourceConfigurer implements LifecycleListener { private final Context context; private StaticResourceConfigurer(Context context) { this.context = context; } @Override public void lifecycleEvent(LifecycleEvent event) { if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) { addResourceJars(getUrlsOfJarsWithMetaInfResources()); } } private void addResourceJars(List&amp;lt;URL&amp;gt; resourceJarUrls) { for (URL url : resourceJarUrls) { String path = url.getPath(); if (path.endsWith(&quot;.jar&quot;) || path.endsWith(&quot;.jar!/&quot;)) { String jar = url.toString(); if (!jar.startsWith(&quot;jar:&quot;)) { // A jar file in the file system. Convert to Jar URL. jar = &quot;jar:&quot; + jar + &quot;!/&quot;; } addResourceSet(jar); } else { addResourceSet(url.toString()); } } } private void addResourceSet(String resource) { try { if (isInsideNestedJar(resource)) { // It's a nested jar but we now don't want the suffix because Tomcat // is going to try and locate it as a root URL (not the resource // inside it) resource = resource.substring(0, resource.length() - 2); } URL url = new URL(resource); String path = &quot;/META-INF/resources&quot;; this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, &quot;/&quot;, url, path); } catch (Exception ex) { // Ignore (probably not a directory) } } private boolean isInsideNestedJar(String dir) { return dir.indexOf(&quot;!/&quot;) &amp;lt; dir.lastIndexOf(&quot;!/&quot;); } } â€‹ æ— è®ºé€»è¾‘æ€ä¹ˆå˜åŒ–,æœ€åç›‘å¬å™¨çš„ä»£ç éƒ½ä¼šèµ°åˆ°this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, &quot;/&quot;, url, path);è¿™å¥è¯æ¥. â€‹ çœ‹åˆ°ResourceSetType.RESOURCE_JARè¿™ä¸ªå¸¸é‡æ˜¯å¦æœ‰ç‚¹æ„Ÿè§‰å‘¢?æ²¡æ„Ÿè§‰å°±è„±æ‰è¡£æœå†çœ‹çœ‹. // StandardRoot public void createWebResourceSet(ResourceSetType type, String webAppMount, URL url, String internalPath) { BaseLocation baseLocation = new BaseLocation(url); createWebResourceSet(type, webAppMount, baseLocation.getBasePath(), baseLocation.getArchivePath(), internalPath); } @Override public void createWebResourceSet(ResourceSetType type, String webAppMount, String base, String archivePath, String internalPath) { List&amp;lt;WebResourceSet&amp;gt; resourceList; WebResourceSet resourceSet; switch (type) { case PRE: resourceList = preResources; break; case CLASSES_JAR: resourceList = classResources; break; case RESOURCE_JAR: resourceList = jarResources; break; case POST: resourceList = postResources; break; default: throw new IllegalArgumentException( sm.getString(&quot;standardRoot.createUnknownType&quot;, type)); } // çœç•¥ resourceList.add(resourceSet); } â€‹ æ˜¯ä¸æ˜¯è¿™ä¸€åˆ‡éƒ½å›­å›å»äº†ï¼Ÿæ˜¯ä¸æ˜¯æ„Ÿè§‰ç–‘æƒ‘éƒ½æ²¡äº†?å¦‚æœè¿˜æ˜¯ä¸è§£åœ¨å»çœ‹çœ‹èµ„æºè§£æçš„é‚£å—å„¿. ä¹ã€çœŸç›¸ â€‹ ä¸ºç”šä¹ˆæ˜¯404å‘¢?é‚£æ˜¯å› ä¸ºåœ¨StandardRooté‡Œé¢çš„resourceListä¸­ä¸å­˜åœ¨æŒ‡å®šçš„æ ¹è·¯å¾„,æ‰€ä»¥æ˜¯404.åˆè¦æœ‰å°ä¼™ä¼´è¦æ äº†,è¯´MATE-INFOç›®å½•ä¸‹é¢çš„éƒ½æ²¡é—®é¢˜. â€‹ æ˜¯,æ²¡é—®é¢˜.å› ä¸ºspringBootæŠŠè¿™ä¸ªè·¯å¾„åŠ è¿›å»äº†.ä¸ä¿¡ä½ çœ‹. // StaticResourceConfigurer private final class StaticResourceConfigurer implements LifecycleListener { private final Context context; private StaticResourceConfigurer(Context context) { this.context = context; } @Override public void lifecycleEvent(LifecycleEvent event) { if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) { addResourceJars(getUrlsOfJarsWithMetaInfResources()); } } private void addResourceJars(List&amp;lt;URL&amp;gt; resourceJarUrls) { // çœç•¥ } private void addResourceSet(String resource) { // çœç•¥ } private boolean isInsideNestedJar(String dir) { return dir.indexOf(&quot;!/&quot;) &amp;lt; dir.lastIndexOf(&quot;!/&quot;); } } â€‹ åœ¨getUrlsOfJarsWithMetaInfResourcesæ–¹æ³•é‡Œé¢å°±æœ‰è¿™ä¸ªè·¯å¾„.é€»è¾‘ç®€å•å°±ä¸è´´å‡ºæ¥äº†. 9.1 å¦‚ä½•è§£å†³404 â€‹ æ ¹æ®ä»¥ä¸Šçš„åˆ†æ,å¯ä»¥å’Œspringä¸€æ ·å¼„ä¸ªç›‘å¬å™¨,åœ¨resourceListæ·»åŠ æŒ‡å®šçš„è·¯å¾„.æœ€ç®€å•æš´åŠ›çš„æ–¹æ³•å¦‚ä¸‹: @Controller @EnableAutoConfiguration @Configuration public class Main { public static void main(String[] args) { SpringApplication.run(Main.class,args); } @RequestMapping(&quot;/test-static&quot;) public String testStatic(){ return &quot;index-static&quot;; } @RequestMapping(&quot;/test-public&quot;) public String testPublic(){ return &quot;index-public&quot;; } @RequestMapping(&quot;/test-resources&quot;) public String testResources(){ return &quot;index-resources&quot;; } @RequestMapping(&quot;/test-meta&quot;) public String testMeta(){ return &quot;index-meta&quot;; } @Bean public TomcatServletWebServerFactory getTomcatServletWebServerFactory(){ return new AdvTomcatServletWebServerFactory(); } } è‡ªå®šä¹‰å·¥å‚: public class AdvTomcatServletWebServerFactory extends TomcatServletWebServerFactory { private Context context; public AdvTomcatServletWebServerFactory(){ getContextLifecycleListeners().add(new AdvResourceListener()); } // è¿™ä¸ªæ–¹æ³•æ˜¯ springç•™ä¸‹çš„æ¨¡æ¿æ–¹æ³• // å¯ä»¥é€šè¿‡è¿™ä¸ªæ–¹æ³•è¿›è¡Œæ‰©å±• @Override protected void postProcessContext(Context context) { this.context = context; } private class AdvResourceListener implements LifecycleListener{ @Override public void lifecycleEvent(LifecycleEvent event) { if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) { final URL resource = AdvTomcatServletWebServerFactory.class.getClassLoader().getResource(&quot;.&quot;); final WebResourceRoot resources = AdvTomcatServletWebServerFactory.this.context.getResources(); resources.createWebResourceSet(WebResourceRoot.ResourceSetType.RESOURCE_JAR, &quot;/&quot;, resource, &quot;/static&quot;); resources.createWebResourceSet(WebResourceRoot.ResourceSetType.RESOURCE_JAR, &quot;/&quot;, resource, &quot;/public&quot;); resources.createWebResourceSet(WebResourceRoot.ResourceSetType.RESOURCE_JAR, &quot;/&quot;, resource, &quot;/resources&quot;); } } } } â€‹ é€šè¿‡è‡ªå·±çš„å·¥å‚æ›¿æ¢æ‰springçš„å·¥å‚,å®ç°æ³¨å†Œè‡ªå·±çš„ç›‘å¬å™¨,å½“ç„¶æ–¹æ³•è¿˜æœ‰å¾ˆå¤š,å¦‚æœä½ ç†Ÿæ‚‰tomcatçš„å¯åŠ¨æµç¨‹çš„è¯. åã€å°ç»“ â€‹ åœ¨springBootçš„æ‡’äººå¥—é¤ä¸‹,å‡ºç°é—®é¢˜å¾€å¾€ä¼šè®©äººé˜²ä¸èƒœé˜²å‘€,æ¯”å¦‚è¿™ä¸ª404,æ ¹æœ¬æ²¡æœ‰ä»»ä½•ä¿¡æ¯è¯´å“ªé‡Œæœ‰é—®é¢˜(é™¤éæ˜¯å¼€äº†debugæ—¥å¿—). â€‹ æœ¬æ¥å°±æƒ³è°¢è°¢è§£å†³æ–¹æ¡ˆçš„,ç»“æœå†™äº†è¿™ä¹ˆå¤š,åƒé¥­äº†.</summary></entry><entry><title type="html">[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-beanå±æ€§å¡«å……ä¸åˆå§‹åŒ–(ä¹)</title><link href="https://onew.me/spring/2020/03/04/debug-spring-9.html" rel="alternate" type="text/html" title="[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-beanå±æ€§å¡«å……ä¸åˆå§‹åŒ–(ä¹)" /><published>2020-03-04T17:20:25+08:00</published><updated>2020-03-04T17:20:25+08:00</updated><id>https://onew.me/spring/2020/03/04/debug-spring-9</id><content type="html" xml:base="https://onew.me/spring/2020/03/04/debug-spring-9.html"># ä¸€ã€å‰è¨€

â€‹	beanæ˜¯åˆ›å»ºå¥½äº†,ä½†è¿˜éœ€è¦ä¸€äº›å±æ€§å¡«å……,åˆå§‹åŒ–ç­‰æ“ä½œ.

```java
	// å±æ€§å¡«å……
	populateBean(beanName, mbd, instanceWrapper);
	// åˆå§‹åŒ–bean
	exposedObject = initializeBean(beanName, exposedObject, mbd);
```



# äºŒã€populateBean

```java
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
		// è·³è¿‡ null bean èµ‹å€¼
		if (bw == null) {
			if (mbd.hasPropertyValues()) {
				throw new BeanCreationException(
						mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);
			}
			else {
				// Skip property population phase for null instance.
				return;
			}
		}

		// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
		// state of the bean before properties are set. This can be used, for example,
		// to support styles of field injection.
		// åˆ¤æ–­æ˜¯å¦æ˜¯æ‹¥æœ‰InstantiationAwareBeanPostProcessor
		if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
			// éå†æ‰€æœ‰BeanPostProcessor
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				// é’ˆå¯¹InstantiationAwareBeanPostProcessor è¿›è¡Œè°ƒç”¨
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
						return;
					}
				}
			}
		}

		PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);

		// è·å–è‡ªåŠ¨æ³¨å…¥æ¨¡å¼
		int resolvedAutowireMode = mbd.getResolvedAutowireMode();
		// æ ¹æ®åç§° æˆ–è€… ç±»å‹ è‡ªåŠ¨æ³¨å…¥
		if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
			MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
			// Add property values based on autowire by name if applicable.
			// å¤„ç†æ ¹æ®åç§°æ³¨å…¥
			if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
				autowireByName(beanName, mbd, bw, newPvs);
			}
			// Add property values based on autowire by type if applicable.
			// å¤„ç†æ ¹æ®ç±»å‹æ³¨å…¥
			if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
				autowireByType(beanName, mbd, bw, newPvs);
			}
			pvs = newPvs;
		}

		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
		// æ˜¯å¦éœ€è¦ä¾èµ–æ£€æŸ¥
		boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

		PropertyDescriptor[] filteredPds = null;
		// BeanPostProcessor å¤„ç†
		if (hasInstAwareBpps) {
			if (pvs == null) {
				pvs = mbd.getPropertyValues();
			}
			// éå†æ‰€æœ‰çš„ BeanPostProcessor
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
					if (pvsToUse == null) {
						if (filteredPds == null) {
							filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
						}
						pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
						if (pvsToUse == null) {
							return;
						}
					}
					pvs = pvsToUse;
				}
			}
		}
		// ä¾èµ–æ£€æŸ¥
		if (needsDepCheck) {
			if (filteredPds == null) {
				filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
			}
			checkDependencies(beanName, mbd, filteredPds, pvs);
		}
		// å°†å±æ€§åº”ç”¨åˆ° bean ä¸­
		if (pvs != null) {
			applyPropertyValues(beanName, mbd, bw, pvs);
		}
	}
```

â€‹	å¯ä»¥çœ‹åˆ°`InstantiationAwareBeanPostProcessor`å¯¹è±¡çš„è°ƒç”¨æ—¶æœºåˆ†åˆ«æ˜¯åœ¨åˆ›å»ºå¯¹è±¡åè°ƒç”¨äº†`postProcessAfterInstantiation`æ–¹æ³•,åœ¨æ³¨å…¥å®Œäº†åè°ƒç”¨äº†`postProcessProperties`æ–¹æ³•,éšå³å¡«å……å±æ€§.



# ä¸‰ã€initializeBean

```java
protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
		if (System.getSecurityManager() != null) {
			AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
				invokeAwareMethods(beanName, bean);
				return null;
			}, getAccessControlContext());
		}
		else {
			// å¯¹å®ç°Awareæ¥å£çš„ç±»è¿›è¡Œæ³¨å…¥ä¾‹å¦‚BeanFactoryAwareç­‰æ¥å£
			invokeAwareMethods(beanName, bean);
		}

		Object wrappedBean = bean;
		if (mbd == null || !mbd.isSynthetic()) {
			// å‰ç½®å¤„ç†
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
		}

		try {
			// è°ƒç”¨ç”¨æˆ·çš„initæ–¹æ³•
			invokeInitMethods(beanName, wrappedBean, mbd);
		}
		catch (Throwable ex) {
			throw new BeanCreationException(
					(mbd != null ? mbd.getResourceDescription() : null),
					beanName, &quot;Invocation of init method failed&quot;, ex);
		}
		if (mbd == null || !mbd.isSynthetic()) {
			// åç½®å¤„ç†
			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
		}

		return wrappedBean;
	}
```

1. å¯¹å®ç°Awareæ¥å£çš„è¿›è¡Œæ³¨å…¥
2. è°ƒç”¨PostProcessorçš„å‰ç½®æ–¹æ³•`postProcessBeforeInitialization`
3. åˆå§‹åŒ–bean åˆå§‹åŒ–æ–¹æ³•
4. åˆå§‹åŒ–å®Œæ¯•åè°ƒç”¨PostProcessorsçš„åç½®æ–¹æ³•`postProcessAfterInitialization`



å•åˆ©çš„åˆ›å»ºæµç¨‹è®°å½•å®Œæ¯•,å…¶ä»–scopeçš„åˆ›å»ºæ–¹å¼éƒ½æ˜¯å¤§åŒå°å¼‚,ä¸å†é‡å¤è®°å½•.



# å››ã€å°ç»“

â€‹	åˆ›å»ºçš„è¿‡ç¨‹ç»ˆäºèµ°å®Œäº†:)</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">ä¸€ã€å‰è¨€ â€‹ beanæ˜¯åˆ›å»ºå¥½äº†,ä½†è¿˜éœ€è¦ä¸€äº›å±æ€§å¡«å……,åˆå§‹åŒ–ç­‰æ“ä½œ. // å±æ€§å¡«å…… populateBean(beanName, mbd, instanceWrapper); // åˆå§‹åŒ–bean exposedObject = initializeBean(beanName, exposedObject, mbd); äºŒã€populateBean protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) { // è·³è¿‡ null bean èµ‹å€¼ if (bw == null) { if (mbd.hasPropertyValues()) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;); } else { // Skip property population phase for null instance. return; } } // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the // state of the bean before properties are set. This can be used, for example, // to support styles of field injection. // åˆ¤æ–­æ˜¯å¦æ˜¯æ‹¥æœ‰InstantiationAwareBeanPostProcessor if (!mbd.isSynthetic() &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) { // éå†æ‰€æœ‰BeanPostProcessor for (BeanPostProcessor bp : getBeanPostProcessors()) { // é’ˆå¯¹InstantiationAwareBeanPostProcessor è¿›è¡Œè°ƒç”¨ if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { return; } } } } PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null); // è·å–è‡ªåŠ¨æ³¨å…¥æ¨¡å¼ int resolvedAutowireMode = mbd.getResolvedAutowireMode(); // æ ¹æ®åç§° æˆ–è€… ç±»å‹ è‡ªåŠ¨æ³¨å…¥ if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) { MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // Add property values based on autowire by name if applicable. // å¤„ç†æ ¹æ®åç§°æ³¨å…¥ if (resolvedAutowireMode == AUTOWIRE_BY_NAME) { autowireByName(beanName, mbd, bw, newPvs); } // Add property values based on autowire by type if applicable. // å¤„ç†æ ¹æ®ç±»å‹æ³¨å…¥ if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) { autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); // æ˜¯å¦éœ€è¦ä¾èµ–æ£€æŸ¥ boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE); PropertyDescriptor[] filteredPds = null; // BeanPostProcessor å¤„ç† if (hasInstAwareBpps) { if (pvs == null) { pvs = mbd.getPropertyValues(); } // éå†æ‰€æœ‰çš„ BeanPostProcessor for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { if (filteredPds == null) { filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { return; } } pvs = pvsToUse; } } } // ä¾èµ–æ£€æŸ¥ if (needsDepCheck) { if (filteredPds == null) { filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } checkDependencies(beanName, mbd, filteredPds, pvs); } // å°†å±æ€§åº”ç”¨åˆ° bean ä¸­ if (pvs != null) { applyPropertyValues(beanName, mbd, bw, pvs); } } â€‹ å¯ä»¥çœ‹åˆ°InstantiationAwareBeanPostProcessorå¯¹è±¡çš„è°ƒç”¨æ—¶æœºåˆ†åˆ«æ˜¯åœ¨åˆ›å»ºå¯¹è±¡åè°ƒç”¨äº†postProcessAfterInstantiationæ–¹æ³•,åœ¨æ³¨å…¥å®Œäº†åè°ƒç”¨äº†postProcessPropertiesæ–¹æ³•,éšå³å¡«å……å±æ€§. ä¸‰ã€initializeBean protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) { if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt; { invokeAwareMethods(beanName, bean); return null; }, getAccessControlContext()); } else { // å¯¹å®ç°Awareæ¥å£çš„ç±»è¿›è¡Œæ³¨å…¥ä¾‹å¦‚BeanFactoryAwareç­‰æ¥å£ invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { // å‰ç½®å¤„ç† wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } try { // è°ƒç”¨ç”¨æˆ·çš„initæ–¹æ³• invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); } if (mbd == null || !mbd.isSynthetic()) { // åç½®å¤„ç† wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean; } å¯¹å®ç°Awareæ¥å£çš„è¿›è¡Œæ³¨å…¥ è°ƒç”¨PostProcessorçš„å‰ç½®æ–¹æ³•postProcessBeforeInitialization åˆå§‹åŒ–bean åˆå§‹åŒ–æ–¹æ³• åˆå§‹åŒ–å®Œæ¯•åè°ƒç”¨PostProcessorsçš„åç½®æ–¹æ³•postProcessAfterInitialization å•åˆ©çš„åˆ›å»ºæµç¨‹è®°å½•å®Œæ¯•,å…¶ä»–scopeçš„åˆ›å»ºæ–¹å¼éƒ½æ˜¯å¤§åŒå°å¼‚,ä¸å†é‡å¤è®°å½•. å››ã€å°ç»“ â€‹ åˆ›å»ºçš„è¿‡ç¨‹ç»ˆäºèµ°å®Œäº†:)</summary></entry><entry><title type="html">[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-beançš„åˆ›å»º(å…«)</title><link href="https://onew.me/spring/2020/03/04/debug-spring-8.html" rel="alternate" type="text/html" title="[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-beançš„åˆ›å»º(å…«)" /><published>2020-03-04T16:20:25+08:00</published><updated>2020-03-04T16:20:25+08:00</updated><id>https://onew.me/spring/2020/03/04/debug-spring-8</id><content type="html" xml:base="https://onew.me/spring/2020/03/04/debug-spring-8.html"># ä¸€ã€å‰è¨€

â€‹	ç»è¿‡å‰é¢çš„ä¸€é¡¿æŠ˜è…¾,ç»ˆäºè¦åˆ°äº†æ‰¯å¼€é®ç¾å¸ƒçš„æ—¶å€™äº†.

```java
@Test
	public void testSpringLoadXml(){
    // A
		BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBean.xml&quot;));
    // B
		final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);
		final String testStr = testBean.getTestStr();
		System.out.println(testStr);
	}
```

â€‹	å‰é¢è®°å½•äº†Aè¿™ä¸ªè¿‡ç¨‹,æ•´ä¸ªè¿‡ç¨‹æ€»ç»“ä¸º:

1. åŠ è½½xmlæ–‡ä»¶
2. è§£æxmlæ–‡ä»¶
3. é€‰ç”¨åˆé€‚çš„handlerè§£ææ ‡ç­¾
4. åˆ›å»ºbeançš„å®šä¹‰
5. æ³¨å†Œbeanå®šä¹‰



â€‹	é‚£ä¹ˆåé¢Bè¿™ä¸€æ­¥å°±æ˜¯æ¯”è¾ƒé‡è¦çš„ä¸€æ­¥.



# äºŒã€åˆ†æ

â€‹	ä»`MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);`è¿™å¥ä»£ç å¼€å§‹å§,è¿›å»çœ‹çœ‹é‡Œé¢æ˜¯å•¥å¦–é­”é¬¼æ€ª.

```java
// AbstractBeanFactory
@Override
	public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException {
		return doGetBean(name, requiredType, null, false);
	}
	@SuppressWarnings(&quot;unchecked&quot;)
	protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,
			@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

		// æå– bean name,bean name å¯èƒ½ä¸æ˜¯å•çº¯çš„åç§°ä¹Ÿå¯èƒ½æ˜¯å·¥å‚çš„åç§°
		// ä¾‹å¦‚ &amp;bean å°±ä»£è¡¨ä»åç§°ä¸ºbeançš„å·¥å‚ä¸­è·å– bean
		final String beanName = transformedBeanName(name);
		Object bean;

		// Eagerly check singleton cache for manually registered singletons.
		// é€šè¿‡å•åˆ©å·¥å‚è·å– bean
		Object sharedInstance = getSingleton(beanName);
		if (sharedInstance != null &amp;&amp; args == null) {
			if (logger.isTraceEnabled()) {
				if (isSingletonCurrentlyInCreation(beanName)) {
					logger.trace(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName +
							&quot;' that is not fully initialized yet - a consequence of a circular reference&quot;);
				}
				else {
					logger.trace(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;);
				}
			}
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
		}

		else {
			// å¦‚æœä¸ºåŸå‹æ¨¡å¼,å­˜åœ¨å¾ªç¯ä¾èµ–åˆ™æŠ¥é”™
			// Fail if we're already creating this bean instance:
			// We're assumably within a circular reference.
			// å¦‚æœæ˜¯åŸå‹æ¨¡å¼åˆ™ä¸è§£å†³å¾ªç¯ä¾èµ–é—®é¢˜,ç›´æ¥æŠ›å‡ºå¼‚å¸¸
			if (isPrototypeCurrentlyInCreation(beanName)) {
				throw new BeanCurrentlyInCreationException(beanName);
			}
			// è·å–çˆ¶beanå·¥å‚
			// Check if bean definition exists in this factory.
			BeanFactory parentBeanFactory = getParentBeanFactory();
			// é€šè¿‡é€’å½’çˆ¶å·¥å‚è·å–beanå¯¹è±¡
			// å¦‚æœæ— beanå®šä¹‰å¹¶ä¸”è¿˜è¦åŠ è½½è¿™ä¸ªbean è¯´æ˜è¿™ä¸ªbeanå·²ç»è¢«åŠ è½½è¿‡äº†
			if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
				// Not found -&gt; check parent.
				String nameToLookup = originalBeanName(name);
				if (parentBeanFactory instanceof AbstractBeanFactory) {
					return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
							nameToLookup, requiredType, args, typeCheckOnly);
				}
				else if (args != null) {
					// Delegation to parent with explicit args.
					return (T) parentBeanFactory.getBean(nameToLookup, args);
				}
				else if (requiredType != null) {
					// No args -&gt; delegate to standard getBean method.
					return parentBeanFactory.getBean(nameToLookup, requiredType);
				}
				else {
					return (T) parentBeanFactory.getBean(nameToLookup);
				}
			}
			//è®°å½• bean æ­£åœ¨åˆ›å»ºä¸­
			if (!typeCheckOnly) {
				markBeanAsCreated(beanName);
			}

			try {
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
				checkMergedBeanDefinition(mbd, beanName, args);

				// Guarantee initialization of beans that the current bean depends on.
				String[] dependsOn = mbd.getDependsOn();
				if (dependsOn != null) {
					for (String dep : dependsOn) {
						if (isDependent(beanName, dep)) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									&quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
						}
						//ä¾èµ–æ³¨å†Œ
						registerDependentBean(dep, beanName);
						try {
							//è·å–bean,å¾ªç¯è·å–ä¾èµ–
							getBean(dep);
						}
						catch (NoSuchBeanDefinitionException ex) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									&quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
						}
					}
				}

				// åˆ›å»ºbeanå®ä¾‹
				// Create bean instance.
				// å•åˆ©æ¨¡å¼
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, () -&gt; {
						try {
							return createBean(beanName, mbd, args);
						}
						catch (BeansException ex) {
							// Explicitly remove instance from singleton cache: It might have been put there
							// eagerly by the creation process, to allow for circular reference resolution.
							// Also remove any beans that received a temporary reference to the bean.
							destroySingleton(beanName);
							throw ex;
						}
					});
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
				}
				// åŸå‹æ¨¡å¼
				else if (mbd.isPrototype()) {
					// It's a prototype -&gt; create a new instance.
					Object prototypeInstance = null;
					try {
						// å‰ç½®å¤„ç†
						beforePrototypeCreation(beanName);
						// åˆ›å»ºbean
						prototypeInstance = createBean(beanName, mbd, args);
					}
					finally {
						// åç½®å¤„ç†
						afterPrototypeCreation(beanName);
					}
					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
				}

				else {
					// å…¶ä»–ä½œç”¨åŸŸ
					String scopeName = mbd.getScope();
					final Scope scope = this.scopes.get(scopeName);
					if (scope == null) {
						throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;);
					}
					try {
						Object scopedInstance = scope.get(beanName, () -&gt; {
							// å‰ç½®å¤„ç†
							beforePrototypeCreation(beanName);
							try {
								// åˆ›å»º bean
								return createBean(beanName, mbd, args);
							}
							finally {
								// åç½®å¤„ç†
								afterPrototypeCreation(beanName);
							}
						});
						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
					}
					catch (IllegalStateException ex) {
						throw new BeanCreationException(beanName,
								&quot;Scope '&quot; + scopeName + &quot;' is not active for the current thread; consider &quot; +
								&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
								ex);
					}
				}
			}
			catch (BeansException ex) {
				cleanupAfterBeanCreationFailure(beanName);
				throw ex;
			}
		}

		//ç±»å‹è½¬æ¢
		// Check if required type matches the type of the actual bean instance.
		if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {
			try {
				T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
				if (convertedBean == null) {
					throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
				}
				return convertedBean;
			}
			catch (TypeMismatchException ex) {
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Failed to convert bean '&quot; + name + &quot;' to required type '&quot; +
							ClassUtils.getQualifiedName(requiredType) + &quot;'&quot;, ex);
				}
				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
			}
		}
		return (T) bean;
	}
```

â€‹	ä»£ç å¾ˆé•¿,çœ‹èµ·æ¥æ¯”è¾ƒè´¹åŠ².æ‹†åˆ†æ¥çœ‹çœ‹ã€‚

```java
// AbstractBeanFactory
// æå– bean name,bean name å¯èƒ½ä¸æ˜¯å•çº¯çš„åç§°ä¹Ÿå¯èƒ½æ˜¯å·¥å‚çš„åç§°
		// ä¾‹å¦‚ &amp;bean å°±ä»£è¡¨ä»åç§°ä¸ºbeançš„å·¥å‚ä¸­è·å– bean
final String beanName = transformedBeanName(name);
		Object bean;

		// Eagerly check singleton cache for manually registered singletons.
		// é€šè¿‡å•åˆ©å·¥å‚è·å– bean
		Object sharedInstance = getSingleton(beanName);
		if (sharedInstance != null &amp;&amp; args == null) {
			if (logger.isTraceEnabled()) {
				if (isSingletonCurrentlyInCreation(beanName)) {
					logger.trace(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName +
							&quot;' that is not fully initialized yet - a consequence of a circular reference&quot;);
				}
				else {
					logger.trace(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;);
				}
			}
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
		}

```

1. è·å–beançš„çœŸå®åç§°
2. è·å–bean



â€‹	è¿™éƒ¨åˆ†åˆ†æˆ3å¥ä»£ç 

1. `String beanName = transformedBeanName(name);`
2. `Object sharedInstance = getSingleton(beanName);`
3. `bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);`



## 2.1 transformedBeanName

```java
// AbstractBeanFactory
protected String transformedBeanName(String name) {
		return canonicalName(BeanFactoryUtils.transformedBeanName(name));
	}
// BeanFactoryUtils
public static String transformedBeanName(String name) {
		Assert.notNull(name, &quot;'name' must not be null&quot;);
		// åˆ¤æ–­æ˜¯å¦æ˜¯ä»¥&amp; å¼€å¤´çš„åç§°
		if (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {
			return name;
		}
		// åç§°-&gt;çœŸå®åç§° æ”¾å…¥æ¢æˆä¸­
		// ä¸åœçš„å¾ªç¯æˆªå–&amp;åé¢çš„éƒ¨åˆ†,ç›´åˆ°ä¸ä»¥&amp;å¼€å¤´ä¸ºæ­¢
		return transformedBeanNameCache.computeIfAbsent(name, beanName -&gt; {
			do {
				beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());
			}
			while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));
			return beanName;
		});
	}
// AbstractBeanFactory
public String canonicalName(String name) {
		String canonicalName = name;
		// Handle aliasing...
		String resolvedName;
		// åˆ¤æ–­beançš„åç§°æ˜¯å¦æ˜¯åˆ«å
		// ä¸€ç›´å¾ªç¯ è·Ÿç€åˆ«åçš„å¼•ç”¨é“¾èµ°
		// ç›´åˆ°éåˆ«åä¸ºæ­¢
		// ä¾‹å¦‚ A-B-C-D-E-F
		// ä»Aæ‰¾åˆ°F
		do {
			resolvedName = this.aliasMap.get(canonicalName);
			if (resolvedName != null) {
				canonicalName = resolvedName;
			}
		}
		while (resolvedName != null);
		return canonicalName;
	}

```

1. å…ˆåˆ¤æ–­æ˜¯å¦æ˜¯ä»¥&amp;å¼€å¤´,è¿™ä¸ªç¬¦å·ä»£è¡¨ç€å¼•ç”¨çš„æ„æ€,åœ¨c/c++é‡Œé¢ä¼°è®¡ä¼šå¾ˆç†Ÿæ‚‰.
2. åˆ¤æ–­æ˜¯å¦æ˜¯åˆ«å
3. è¿”å›æœ€ç»ˆç¡®å®šä¸‹æ¥çš„beanåç§°



## 2.2 &amp; ç¬¦å·çš„ä½œç”¨

```java

public class MyTestFactoryBean implements FactoryBean&lt;MyTestBean&gt; {
	@Override
	public MyTestBean getObject() throws Exception {
		return new MyTestBean();
	}

	@Override
	public Class&lt;?&gt; getObjectType() {
		return MyTestBean.class;
	}

	@Override
	public boolean isSingleton() {
		return true;
	}
}

```



```java
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                       https://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;
	&lt;bean id=&quot;myTestBeanFactory&quot; class=&quot;com.sjr.test.bean.MyTestFactoryBean&quot;/&gt;
&lt;/beans&gt;

```



```java

public class TestSpringFactoryBean {

	@Test
	public void testFactoryBean() {
		BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBeanFactory.xml&quot;));
		final Object bean = factory.getBean(&quot;myTestBeanFactory&quot;);
		System.out.println(bean.getClass().getName());
		final Object bean1 = factory.getBean(&quot;&amp;myTestBeanFactory&quot;);
		System.out.println(bean1.getClass().getName());
	}
}

```

æœ€åç»“æœè¾“å‡ºä¸º:

```properties
com.sjr.test.bean.MyTestBean
com.sjr.test.bean.MyTestFactoryBean
```

â€‹	ä»ç»“æœä¸Šæ¥åº”è¯¥ç§’æ‡‚å§,å¦‚æœä¸€`FactoryBean`å¯¹è±¡åœ¨springåˆ›å»ºçš„æ—¶å€™ä¼šåˆ¤æ–­beanåç§°,å¦‚æœbeanåç§°ä¸­ä¸å¸¦æœ‰&amp;ç¬¦å·,è¯´æ˜æ˜¯è¦è·å–`FactoryBean`æ‰€äº§ç”Ÿçš„å¯¹è±¡,å¦‚æœå¸¦æœ‰&amp;ç¬¦å·,åˆ™è¯´æ˜éœ€è¦è·å–`FactoryBean`å¯¹è±¡æœ¬èº«.

## 2.2 getSingleton

```java
// DefaultSingletonBeanRegistry
@Override
	@Nullable
	public Object getSingleton(String beanName) {
		return getSingleton(beanName, true);
	}

@Nullable
	protected Object getSingleton(String beanName, boolean allowEarlyReference) {
		// ç¼“å­˜ä¸­æ˜¯å¦æœ‰åˆ›å»ºå¥½çš„bean
		Object singletonObject = this.singletonObjects.get(beanName);
		// ç¼“å­˜ä¸­æ— æŒ‡å®šçš„beanå¹¶ä¸”è¯¥beanæœªåœ¨åˆ›å»ºä¸­
		if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
			// åŠ é” 
			synchronized (this.singletonObjects) {
				// æŒ‡å®šçš„beanæ˜¯å¦åœ¨åˆ›å»ºä¸­
				singletonObject = this.earlySingletonObjects.get(beanName);
				// éåˆ›å»ºä¸­,å¹¶ä¸”å…è®¸æå‰å¼•ç”¨
				if (singletonObject == null &amp;&amp; allowEarlyReference) {
					// è·å–å•åˆ©å·¥å‚
					ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
					if (singletonFactory != null) {
						// è°ƒç”¨å·¥å‚åˆ›å»ºå¯¹è±¡
						singletonObject = singletonFactory.getObject();
						// æŠŠåˆ›å»ºå¥½çš„å¯¹è±¡æ”¾å…¥åˆ°æ­£åœ¨åˆ›å»ºçš„é›†åˆä¸­å»
						this.earlySingletonObjects.put(beanName, singletonObject);
						// ç§»é™¤å•åˆ©å·¥å‚
						this.singletonFactories.remove(beanName);
					}
				}
			}
		}
		return singletonObject;
	}
```

â€‹	é€»è¾‘æ¯”è¾ƒç®€å•,è¿™é‡Œæœ‰å‡ ä¸ªmap æ¯”è¾ƒé‡è¦:

1. singletonObjects ç”¨äºä¿å­˜BeanNameå’Œåˆ›å»ºbeanå®ä¾‹ä¹‹é—´çš„å…³ç³» beanName-&gt;bean
2. earlySingletonObjects ç”¨äºä¿å­˜BeanNameå’Œåˆ›å»ºbeanå®ä¾‹ä¹‹é—´çš„å…³ç³» beanName-&gt;bean,ä¸åŒç‚¹æ˜¯,å½“beanæ”¾å…¥åˆ°æ­¤é›†åˆä¸­æ—¶,åœ¨beanåˆ›å»ºçš„è¿‡ç¨‹ä¸­å°±å¯ä»¥é€š è¿‡getBeanæ–¹æ³•æ¥è·å–beançš„å¼•ç”¨,ä¸»è¦æ˜¯ç”¨äºè§£å†³å¾ªç¯ä¾èµ–é—®é¢˜.
3. singletonFactories:ç”¨äºä¿å­˜beanNameä¸beanå·¥å‚ä¹‹é—´çš„å…³ç³»
4. registeredSingletons:ç”¨æ¥ä¿å­˜å½“å‰æ‰€æœ‰å·²æ³¨å†Œçš„bean



â€‹	å¦‚æœbeanåç§°æ˜¯å·¥å‚çš„åç§°,é‚£ä¹ˆè¿™é‡Œå·²ç»å®Œæˆäº†beançš„åˆ›å»ºäº†,ä½†ä»…ä»…æ˜¯åˆ›å»ºå®Œæˆè¿˜æ˜¯ä¸å¤Ÿ,springè¿˜è¦æ’ä¸Šä¸€è„šè¿›è¡Œç®¡ç†.



## 2.3 getObjectForBeanInstance

```java
protected Object getObjectForBeanInstance(
			Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {

		// Don't let calling code try to dereference the factory if the bean isn't a factory.
		// æ£€æŸ¥beanåç§°æ˜¯å¦ç¬¦åˆbeanå·¥å‚çš„å‘½åè§„èŒƒ,å¦‚æœåç§°æ˜¯å·¥å‚çš„æ ¼å¼,åˆ™è·å–çš„beanä¸ºå·¥å‚å®ä¾‹
		if (BeanFactoryUtils.isFactoryDereference(name)) {
			// ç¬¦åˆè§„èŒƒä½†æ˜¯ä¸ªnull
			if (beanInstance instanceof NullBean) {
				return beanInstance;
			}
			// ç¬¦åˆè§„èŒƒä½†ä¸æ˜¯factory,å¼‚å¸¸
			if (!(beanInstance instanceof FactoryBean)) {
				throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass());
			}
			// å¦‚æœbeanå®šä¹‰ä¸ä¸ºç©º,è®¾ç½®ä¸ºtrueè¡¨æ˜æ˜¯ä¸ªå·¥å‚bean
			if (mbd != null) {
				mbd.isFactoryBean = true;
			}
			return beanInstance;
		}

		// Now we have the bean instance, which may be a normal bean or a FactoryBean.
		// If it's a FactoryBean, we use it to create a bean instance, unless the
		// caller actually wants a reference to the factory.
		// å¦‚æœbeanå®ä¾‹ä¸ºéå·¥å‚,ç›´æ¥è¿”å›
		if (!(beanInstance instanceof FactoryBean)) {
			return beanInstance;
		}

		// åé¢çš„é€»è¾‘æ˜¯beanæ˜¯å·¥å‚,è€Œåç§°åˆ™ä¸æ˜¯å·¥å‚çš„è§£å¼•ç”¨æ ¼å¼
		Object object = null;
		if (mbd != null) {
			mbd.isFactoryBean = true;
		}
		else {
			// ä»ç¼“å­˜ä¸­è·å–å¯¹è±¡å¯¹åº”çš„å·¥å‚bean
			object = getCachedObjectForFactoryBean(beanName);
		}
		if (object == null) {
			// Return bean instance from factory.
			FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;
			// Caches object obtained from FactoryBean if it is a singleton.
			if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) {
				mbd = getMergedLocalBeanDefinition(beanName);
			}
			boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());
			object = getObjectFromFactoryBean(factory, beanName, !synthetic);
		}
		return object;
	}
```

1. å¦‚æœbeançš„åç§°ä»¥&amp; å¼€å¤´å¹¶ä¸”æ˜¯`FactoryBean`å­ç±»,ç›´æ¥è¿”å›å·¥å‚å¯¹è±¡
2. å¦‚æœbeançš„åç§°éä»¥&amp;å¼€å¤´å¹¶ä¸”é`FactoryBean`å­ç±»ç›´æ¥è¿”å›å¯¹è±¡
3. å¦‚æœbeançš„åç§°éä»¥&amp;å¼€å¤´å¹¶ä¸”æ˜¯`FactoryBean`å­ç±»è°ƒç”¨`FactoryBean`çš„getObjectæ–¹æ³•è·å–å¯¹è±¡



ä»¥ä¸Šä»£ç ä¸­çš„æ ¸å¿ƒä»£ç æœ‰ä¸‰å¤„:

1. getCachedObjectForFactoryBean()
2. getMergedLocalBeanDefinition()
3. getObjectFromFactoryBean()



## 2.4 getCachedObjectForFactoryBean

```java
@Nullable
	protected Object getCachedObjectForFactoryBean(String beanName) {
		return this.factoryBeanObjectCache.get(beanName);
	}
```

â€‹	ä»£ç å¾ˆç®€å•,å°±æ˜¯æ ¹æ®beanNameåœ¨æ¢æˆä¸­è·å–å¯¹åº”çš„bean

## 2.5 getMergedLocalBeanDefinition

```java
// AbstractBeanFactory
protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException {
		// Quick check on the concurrent map first, with minimal locking.
		// ä»ç¼“å­˜ä¸­è·å–
		RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName);
		if (mbd != null &amp;&amp; !mbd.stale) {
			return mbd;
		}
		return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));
	}
protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd)
			throws BeanDefinitionStoreException {

		return getMergedBeanDefinition(beanName, bd, null);
	}

protected RootBeanDefinition getMergedBeanDefinition(
			String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)
			throws BeanDefinitionStoreException {
		// åŠ é”,å¹¶å‘æ§åˆ¶
		synchronized (this.mergedBeanDefinitions) {
			RootBeanDefinition mbd = null;
			RootBeanDefinition previous = null;

			// Check with full lock now in order to enforce the same merged instance.
			if (containingBd == null) {
				// å¦‚æœä¸ºç©º ä»ç¼“å­˜ä¸­è·å–
				mbd = this.mergedBeanDefinitions.get(beanName);
			}
			
			
			if (mbd == null || mbd.stale) {
				previous = mbd;
				// åˆ¤æ–­æ˜¯å¦å…·æœ‰çˆ¶å­å…³ç³»
				if (bd.getParentName() == null) {
					// Use copy of given root bean definition.
					// åˆ¤æ–­ç±»å‹æ˜¯å¦æ˜¯ RootBeanDefinition
					if (bd instanceof RootBeanDefinition) {
						// copyä¸€ä¸ª
						mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();
					}
					else {
						// è½¬æ¢ä¸º RootBeanDefinition
						mbd = new RootBeanDefinition(bd);
					}
				}
				else {
					// Child bean definition: needs to be merged with parent.
					BeanDefinition pbd;
					try {
						// è·å– çˆ¶bean åç§°
						String parentBeanName = transformedBeanName(bd.getParentName());
						// åˆ¤æ–­çˆ¶ä¸å­çš„bean åç§°æ˜¯å¦ç›¸åŒ
						if (!beanName.equals(parentBeanName)) {
							// å¦‚æœä¸ç›¸åŒ,åˆ™é¡ºåˆ™ çˆ¶å­å…³ç³» ä¸€è·¯é€’å½’ä¸Šå»
							// å…¨éƒ¨è½¬æ¢ä¸º RootBeanDefinition
							pbd = getMergedBeanDefinition(parentBeanName);
						}
						else {
							// å’Œä¸Šé¢ä»£ç é€»è¾‘ç›¸åŒ åªæ˜¯ç±»å‹ä¸ä¸€æ ·
							BeanFactory parent = getParentBeanFactory();
							if (parent instanceof ConfigurableBeanFactory) {
								pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);
							}
							else {
								throw new NoSuchBeanDefinitionException(parentBeanName,
										&quot;Parent name '&quot; + parentBeanName + &quot;' is equal to bean name '&quot; + beanName +
										&quot;': cannot be resolved without an AbstractBeanFactory parent&quot;);
							}
						}
					}
					catch (NoSuchBeanDefinitionException ex) {
						throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName,
								&quot;Could not resolve parent bean definition '&quot; + bd.getParentName() + &quot;'&quot;, ex);
					}
					// Deep copy with overridden values.
					// æ·±æ‹·è´ è½¬æ¢ä¸ºRootBeanDefinition
					mbd = new RootBeanDefinition(pbd);
					mbd.overrideFrom(bd);
				}

				// Set default singleton scope, if not configured before.
				if (!StringUtils.hasLength(mbd.getScope())) {
					mbd.setScope(SCOPE_SINGLETON);
				}

				// A bean contained in a non-singleton bean cannot be a singleton itself.
				// Let's correct this on the fly here, since this might be the result of
				// parent-child merging for the outer bean, in which case the original inner bean
				// definition will not have inherited the merged outer bean's singleton status.
				if (containingBd != null &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) {
					mbd.setScope(containingBd.getScope());
				}

				// Cache the merged bean definition for the time being
				// (it might still get re-merged later on in order to pick up metadata changes)
				if (containingBd == null &amp;&amp; isCacheBeanMetadata()) {
					// åŠ å…¥ç¼“å­˜
					this.mergedBeanDefinitions.put(beanName, mbd);
				}
			}
			if (previous != null) {
				copyRelevantMergedBeanDefinitionCaches(previous, mbd);
			}
			return mbd;
		}
	}

```

â€‹	è¯´è¿™ä»£ç ä¹‹å‰,å…ˆè¯´è¯´springä¸­çš„åŸºæœ¬æ•°æ®ç»“æ„.åœ¨springä¸­åŸºæœ¬æ•°æ®ç»“æ„ä¸º`BeanDefinition`,é€šè¿‡springäº§ç”Ÿçš„æ™®é€šbeanä¸º`GenericBeanDefinition`.è€Œspringåç»­å¤„ç†çš„ç±»å‹åˆ™ä¸º`RootBeanDefinition`.å…³ç³»å›¾å¦‚ä¸‹:

![images](https://gitee.com/oneww/onew_image/raw/master/BeanDefinition.png)

â€‹	è¿™ä¸¤ä¸ªé•¿çš„éƒ½å·®ä¸å¤š,åªä¸è¿‡åç»­å¤„ç†çš„æ­¥éª¤ç”¨åˆ°çš„ç±»å‹ä¸º`RootBeanDefinition`,æ‰€ä»¥åœ¨ä¸Šé¢çš„æ–¹æ³•ä¸­,è¿›è¡Œé€’å½’è½¬æ¢.

## 2.6 getObjectFromFactoryBean

```java
// AbstractBeanFactory
boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());
object = getObjectFromFactoryBean(factory, beanName, !synthetic);
```

â€‹	è¿™é‡Œè¿™ä¸ª`isSynthetic`æ–¹æ³•ä»£è¡¨æ˜¯å¦æ˜¯äººé€ çš„,emmaå°±è¿™æ ·ç†è§£å§.ä»€ä¹ˆå«åšäººé€ çš„å‘¢?æ„æ€å°±æ˜¯ä¸åŠ å¹²é¢„é€šspringäº§ç”Ÿçš„å°±æ˜¯éäººé€ çš„,å¦‚æœæ˜¯åé¢é€šè¿‡ä»£ç†äº§ç”Ÿçš„å°±æ˜¯éäººé€ çš„.

â€‹	çœ‹äº†ä¸€ä¸‹setSyntheticè¿™ä¸ªæ–¹æ³•çš„è°ƒç”¨æƒ…å†µ,éƒ½æ˜¯åœ¨aopé‚£è¾¹è°ƒç”¨çš„æ¯”è¾ƒå¤š.ä¸çŸ¥é“è§£é‡Šçš„å¯¹ä¸å¯¹å“ˆ.

```java
// FactoryBeanRegistrySupport
protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) {
		// åˆ¤æ–­å·¥å‚æ˜¯å¦ä¸ºå•åˆ©å·¥å‚,å¹¶ä¸”å•åˆ©å¯¹è±¡å·²è¢«åˆ›å»ºå®Œæˆ
		if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) {
			// åŠ é”
			synchronized (getSingletonMutex()) {
				// åœ¨ç¼“å­˜ä¸­è·å–é€šè¿‡å·¥å‚åˆ›å»ºçš„bean
				Object object = this.factoryBeanObjectCache.get(beanName);
				if (object == null) {
					// è·å–beané€šè¿‡å·¥å‚
					object = doGetObjectFromFactoryBean(factory, beanName);
					// Only post-process and store if not put there already during getObject() call above
					// (e.g. because of circular reference processing triggered by custom getBean calls)
					// å†æ¬¡ä»ç¼“å­˜ä¸­è·å–bean
					Object alreadyThere = this.factoryBeanObjectCache.get(beanName);
					if (alreadyThere != null) {
						// å¦‚æœç¼“å­˜ä¸­è·å–åˆ°bean,åˆ™ä¸¢å¼ƒå½“å‰åˆ›å»ºçš„å¯¹è±¡
						object = alreadyThere;
					}
					else {
						// åˆ¤æ–­æ˜¯å¦éœ€è¦post-processing
						if (shouldPostProcess) {
							// å½“å‰çš„beanæ˜¯å¦è¢«åˆ›å»ºä¸­,å¦‚æœæ˜¯å°±ç›´æ¥è¿”å›å½“å‰çš„beanä¸åšå¤„ç†
							if (isSingletonCurrentlyInCreation(beanName)) {
								// Temporarily return non-post-processed object, not storing it yet..
								return object;
							}
							// beanåˆ›å»ºä¹‹å‰,æŠŠå½“å‰beanåŠ å…¥æ­£åœ¨åˆ›å»ºä¸­çš„é›†åˆä¸­å»
							beforeSingletonCreation(beanName);
							try {
								// AOPçš„æ ¸å¿ƒæ­¥éª¤
								object = postProcessObjectFromFactoryBean(object, beanName);
							}
							catch (Throwable ex) {
								throw new BeanCreationException(beanName,
										&quot;Post-processing of FactoryBean's singleton object failed&quot;, ex);
							}
							finally {
								// beanåˆ›å»ºä¹‹å,æŠŠbeanä»æ­£åœ¨åˆ›å»ºä¸­çš„é›†åˆä¸­ç§»é™¤
								afterSingletonCreation(beanName);
							}
						}
						if (containsSingleton(beanName)) {
							// ç¼“å­˜beanå¯¹è±¡
							this.factoryBeanObjectCache.put(beanName, object);
						}
					}
				}
				return object;
			}
		}
		else {
			//åˆ›å»ºå¯¹è±¡
			Object object = doGetObjectFromFactoryBean(factory, beanName);
			if (shouldPostProcess) {
				try {
					//å¤„ç†beanæµç¨‹
					object = postProcessObjectFromFactoryBean(object, beanName);
				}
				catch (Throwable ex) {
					throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean's object failed&quot;, ex);
				}
			}
			return object;
		}
	}
```

1. åˆ¤æ–­æ˜¯å¦æ˜¯å•åˆ©å·¥å‚,å¹¶ä¸”ç¼“å­˜ä¸­å·²ç»åˆ›å»ºäº†è¯¥beançš„factoryBean
2. åˆ¤æ–­factoryBeanObjectCacheç¼“å­˜ä¸­beanæ˜¯å¦å­˜åœ¨
3. é€šè¿‡factoryBeanåˆ›å»ºbean



â€‹	ä»¥ä¸Šé€»è¾‘ä¸ºå½“æœ‰factoryBeançš„é€»è¾‘.

# ä¸‰ã€ååŠæ®µé€»è¾‘

```java
//AbstractBeanFactory
			// å¦‚æœä¸ºåŸå‹æ¨¡å¼,å­˜åœ¨å¾ªç¯ä¾èµ–åˆ™æŠ¥é”™
			// Fail if we're already creating this bean instance:
			// We're assumably within a circular reference.
			// å¦‚æœæ˜¯åŸå‹æ¨¡å¼åˆ™ä¸è§£å†³å¾ªç¯ä¾èµ–é—®é¢˜,ç›´æ¥æŠ›å‡ºå¼‚å¸¸
			if (isPrototypeCurrentlyInCreation(beanName)) {
				throw new BeanCurrentlyInCreationException(beanName);
			}
			// è·å–çˆ¶beanå·¥å‚
			// Check if bean definition exists in this factory.
			BeanFactory parentBeanFactory = getParentBeanFactory();
			// é€šè¿‡é€’å½’çˆ¶å·¥å‚è·å–beanå¯¹è±¡
			// å¦‚æœæ— beanå®šä¹‰å¹¶ä¸”è¿˜è¦åŠ è½½è¿™ä¸ªbean è¯´æ˜è¿™ä¸ªbeanå·²ç»è¢«åŠ è½½è¿‡äº†
			if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
				// Not found -&gt; check parent.
				String nameToLookup = originalBeanName(name);
				if (parentBeanFactory instanceof AbstractBeanFactory) {
					return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
							nameToLookup, requiredType, args, typeCheckOnly);
				}
				else if (args != null) {
					// Delegation to parent with explicit args.
					return (T) parentBeanFactory.getBean(nameToLookup, args);
				}
				else if (requiredType != null) {
					// No args -&gt; delegate to standard getBean method.
					return parentBeanFactory.getBean(nameToLookup, requiredType);
				}
				else {
					return (T) parentBeanFactory.getBean(nameToLookup);
				}
			}
```

â€‹	å¦‚æœéå•åˆ©æ¨¡å¼,springåœ¨è¿™é‡Œä¸å¤„ç†å¾ªç¯ä¾èµ–é—®é¢˜.å¦‚æœ`BeanFactory`å­˜åœ¨çˆ¶å­å…³ç³»,åˆ™è¿›è¡Œé€’å½’åˆ›å»º.

```java
// AbstractBeanFactory
// è®°å½• bean æ­£åœ¨åˆ›å»ºä¸­
			if (!typeCheckOnly) {
				markBeanAsCreated(beanName);
			}
// è½¬æ¢BeanDefinitionä¸ºRootBeanDefinition
final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
			// æ£€æŸ¥RootBeanDefinitionæ˜¯å¦åˆæ³•
				checkMergedBeanDefinition(mbd, beanName, args);

				// Guarantee initialization of beans that the current bean depends on.
				// éå†æ‰€æœ‰ä¾èµ–,å¹¶è¿›è¡Œæ³¨å†Œã€åˆ›å»ºç­‰è¿‡ç¨‹
				String[] dependsOn = mbd.getDependsOn();
				if (dependsOn != null) {
					for (String dep : dependsOn) {
						if (isDependent(beanName, dep)) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									&quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
						}
						// ä¾èµ–æ³¨å†Œ
						registerDependentBean(dep, beanName);
						try {
							// è·å–bean,å¾ªç¯è·å–ä¾èµ–
							getBean(dep);
						}
						catch (NoSuchBeanDefinitionException ex) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									&quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
						}
					}
				}

				// åˆ›å»ºbeanå®ä¾‹
				// Create bean instance.
				// å•åˆ©æ¨¡å¼
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, () -&gt; {
						try {
							return createBean(beanName, mbd, args);
						}
						catch (BeansException ex) {
							// Explicitly remove instance from singleton cache: It might have been put there
							// eagerly by the creation process, to allow for circular reference resolution.
							// Also remove any beans that received a temporary reference to the bean.
							destroySingleton(beanName);
							throw ex;
						}
					});
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
				}			
```

1. æ ‡è®°è¯¥beanæœªæ­£åœ¨åˆ›å»ºä¸­.

   ```java
   // AbstractBeanFactory
   protected void markBeanAsCreated(String beanName) {
   		// åˆ¤æ–­æ˜¯å¦åŒ…å«beanName
   		if (!this.alreadyCreated.contains(beanName)) {
   			// åŠ é”å¹¶å‘æ§åˆ¶
   			synchronized (this.mergedBeanDefinitions) {
   				// åŒé‡æ£€æŸ¥
   				if (!this.alreadyCreated.contains(beanName)) {
   					// Let the bean definition get re-merged now that we're actually creating
   					// the bean... just in case some of its metadata changed in the meantime.
   					clearMergedBeanDefinition(beanName);
   					// æ·»åŠ è¿›è¡Œå·²ç»åˆ›å»ºé›†åˆä¸­
   					this.alreadyCreated.add(beanName);
   				}
   			}
   		}
   	}
   ```

2. éå†ä¾èµ–å¹¶è¿›è¡Œé€’å½’åˆ›å»º

   ```java
   // AbstractBeanFactory
   			if (dependsOn != null) {
   					for (String dep : dependsOn) {
   						if (isDependent(beanName, dep)) {
   							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
   									&quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
   						}
   						//ä¾èµ–æ³¨å†Œ
   						registerDependentBean(dep, beanName);
   						try {
   							//è·å–bean,å¾ªç¯è·å–ä¾èµ–
   							getBean(dep);
   						}
   						catch (NoSuchBeanDefinitionException ex) {
   							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
   									&quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
   						}
   					}
   				}
   ```



â€‹	è¿™é‡Œçš„æ ¸å¿ƒé€»è¾‘åœ¨äº`getSingleton`è¿™ä¸ªæ–¹æ³•é‡Œ



### 3.1 getSingleton

```java
// AbstractBeanFactory
public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
		Assert.notNull(beanName, &quot;Bean name must not be null&quot;);
		// åŠ é”
		synchronized (this.singletonObjects) {
			// ä»ç¼“å­˜ä¸­è·å– bean
			Object singletonObject = this.singletonObjects.get(beanName);
			// å¦‚æœç¼“å­˜ä¸­æ²¡æœ‰
			if (singletonObject == null) {
        // åˆ¤æ–­å½“å‰beanæ˜¯å¦è¢«æ ‡è®°ä¸ºé”€æ¯
        // ç›¸å½“äºä¸èƒ½åœ¨destroryæ–¹æ³•é‡Œé¢å†å»åˆ›å»ºè¿™ä¸ªbean
				if (this.singletonsCurrentlyInDestruction) {
					throw new BeanCreationNotAllowedException(beanName,
							&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +
							&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);
				}
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Creating shared instance of singleton bean '&quot; + beanName + &quot;'&quot;);
				}
				// å¼€å§‹åˆ›å»º bean
				// æ·»åŠ åˆ° åˆ›å»ºä¸­é›†åˆä¸­å»
				// å‰ç½®å¤„ç†
				beforeSingletonCreation(beanName);
				boolean newSingleton = false;
				boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
				if (recordSuppressedExceptions) {
					this.suppressedExceptions = new LinkedHashSet&lt;&gt;();
				}
				try {
					// ä»å·¥å‚ä¸­è·å– bean
					singletonObject = singletonFactory.getObject();
					newSingleton = true;
				}
				catch (IllegalStateException ex) {
					// Has the singleton object implicitly appeared in the meantime -&gt;
					// if yes, proceed with it since the exception indicates that state.
					singletonObject = this.singletonObjects.get(beanName);
					if (singletonObject == null) {
						throw ex;
					}
				}
				catch (BeanCreationException ex) {
					if (recordSuppressedExceptions) {
						for (Exception suppressedException : this.suppressedExceptions) {
							ex.addRelatedCause(suppressedException);
						}
					}
					throw ex;
				}
				finally {
					if (recordSuppressedExceptions) {
						this.suppressedExceptions = null;
					}
					// ç§»é™¤åˆ›å»ºä¸­çš„é›†åˆ
					afterSingletonCreation(beanName);
				}
				if (newSingleton) {
					// æ”¾å…¥ç¼“å­˜
					addSingleton(beanName, singletonObject);
				}
			}
			return singletonObject;
		}
	}
```

1. ä»ç¼“å­˜ä¸­è·å–bean
2. å¦‚æœæ¢æˆä¸­æ²¡æœ‰,åˆ™åˆ¤æ–­å½“å‰çš„beanæ˜¯å¦è¢«è®°è¢«é”€æ¯
3. åœ¨åˆ›å»ºä¹‹å‰æŠŠbeanNameåŠ å…¥æ­£åœ¨åˆ›å»ºçš„ç¼“å­˜ä¸­å»
4. ä»å•åˆ©å·¥å‚ä¸­åˆ›å»ºbean
5. ä»æ­£åœ¨åˆ›å»ºçš„æ¢æˆä¸­ç§»é™¤beanName
6. æŠŠåˆ›å»ºå¥½çš„singletonObjectåŠ å…¥ç¼“å­˜ä¸­



å€¼å¾—æ³¨æ„çš„æ˜¯è¿™é‡Œçš„`singletonFactory`å¯¹è±¡æ˜¯é€šè¿‡Lambdaè¡¨è¾¾ä¼ å…¥è¿›æ¥çš„

```java
// AbstractBeanFactory
sharedInstance = getSingleton(beanName, () -&gt; {
						try {
							return createBean(beanName, mbd, args);
						}
						catch (BeansException ex) {
							// Explicitly remove instance from singleton cache: It might have been put there
							// eagerly by the creation process, to allow for circular reference resolution.
							// Also remove any beans that received a temporary reference to the bean.
							destroySingleton(beanName);
							throw ex;
						}
					});
```

è¿™é‡Œçš„æ ¸å¿ƒé€»è¾‘ä»£ç æ˜¯`createBean(beanName, mbd, args)`



### 3.2 createBean

```java
// AbstractAutowireCapableBeanFactory
@Override
	protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
			throws BeanCreationException {

		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Creating instance of bean '&quot; + beanName + &quot;'&quot;);
		}
		RootBeanDefinition mbdToUse = mbd;

		// Make sure bean class is actually resolved at this point, and
		// clone the bean definition in case of a dynamically resolved Class
		// which cannot be stored in the shared merged bean definition.
		// æ ¹æ®ç±»ååŠ è½½classå¯¹è±¡
		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
		if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {
			mbdToUse = new RootBeanDefinition(mbd);
			mbdToUse.setBeanClass(resolvedClass);
		}

		// Prepare method overrides.
		try {
			// åŒ¹é…éœ€è¦è¦†ç›–çš„æ–¹æ³•
			mbdToUse.prepareMethodOverrides();
		}
		catch (BeanDefinitionValidationException ex) {
			throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
					beanName, &quot;Validation of method overrides failed&quot;, ex);
		}

		try {
			// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
			// è¿”å›ä¸€ä¸ªä»£ç†å¯¹è±¡,ä¹Ÿå¯èƒ½æ˜¯éä»£ç†å¯¹è±¡
			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
			if (bean != null) {
				return bean;
			}
		}
		catch (Throwable ex) {
			throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
					&quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);
		}

		try {
			// åˆ›å»ºbean
			Object beanInstance = doCreateBean(beanName, mbdToUse, args);
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;);
			}
			return beanInstance;
		}
		catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
			// A previously detected exception with proper bean creation context already,
			// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.
			throw ex;
		}
		catch (Throwable ex) {
			throw new BeanCreationException(
					mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);
		}
	}
```

1. åŠ è½½class
2. åˆ¤æ–­è¯¥beanæ˜¯å¦éœ€è¦`InstantiationAwareBeanPostProcessor`è¿›è¡Œå¤„ç†,è¿™ä¸ªæ¥å£ä¸`BeanPostProcessor`ä¸åŒ,ä¸»è¦åŒºåˆ«æ˜¯åœ¨è°ƒç”¨æ—¶æœºä¸Šçš„åŒºåˆ«,`InstantiationAwareBeanPostProcessor`ä¼šåœ¨å¯¹è±¡åˆ›å»ºå‰è¿›è¡Œè°ƒç”¨,è€Œ`BeanPostProcessor`ä¼šåœ¨å¯¹è±¡åˆå§‹åŒ–å‰åè¿›è¡Œè°ƒç”¨,è¿™ä¸ªå¯ä»¥ä»doCreateBeançœ‹å‡ºæ—¶æœºçš„å·®åˆ«.
3. åˆ›å»ºå¯¹è±¡



### 3.3 doCreateBean

```java
// AbstractAutowireCapableBeanFactory
protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
			throws BeanCreationException {

		// Instantiate the bean.
		BeanWrapper instanceWrapper = null;
		if (mbd.isSingleton()) {
			// ä»ç¼“å­˜ä¸­è·å–å®ä¾‹wrapper,å¹¶ç§»é™¤å®ƒ
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
		}
		// å¦‚æœæ²¡æœ‰è·å–åˆ°å®ä¾‹çš„wrapper,åˆ™åˆ›å»ºä¸€ä¸ªå®ä¾‹
		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
		}
		final Object bean = instanceWrapper.getWrappedInstance();
		Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
		if (beanType != NullBean.class) {
			mbd.resolvedTargetType = beanType;
		}

		// Allow post-processors to modify the merged bean definition.
		// åˆ¤æ–­æ˜¯å¦æœ‰ åç½®å¤„ç†å™¨
		// åŠ é”
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				try {
					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
				}
				catch (Throwable ex) {
					throw new BeanCreationException(mbd.getResourceDescription(), beanName,
							&quot;Post-processing of merged bean definition failed&quot;, ex);
				}
				mbd.postProcessed = true;
			}
		}

		// æ˜¯å¦å…è®¸å¾ªç¯å¼•ç”¨
		// Eagerly cache singletons to be able to resolve circular references
		// even when triggered by lifecycle interfaces like BeanFactoryAware.
		boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;Eagerly caching bean '&quot; + beanName +
						&quot;' to allow for resolving potential circular references&quot;);
			}
			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
		}

		// Initialize the bean instance.
		Object exposedObject = bean;
		try {
			// å¡«å……beanå±æ€§
			populateBean(beanName, mbd, instanceWrapper);
			// åˆå§‹åŒ–bean
			exposedObject = initializeBean(beanName, exposedObject, mbd);
		}
		catch (Throwable ex) {
			if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
				throw (BeanCreationException) ex;
			}
			else {
				throw new BeanCreationException(
						mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
			}
		}
		// å¾ªç¯ä¾èµ–å¤„ç†
		if (earlySingletonExposure) {
			// è·å–å•åˆ©å¯¹è±¡
			Object earlySingletonReference = getSingleton(beanName, false);
			if (earlySingletonReference != null) {
				if (exposedObject == bean) {
					exposedObject = earlySingletonReference;
				}
				else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
					String[] dependentBeans = getDependentBeans(beanName);
					Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
					for (String dependentBean : dependentBeans) {
						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
							actualDependentBeans.add(dependentBean);
						}
					}
					if (!actualDependentBeans.isEmpty()) {
						throw new BeanCurrentlyInCreationException(beanName,
								&quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; +
								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
								&quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
								&quot;wrapped. This means that said other beans do not use the final version of the &quot; +
								&quot;bean. This is often the result of over-eager type matching - consider using &quot; +
								&quot;'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.&quot;);
					}
				}
			}
		}

		// Register bean as disposable.
		try {
			// æ³¨å†Œé”€æ¯å¤„ç†å™¨
			registerDisposableBeanIfNecessary(beanName, bean, mbd);
		}
		catch (BeanDefinitionValidationException ex) {
			throw new BeanCreationException(
					mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
		}

		return exposedObject;
	}
```

â€‹	è¿›è¿‡ä»¥ä¸Šéªšæ“ä½œå°±å®Œæˆäº†beançš„åˆ›å»º,åœ¨åˆ›å»ºçš„è¿‡ç¨‹ä¸­è¿˜ä¼šæœ‰å±æ€§çš„å¡«å……,beançš„åˆå§‹åŒ–ç­‰.



# å››ã€å°ç»“

â€‹	ç»§ç»­beançš„åˆå§‹åŒ–,ä¸å±æ€§çš„å¡«å…….</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">ä¸€ã€å‰è¨€ â€‹ ç»è¿‡å‰é¢çš„ä¸€é¡¿æŠ˜è…¾,ç»ˆäºè¦åˆ°äº†æ‰¯å¼€é®ç¾å¸ƒçš„æ—¶å€™äº†. @Test public void testSpringLoadXml(){ // A BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBean.xml&quot;)); // B final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class); final String testStr = testBean.getTestStr(); System.out.println(testStr); } â€‹ å‰é¢è®°å½•äº†Aè¿™ä¸ªè¿‡ç¨‹,æ•´ä¸ªè¿‡ç¨‹æ€»ç»“ä¸º: åŠ è½½xmlæ–‡ä»¶ è§£æxmlæ–‡ä»¶ é€‰ç”¨åˆé€‚çš„handlerè§£ææ ‡ç­¾ åˆ›å»ºbeançš„å®šä¹‰ æ³¨å†Œbeanå®šä¹‰ â€‹ é‚£ä¹ˆåé¢Bè¿™ä¸€æ­¥å°±æ˜¯æ¯”è¾ƒé‡è¦çš„ä¸€æ­¥. äºŒã€åˆ†æ â€‹ ä»MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);è¿™å¥ä»£ç å¼€å§‹å§,è¿›å»çœ‹çœ‹é‡Œé¢æ˜¯å•¥å¦–é­”é¬¼æ€ª. // AbstractBeanFactory @Override public &amp;lt;T&amp;gt; T getBean(String name, Class&amp;lt;T&amp;gt; requiredType) throws BeansException { return doGetBean(name, requiredType, null, false); } @SuppressWarnings(&quot;unchecked&quot;) protected &amp;lt;T&amp;gt; T doGetBean(final String name, @Nullable final Class&amp;lt;T&amp;gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { // æå– bean name,bean name å¯èƒ½ä¸æ˜¯å•çº¯çš„åç§°ä¹Ÿå¯èƒ½æ˜¯å·¥å‚çš„åç§° // ä¾‹å¦‚ &amp;amp;bean å°±ä»£è¡¨ä»åç§°ä¸ºbeançš„å·¥å‚ä¸­è·å– bean final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. // é€šè¿‡å•åˆ©å·¥å‚è·å– bean Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;amp;&amp;amp; args == null) { if (logger.isTraceEnabled()) { if (isSingletonCurrentlyInCreation(beanName)) { logger.trace(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName + &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;); } else { logger.trace(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;); } } bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } else { // å¦‚æœä¸ºåŸå‹æ¨¡å¼,å­˜åœ¨å¾ªç¯ä¾èµ–åˆ™æŠ¥é”™ // Fail if we're already creating this bean instance: // We're assumably within a circular reference. // å¦‚æœæ˜¯åŸå‹æ¨¡å¼åˆ™ä¸è§£å†³å¾ªç¯ä¾èµ–é—®é¢˜,ç›´æ¥æŠ›å‡ºå¼‚å¸¸ if (isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } // è·å–çˆ¶beanå·¥å‚ // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); // é€šè¿‡é€’å½’çˆ¶å·¥å‚è·å–beanå¯¹è±¡ // å¦‚æœæ— beanå®šä¹‰å¹¶ä¸”è¿˜è¦åŠ è½½è¿™ä¸ªbean è¯´æ˜è¿™ä¸ªbeanå·²ç»è¢«åŠ è½½è¿‡äº† if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) { // Not found -&amp;gt; check parent. String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) { return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); } else if (args != null) { // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); } else if (requiredType != null) { // No args -&amp;gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); } else { return (T) parentBeanFactory.getBean(nameToLookup); } } //è®°å½• bean æ­£åœ¨åˆ›å»ºä¸­ if (!typeCheckOnly) { markBeanAsCreated(beanName); } try { final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) { for (String dep : dependsOn) { if (isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;); } //ä¾èµ–æ³¨å†Œ registerDependentBean(dep, beanName); try { //è·å–bean,å¾ªç¯è·å–ä¾èµ– getBean(dep); } catch (NoSuchBeanDefinitionException ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex); } } } // åˆ›å»ºbeanå®ä¾‹ // Create bean instance. // å•åˆ©æ¨¡å¼ if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -&amp;gt; { try { return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } // åŸå‹æ¨¡å¼ else if (mbd.isPrototype()) { // It's a prototype -&amp;gt; create a new instance. Object prototypeInstance = null; try { // å‰ç½®å¤„ç† beforePrototypeCreation(beanName); // åˆ›å»ºbean prototypeInstance = createBean(beanName, mbd, args); } finally { // åç½®å¤„ç† afterPrototypeCreation(beanName); } bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } else { // å…¶ä»–ä½œç”¨åŸŸ String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) { throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;); } try { Object scopedInstance = scope.get(beanName, () -&amp;gt; { // å‰ç½®å¤„ç† beforePrototypeCreation(beanName); try { // åˆ›å»º bean return createBean(beanName, mbd, args); } finally { // åç½®å¤„ç† afterPrototypeCreation(beanName); } }); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException ex) { throw new BeanCreationException(beanName, &quot;Scope '&quot; + scopeName + &quot;' is not active for the current thread; consider &quot; + &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;, ex); } } } catch (BeansException ex) { cleanupAfterBeanCreationFailure(beanName); throw ex; } } //ç±»å‹è½¬æ¢ // Check if required type matches the type of the actual bean instance. if (requiredType != null &amp;amp;&amp;amp; !requiredType.isInstance(bean)) { try { T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType); if (convertedBean == null) { throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); } return convertedBean; } catch (TypeMismatchException ex) { if (logger.isTraceEnabled()) { logger.trace(&quot;Failed to convert bean '&quot; + name + &quot;' to required type '&quot; + ClassUtils.getQualifiedName(requiredType) + &quot;'&quot;, ex); } throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); } } return (T) bean; } â€‹ ä»£ç å¾ˆé•¿,çœ‹èµ·æ¥æ¯”è¾ƒè´¹åŠ².æ‹†åˆ†æ¥çœ‹çœ‹ã€‚ // AbstractBeanFactory // æå– bean name,bean name å¯èƒ½ä¸æ˜¯å•çº¯çš„åç§°ä¹Ÿå¯èƒ½æ˜¯å·¥å‚çš„åç§° // ä¾‹å¦‚ &amp;amp;bean å°±ä»£è¡¨ä»åç§°ä¸ºbeançš„å·¥å‚ä¸­è·å– bean final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. // é€šè¿‡å•åˆ©å·¥å‚è·å– bean Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;amp;&amp;amp; args == null) { if (logger.isTraceEnabled()) { if (isSingletonCurrentlyInCreation(beanName)) { logger.trace(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName + &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;); } else { logger.trace(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;); } } bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } è·å–beançš„çœŸå®åç§° è·å–bean â€‹ è¿™éƒ¨åˆ†åˆ†æˆ3å¥ä»£ç  String beanName = transformedBeanName(name); Object sharedInstance = getSingleton(beanName); bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); 2.1 transformedBeanName // AbstractBeanFactory protected String transformedBeanName(String name) { return canonicalName(BeanFactoryUtils.transformedBeanName(name)); } // BeanFactoryUtils public static String transformedBeanName(String name) { Assert.notNull(name, &quot;'name' must not be null&quot;); // åˆ¤æ–­æ˜¯å¦æ˜¯ä»¥&amp;amp; å¼€å¤´çš„åç§° if (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) { return name; } // åç§°-&amp;gt;çœŸå®åç§° æ”¾å…¥æ¢æˆä¸­ // ä¸åœçš„å¾ªç¯æˆªå–&amp;amp;åé¢çš„éƒ¨åˆ†,ç›´åˆ°ä¸ä»¥&amp;amp;å¼€å¤´ä¸ºæ­¢ return transformedBeanNameCache.computeIfAbsent(name, beanName -&amp;gt; { do { beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length()); } while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)); return beanName; }); } // AbstractBeanFactory public String canonicalName(String name) { String canonicalName = name; // Handle aliasing... String resolvedName; // åˆ¤æ–­beançš„åç§°æ˜¯å¦æ˜¯åˆ«å // ä¸€ç›´å¾ªç¯ è·Ÿç€åˆ«åçš„å¼•ç”¨é“¾èµ° // ç›´åˆ°éåˆ«åä¸ºæ­¢ // ä¾‹å¦‚ A-B-C-D-E-F // ä»Aæ‰¾åˆ°F do { resolvedName = this.aliasMap.get(canonicalName); if (resolvedName != null) { canonicalName = resolvedName; } } while (resolvedName != null); return canonicalName; } å…ˆåˆ¤æ–­æ˜¯å¦æ˜¯ä»¥&amp;amp;å¼€å¤´,è¿™ä¸ªç¬¦å·ä»£è¡¨ç€å¼•ç”¨çš„æ„æ€,åœ¨c/c++é‡Œé¢ä¼°è®¡ä¼šå¾ˆç†Ÿæ‚‰. åˆ¤æ–­æ˜¯å¦æ˜¯åˆ«å è¿”å›æœ€ç»ˆç¡®å®šä¸‹æ¥çš„beanåç§° 2.2 &amp;amp; ç¬¦å·çš„ä½œç”¨ public class MyTestFactoryBean implements FactoryBean&amp;lt;MyTestBean&amp;gt; { @Override public MyTestBean getObject() throws Exception { return new MyTestBean(); } @Override public Class&amp;lt;?&amp;gt; getObjectType() { return MyTestBean.class; } @Override public boolean isSingleton() { return true; } } &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&amp;gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&amp;gt; &amp;lt;bean id=&quot;myTestBeanFactory&quot; class=&quot;com.sjr.test.bean.MyTestFactoryBean&quot;/&amp;gt; &amp;lt;/beans&amp;gt; public class TestSpringFactoryBean { @Test public void testFactoryBean() { BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBeanFactory.xml&quot;)); final Object bean = factory.getBean(&quot;myTestBeanFactory&quot;); System.out.println(bean.getClass().getName()); final Object bean1 = factory.getBean(&quot;&amp;amp;myTestBeanFactory&quot;); System.out.println(bean1.getClass().getName()); } } æœ€åç»“æœè¾“å‡ºä¸º: com.sjr.test.bean.MyTestBean com.sjr.test.bean.MyTestFactoryBean â€‹ ä»ç»“æœä¸Šæ¥åº”è¯¥ç§’æ‡‚å§,å¦‚æœä¸€FactoryBeanå¯¹è±¡åœ¨springåˆ›å»ºçš„æ—¶å€™ä¼šåˆ¤æ–­beanåç§°,å¦‚æœbeanåç§°ä¸­ä¸å¸¦æœ‰&amp;amp;ç¬¦å·,è¯´æ˜æ˜¯è¦è·å–FactoryBeanæ‰€äº§ç”Ÿçš„å¯¹è±¡,å¦‚æœå¸¦æœ‰&amp;amp;ç¬¦å·,åˆ™è¯´æ˜éœ€è¦è·å–FactoryBeanå¯¹è±¡æœ¬èº«. 2.2 getSingleton // DefaultSingletonBeanRegistry @Override @Nullable public Object getSingleton(String beanName) { return getSingleton(beanName, true); } @Nullable protected Object getSingleton(String beanName, boolean allowEarlyReference) { // ç¼“å­˜ä¸­æ˜¯å¦æœ‰åˆ›å»ºå¥½çš„bean Object singletonObject = this.singletonObjects.get(beanName); // ç¼“å­˜ä¸­æ— æŒ‡å®šçš„beanå¹¶ä¸”è¯¥beanæœªåœ¨åˆ›å»ºä¸­ if (singletonObject == null &amp;amp;&amp;amp; isSingletonCurrentlyInCreation(beanName)) { // åŠ é” synchronized (this.singletonObjects) { // æŒ‡å®šçš„beanæ˜¯å¦åœ¨åˆ›å»ºä¸­ singletonObject = this.earlySingletonObjects.get(beanName); // éåˆ›å»ºä¸­,å¹¶ä¸”å…è®¸æå‰å¼•ç”¨ if (singletonObject == null &amp;amp;&amp;amp; allowEarlyReference) { // è·å–å•åˆ©å·¥å‚ ObjectFactory&amp;lt;?&amp;gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { // è°ƒç”¨å·¥å‚åˆ›å»ºå¯¹è±¡ singletonObject = singletonFactory.getObject(); // æŠŠåˆ›å»ºå¥½çš„å¯¹è±¡æ”¾å…¥åˆ°æ­£åœ¨åˆ›å»ºçš„é›†åˆä¸­å» this.earlySingletonObjects.put(beanName, singletonObject); // ç§»é™¤å•åˆ©å·¥å‚ this.singletonFactories.remove(beanName); } } } } return singletonObject; } â€‹ é€»è¾‘æ¯”è¾ƒç®€å•,è¿™é‡Œæœ‰å‡ ä¸ªmap æ¯”è¾ƒé‡è¦: singletonObjects ç”¨äºä¿å­˜BeanNameå’Œåˆ›å»ºbeanå®ä¾‹ä¹‹é—´çš„å…³ç³» beanName-&amp;gt;bean earlySingletonObjects ç”¨äºä¿å­˜BeanNameå’Œåˆ›å»ºbeanå®ä¾‹ä¹‹é—´çš„å…³ç³» beanName-&amp;gt;bean,ä¸åŒç‚¹æ˜¯,å½“beanæ”¾å…¥åˆ°æ­¤é›†åˆä¸­æ—¶,åœ¨beanåˆ›å»ºçš„è¿‡ç¨‹ä¸­å°±å¯ä»¥é€š è¿‡getBeanæ–¹æ³•æ¥è·å–beançš„å¼•ç”¨,ä¸»è¦æ˜¯ç”¨äºè§£å†³å¾ªç¯ä¾èµ–é—®é¢˜. singletonFactories:ç”¨äºä¿å­˜beanNameä¸beanå·¥å‚ä¹‹é—´çš„å…³ç³» registeredSingletons:ç”¨æ¥ä¿å­˜å½“å‰æ‰€æœ‰å·²æ³¨å†Œçš„bean â€‹ å¦‚æœbeanåç§°æ˜¯å·¥å‚çš„åç§°,é‚£ä¹ˆè¿™é‡Œå·²ç»å®Œæˆäº†beançš„åˆ›å»ºäº†,ä½†ä»…ä»…æ˜¯åˆ›å»ºå®Œæˆè¿˜æ˜¯ä¸å¤Ÿ,springè¿˜è¦æ’ä¸Šä¸€è„šè¿›è¡Œç®¡ç†. 2.3 getObjectForBeanInstance protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) { // Don't let calling code try to dereference the factory if the bean isn't a factory. // æ£€æŸ¥beanåç§°æ˜¯å¦ç¬¦åˆbeanå·¥å‚çš„å‘½åè§„èŒƒ,å¦‚æœåç§°æ˜¯å·¥å‚çš„æ ¼å¼,åˆ™è·å–çš„beanä¸ºå·¥å‚å®ä¾‹ if (BeanFactoryUtils.isFactoryDereference(name)) { // ç¬¦åˆè§„èŒƒä½†æ˜¯ä¸ªnull if (beanInstance instanceof NullBean) { return beanInstance; } // ç¬¦åˆè§„èŒƒä½†ä¸æ˜¯factory,å¼‚å¸¸ if (!(beanInstance instanceof FactoryBean)) { throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass()); } // å¦‚æœbeanå®šä¹‰ä¸ä¸ºç©º,è®¾ç½®ä¸ºtrueè¡¨æ˜æ˜¯ä¸ªå·¥å‚bean if (mbd != null) { mbd.isFactoryBean = true; } return beanInstance; } // Now we have the bean instance, which may be a normal bean or a FactoryBean. // If it's a FactoryBean, we use it to create a bean instance, unless the // caller actually wants a reference to the factory. // å¦‚æœbeanå®ä¾‹ä¸ºéå·¥å‚,ç›´æ¥è¿”å› if (!(beanInstance instanceof FactoryBean)) { return beanInstance; } // åé¢çš„é€»è¾‘æ˜¯beanæ˜¯å·¥å‚,è€Œåç§°åˆ™ä¸æ˜¯å·¥å‚çš„è§£å¼•ç”¨æ ¼å¼ Object object = null; if (mbd != null) { mbd.isFactoryBean = true; } else { // ä»ç¼“å­˜ä¸­è·å–å¯¹è±¡å¯¹åº”çš„å·¥å‚bean object = getCachedObjectForFactoryBean(beanName); } if (object == null) { // Return bean instance from factory. FactoryBean&amp;lt;?&amp;gt; factory = (FactoryBean&amp;lt;?&amp;gt;) beanInstance; // Caches object obtained from FactoryBean if it is a singleton. if (mbd == null &amp;amp;&amp;amp; containsBeanDefinition(beanName)) { mbd = getMergedLocalBeanDefinition(beanName); } boolean synthetic = (mbd != null &amp;amp;&amp;amp; mbd.isSynthetic()); object = getObjectFromFactoryBean(factory, beanName, !synthetic); } return object; } å¦‚æœbeançš„åç§°ä»¥&amp;amp; å¼€å¤´å¹¶ä¸”æ˜¯FactoryBeanå­ç±»,ç›´æ¥è¿”å›å·¥å‚å¯¹è±¡ å¦‚æœbeançš„åç§°éä»¥&amp;amp;å¼€å¤´å¹¶ä¸”éFactoryBeanå­ç±»ç›´æ¥è¿”å›å¯¹è±¡ å¦‚æœbeançš„åç§°éä»¥&amp;amp;å¼€å¤´å¹¶ä¸”æ˜¯FactoryBeanå­ç±»è°ƒç”¨FactoryBeançš„getObjectæ–¹æ³•è·å–å¯¹è±¡ ä»¥ä¸Šä»£ç ä¸­çš„æ ¸å¿ƒä»£ç æœ‰ä¸‰å¤„: getCachedObjectForFactoryBean() getMergedLocalBeanDefinition() getObjectFromFactoryBean() 2.4 getCachedObjectForFactoryBean @Nullable protected Object getCachedObjectForFactoryBean(String beanName) { return this.factoryBeanObjectCache.get(beanName); } â€‹ ä»£ç å¾ˆç®€å•,å°±æ˜¯æ ¹æ®beanNameåœ¨æ¢æˆä¸­è·å–å¯¹åº”çš„bean 2.5 getMergedLocalBeanDefinition // AbstractBeanFactory protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException { // Quick check on the concurrent map first, with minimal locking. // ä»ç¼“å­˜ä¸­è·å– RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName); if (mbd != null &amp;amp;&amp;amp; !mbd.stale) { return mbd; } return getMergedBeanDefinition(beanName, getBeanDefinition(beanName)); } protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd) throws BeanDefinitionStoreException { return getMergedBeanDefinition(beanName, bd, null); } protected RootBeanDefinition getMergedBeanDefinition( String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd) throws BeanDefinitionStoreException { // åŠ é”,å¹¶å‘æ§åˆ¶ synchronized (this.mergedBeanDefinitions) { RootBeanDefinition mbd = null; RootBeanDefinition previous = null; // Check with full lock now in order to enforce the same merged instance. if (containingBd == null) { // å¦‚æœä¸ºç©º ä»ç¼“å­˜ä¸­è·å– mbd = this.mergedBeanDefinitions.get(beanName); } if (mbd == null || mbd.stale) { previous = mbd; // åˆ¤æ–­æ˜¯å¦å…·æœ‰çˆ¶å­å…³ç³» if (bd.getParentName() == null) { // Use copy of given root bean definition. // åˆ¤æ–­ç±»å‹æ˜¯å¦æ˜¯ RootBeanDefinition if (bd instanceof RootBeanDefinition) { // copyä¸€ä¸ª mbd = ((RootBeanDefinition) bd).cloneBeanDefinition(); } else { // è½¬æ¢ä¸º RootBeanDefinition mbd = new RootBeanDefinition(bd); } } else { // Child bean definition: needs to be merged with parent. BeanDefinition pbd; try { // è·å– çˆ¶bean åç§° String parentBeanName = transformedBeanName(bd.getParentName()); // åˆ¤æ–­çˆ¶ä¸å­çš„bean åç§°æ˜¯å¦ç›¸åŒ if (!beanName.equals(parentBeanName)) { // å¦‚æœä¸ç›¸åŒ,åˆ™é¡ºåˆ™ çˆ¶å­å…³ç³» ä¸€è·¯é€’å½’ä¸Šå» // å…¨éƒ¨è½¬æ¢ä¸º RootBeanDefinition pbd = getMergedBeanDefinition(parentBeanName); } else { // å’Œä¸Šé¢ä»£ç é€»è¾‘ç›¸åŒ åªæ˜¯ç±»å‹ä¸ä¸€æ · BeanFactory parent = getParentBeanFactory(); if (parent instanceof ConfigurableBeanFactory) { pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName); } else { throw new NoSuchBeanDefinitionException(parentBeanName, &quot;Parent name '&quot; + parentBeanName + &quot;' is equal to bean name '&quot; + beanName + &quot;': cannot be resolved without an AbstractBeanFactory parent&quot;); } } } catch (NoSuchBeanDefinitionException ex) { throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName, &quot;Could not resolve parent bean definition '&quot; + bd.getParentName() + &quot;'&quot;, ex); } // Deep copy with overridden values. // æ·±æ‹·è´ è½¬æ¢ä¸ºRootBeanDefinition mbd = new RootBeanDefinition(pbd); mbd.overrideFrom(bd); } // Set default singleton scope, if not configured before. if (!StringUtils.hasLength(mbd.getScope())) { mbd.setScope(SCOPE_SINGLETON); } // A bean contained in a non-singleton bean cannot be a singleton itself. // Let's correct this on the fly here, since this might be the result of // parent-child merging for the outer bean, in which case the original inner bean // definition will not have inherited the merged outer bean's singleton status. if (containingBd != null &amp;amp;&amp;amp; !containingBd.isSingleton() &amp;amp;&amp;amp; mbd.isSingleton()) { mbd.setScope(containingBd.getScope()); } // Cache the merged bean definition for the time being // (it might still get re-merged later on in order to pick up metadata changes) if (containingBd == null &amp;amp;&amp;amp; isCacheBeanMetadata()) { // åŠ å…¥ç¼“å­˜ this.mergedBeanDefinitions.put(beanName, mbd); } } if (previous != null) { copyRelevantMergedBeanDefinitionCaches(previous, mbd); } return mbd; } } â€‹ è¯´è¿™ä»£ç ä¹‹å‰,å…ˆè¯´è¯´springä¸­çš„åŸºæœ¬æ•°æ®ç»“æ„.åœ¨springä¸­åŸºæœ¬æ•°æ®ç»“æ„ä¸ºBeanDefinition,é€šè¿‡springäº§ç”Ÿçš„æ™®é€šbeanä¸ºGenericBeanDefinition.è€Œspringåç»­å¤„ç†çš„ç±»å‹åˆ™ä¸ºRootBeanDefinition.å…³ç³»å›¾å¦‚ä¸‹: â€‹ è¿™ä¸¤ä¸ªé•¿çš„éƒ½å·®ä¸å¤š,åªä¸è¿‡åç»­å¤„ç†çš„æ­¥éª¤ç”¨åˆ°çš„ç±»å‹ä¸ºRootBeanDefinition,æ‰€ä»¥åœ¨ä¸Šé¢çš„æ–¹æ³•ä¸­,è¿›è¡Œé€’å½’è½¬æ¢. 2.6 getObjectFromFactoryBean // AbstractBeanFactory boolean synthetic = (mbd != null &amp;amp;&amp;amp; mbd.isSynthetic()); object = getObjectFromFactoryBean(factory, beanName, !synthetic); â€‹ è¿™é‡Œè¿™ä¸ªisSyntheticæ–¹æ³•ä»£è¡¨æ˜¯å¦æ˜¯äººé€ çš„,emmaå°±è¿™æ ·ç†è§£å§.ä»€ä¹ˆå«åšäººé€ çš„å‘¢?æ„æ€å°±æ˜¯ä¸åŠ å¹²é¢„é€šspringäº§ç”Ÿçš„å°±æ˜¯éäººé€ çš„,å¦‚æœæ˜¯åé¢é€šè¿‡ä»£ç†äº§ç”Ÿçš„å°±æ˜¯éäººé€ çš„. â€‹ çœ‹äº†ä¸€ä¸‹setSyntheticè¿™ä¸ªæ–¹æ³•çš„è°ƒç”¨æƒ…å†µ,éƒ½æ˜¯åœ¨aopé‚£è¾¹è°ƒç”¨çš„æ¯”è¾ƒå¤š.ä¸çŸ¥é“è§£é‡Šçš„å¯¹ä¸å¯¹å“ˆ. // FactoryBeanRegistrySupport protected Object getObjectFromFactoryBean(FactoryBean&amp;lt;?&amp;gt; factory, String beanName, boolean shouldPostProcess) { // åˆ¤æ–­å·¥å‚æ˜¯å¦ä¸ºå•åˆ©å·¥å‚,å¹¶ä¸”å•åˆ©å¯¹è±¡å·²è¢«åˆ›å»ºå®Œæˆ if (factory.isSingleton() &amp;amp;&amp;amp; containsSingleton(beanName)) { // åŠ é” synchronized (getSingletonMutex()) { // åœ¨ç¼“å­˜ä¸­è·å–é€šè¿‡å·¥å‚åˆ›å»ºçš„bean Object object = this.factoryBeanObjectCache.get(beanName); if (object == null) { // è·å–beané€šè¿‡å·¥å‚ object = doGetObjectFromFactoryBean(factory, beanName); // Only post-process and store if not put there already during getObject() call above // (e.g. because of circular reference processing triggered by custom getBean calls) // å†æ¬¡ä»ç¼“å­˜ä¸­è·å–bean Object alreadyThere = this.factoryBeanObjectCache.get(beanName); if (alreadyThere != null) { // å¦‚æœç¼“å­˜ä¸­è·å–åˆ°bean,åˆ™ä¸¢å¼ƒå½“å‰åˆ›å»ºçš„å¯¹è±¡ object = alreadyThere; } else { // åˆ¤æ–­æ˜¯å¦éœ€è¦post-processing if (shouldPostProcess) { // å½“å‰çš„beanæ˜¯å¦è¢«åˆ›å»ºä¸­,å¦‚æœæ˜¯å°±ç›´æ¥è¿”å›å½“å‰çš„beanä¸åšå¤„ç† if (isSingletonCurrentlyInCreation(beanName)) { // Temporarily return non-post-processed object, not storing it yet.. return object; } // beanåˆ›å»ºä¹‹å‰,æŠŠå½“å‰beanåŠ å…¥æ­£åœ¨åˆ›å»ºä¸­çš„é›†åˆä¸­å» beforeSingletonCreation(beanName); try { // AOPçš„æ ¸å¿ƒæ­¥éª¤ object = postProcessObjectFromFactoryBean(object, beanName); } catch (Throwable ex) { throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean's singleton object failed&quot;, ex); } finally { // beanåˆ›å»ºä¹‹å,æŠŠbeanä»æ­£åœ¨åˆ›å»ºä¸­çš„é›†åˆä¸­ç§»é™¤ afterSingletonCreation(beanName); } } if (containsSingleton(beanName)) { // ç¼“å­˜beanå¯¹è±¡ this.factoryBeanObjectCache.put(beanName, object); } } } return object; } } else { //åˆ›å»ºå¯¹è±¡ Object object = doGetObjectFromFactoryBean(factory, beanName); if (shouldPostProcess) { try { //å¤„ç†beanæµç¨‹ object = postProcessObjectFromFactoryBean(object, beanName); } catch (Throwable ex) { throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean's object failed&quot;, ex); } } return object; } } åˆ¤æ–­æ˜¯å¦æ˜¯å•åˆ©å·¥å‚,å¹¶ä¸”ç¼“å­˜ä¸­å·²ç»åˆ›å»ºäº†è¯¥beançš„factoryBean åˆ¤æ–­factoryBeanObjectCacheç¼“å­˜ä¸­beanæ˜¯å¦å­˜åœ¨ é€šè¿‡factoryBeanåˆ›å»ºbean â€‹ ä»¥ä¸Šé€»è¾‘ä¸ºå½“æœ‰factoryBeançš„é€»è¾‘. ä¸‰ã€ååŠæ®µé€»è¾‘ //AbstractBeanFactory // å¦‚æœä¸ºåŸå‹æ¨¡å¼,å­˜åœ¨å¾ªç¯ä¾èµ–åˆ™æŠ¥é”™ // Fail if we're already creating this bean instance: // We're assumably within a circular reference. // å¦‚æœæ˜¯åŸå‹æ¨¡å¼åˆ™ä¸è§£å†³å¾ªç¯ä¾èµ–é—®é¢˜,ç›´æ¥æŠ›å‡ºå¼‚å¸¸ if (isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } // è·å–çˆ¶beanå·¥å‚ // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); // é€šè¿‡é€’å½’çˆ¶å·¥å‚è·å–beanå¯¹è±¡ // å¦‚æœæ— beanå®šä¹‰å¹¶ä¸”è¿˜è¦åŠ è½½è¿™ä¸ªbean è¯´æ˜è¿™ä¸ªbeanå·²ç»è¢«åŠ è½½è¿‡äº† if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) { // Not found -&amp;gt; check parent. String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) { return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); } else if (args != null) { // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); } else if (requiredType != null) { // No args -&amp;gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); } else { return (T) parentBeanFactory.getBean(nameToLookup); } } â€‹ å¦‚æœéå•åˆ©æ¨¡å¼,springåœ¨è¿™é‡Œä¸å¤„ç†å¾ªç¯ä¾èµ–é—®é¢˜.å¦‚æœBeanFactoryå­˜åœ¨çˆ¶å­å…³ç³»,åˆ™è¿›è¡Œé€’å½’åˆ›å»º. // AbstractBeanFactory // è®°å½• bean æ­£åœ¨åˆ›å»ºä¸­ if (!typeCheckOnly) { markBeanAsCreated(beanName); } // è½¬æ¢BeanDefinitionä¸ºRootBeanDefinition final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); // æ£€æŸ¥RootBeanDefinitionæ˜¯å¦åˆæ³• checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. // éå†æ‰€æœ‰ä¾èµ–,å¹¶è¿›è¡Œæ³¨å†Œã€åˆ›å»ºç­‰è¿‡ç¨‹ String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) { for (String dep : dependsOn) { if (isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;); } // ä¾èµ–æ³¨å†Œ registerDependentBean(dep, beanName); try { // è·å–bean,å¾ªç¯è·å–ä¾èµ– getBean(dep); } catch (NoSuchBeanDefinitionException ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex); } } } // åˆ›å»ºbeanå®ä¾‹ // Create bean instance. // å•åˆ©æ¨¡å¼ if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -&amp;gt; { try { return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } æ ‡è®°è¯¥beanæœªæ­£åœ¨åˆ›å»ºä¸­. // AbstractBeanFactory protected void markBeanAsCreated(String beanName) { // åˆ¤æ–­æ˜¯å¦åŒ…å«beanName if (!this.alreadyCreated.contains(beanName)) { // åŠ é”å¹¶å‘æ§åˆ¶ synchronized (this.mergedBeanDefinitions) { // åŒé‡æ£€æŸ¥ if (!this.alreadyCreated.contains(beanName)) { // Let the bean definition get re-merged now that we're actually creating // the bean... just in case some of its metadata changed in the meantime. clearMergedBeanDefinition(beanName); // æ·»åŠ è¿›è¡Œå·²ç»åˆ›å»ºé›†åˆä¸­ this.alreadyCreated.add(beanName); } } } } éå†ä¾èµ–å¹¶è¿›è¡Œé€’å½’åˆ›å»º // AbstractBeanFactory if (dependsOn != null) { for (String dep : dependsOn) { if (isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;); } //ä¾èµ–æ³¨å†Œ registerDependentBean(dep, beanName); try { //è·å–bean,å¾ªç¯è·å–ä¾èµ– getBean(dep); } catch (NoSuchBeanDefinitionException ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex); } } } â€‹ è¿™é‡Œçš„æ ¸å¿ƒé€»è¾‘åœ¨äºgetSingletonè¿™ä¸ªæ–¹æ³•é‡Œ 3.1 getSingleton // AbstractBeanFactory public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) { Assert.notNull(beanName, &quot;Bean name must not be null&quot;); // åŠ é” synchronized (this.singletonObjects) { // ä»ç¼“å­˜ä¸­è·å– bean Object singletonObject = this.singletonObjects.get(beanName); // å¦‚æœç¼“å­˜ä¸­æ²¡æœ‰ if (singletonObject == null) { // åˆ¤æ–­å½“å‰beanæ˜¯å¦è¢«æ ‡è®°ä¸ºé”€æ¯ // ç›¸å½“äºä¸èƒ½åœ¨destroryæ–¹æ³•é‡Œé¢å†å»åˆ›å»ºè¿™ä¸ªbean if (this.singletonsCurrentlyInDestruction) { throw new BeanCreationNotAllowedException(beanName, &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; + &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;); } if (logger.isDebugEnabled()) { logger.debug(&quot;Creating shared instance of singleton bean '&quot; + beanName + &quot;'&quot;); } // å¼€å§‹åˆ›å»º bean // æ·»åŠ åˆ° åˆ›å»ºä¸­é›†åˆä¸­å» // å‰ç½®å¤„ç† beforeSingletonCreation(beanName); boolean newSingleton = false; boolean recordSuppressedExceptions = (this.suppressedExceptions == null); if (recordSuppressedExceptions) { this.suppressedExceptions = new LinkedHashSet&amp;lt;&amp;gt;(); } try { // ä»å·¥å‚ä¸­è·å– bean singletonObject = singletonFactory.getObject(); newSingleton = true; } catch (IllegalStateException ex) { // Has the singleton object implicitly appeared in the meantime -&amp;gt; // if yes, proceed with it since the exception indicates that state. singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { throw ex; } } catch (BeanCreationException ex) { if (recordSuppressedExceptions) { for (Exception suppressedException : this.suppressedExceptions) { ex.addRelatedCause(suppressedException); } } throw ex; } finally { if (recordSuppressedExceptions) { this.suppressedExceptions = null; } // ç§»é™¤åˆ›å»ºä¸­çš„é›†åˆ afterSingletonCreation(beanName); } if (newSingleton) { // æ”¾å…¥ç¼“å­˜ addSingleton(beanName, singletonObject); } } return singletonObject; } } ä»ç¼“å­˜ä¸­è·å–bean å¦‚æœæ¢æˆä¸­æ²¡æœ‰,åˆ™åˆ¤æ–­å½“å‰çš„beanæ˜¯å¦è¢«è®°è¢«é”€æ¯ åœ¨åˆ›å»ºä¹‹å‰æŠŠbeanNameåŠ å…¥æ­£åœ¨åˆ›å»ºçš„ç¼“å­˜ä¸­å» ä»å•åˆ©å·¥å‚ä¸­åˆ›å»ºbean ä»æ­£åœ¨åˆ›å»ºçš„æ¢æˆä¸­ç§»é™¤beanName æŠŠåˆ›å»ºå¥½çš„singletonObjectåŠ å…¥ç¼“å­˜ä¸­ å€¼å¾—æ³¨æ„çš„æ˜¯è¿™é‡Œçš„singletonFactoryå¯¹è±¡æ˜¯é€šè¿‡Lambdaè¡¨è¾¾ä¼ å…¥è¿›æ¥çš„ // AbstractBeanFactory sharedInstance = getSingleton(beanName, () -&amp;gt; { try { return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); è¿™é‡Œçš„æ ¸å¿ƒé€»è¾‘ä»£ç æ˜¯createBean(beanName, mbd, args) 3.2 createBean // AbstractAutowireCapableBeanFactory @Override protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { if (logger.isTraceEnabled()) { logger.trace(&quot;Creating instance of bean '&quot; + beanName + &quot;'&quot;); } RootBeanDefinition mbdToUse = mbd; // Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition. // æ ¹æ®ç±»ååŠ è½½classå¯¹è±¡ Class&amp;lt;?&amp;gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;amp;&amp;amp; !mbd.hasBeanClass() &amp;amp;&amp;amp; mbd.getBeanClassName() != null) { mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); } // Prepare method overrides. try { // åŒ¹é…éœ€è¦è¦†ç›–çš„æ–¹æ³• mbdToUse.prepareMethodOverrides(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, &quot;Validation of method overrides failed&quot;, ex); } try { // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. // è¿”å›ä¸€ä¸ªä»£ç†å¯¹è±¡,ä¹Ÿå¯èƒ½æ˜¯éä»£ç†å¯¹è±¡ Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) { return bean; } } catch (Throwable ex) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex); } try { // åˆ›å»ºbean Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isTraceEnabled()) { logger.trace(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;); } return beanInstance; } catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) { // A previously detected exception with proper bean creation context already, // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry. throw ex; } catch (Throwable ex) { throw new BeanCreationException( mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex); } } åŠ è½½class åˆ¤æ–­è¯¥beanæ˜¯å¦éœ€è¦InstantiationAwareBeanPostProcessorè¿›è¡Œå¤„ç†,è¿™ä¸ªæ¥å£ä¸BeanPostProcessorä¸åŒ,ä¸»è¦åŒºåˆ«æ˜¯åœ¨è°ƒç”¨æ—¶æœºä¸Šçš„åŒºåˆ«,InstantiationAwareBeanPostProcessorä¼šåœ¨å¯¹è±¡åˆ›å»ºå‰è¿›è¡Œè°ƒç”¨,è€ŒBeanPostProcessorä¼šåœ¨å¯¹è±¡åˆå§‹åŒ–å‰åè¿›è¡Œè°ƒç”¨,è¿™ä¸ªå¯ä»¥ä»doCreateBeançœ‹å‡ºæ—¶æœºçš„å·®åˆ«. åˆ›å»ºå¯¹è±¡ 3.3 doCreateBean // AbstractAutowireCapableBeanFactory protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException { // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { // ä»ç¼“å­˜ä¸­è·å–å®ä¾‹wrapper,å¹¶ç§»é™¤å®ƒ instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } // å¦‚æœæ²¡æœ‰è·å–åˆ°å®ä¾‹çš„wrapper,åˆ™åˆ›å»ºä¸€ä¸ªå®ä¾‹ if (instanceWrapper == null) { instanceWrapper = createBeanInstance(beanName, mbd, args); } final Object bean = instanceWrapper.getWrappedInstance(); Class&amp;lt;?&amp;gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } // Allow post-processors to modify the merged bean definition. // åˆ¤æ–­æ˜¯å¦æœ‰ åç½®å¤„ç†å™¨ // åŠ é” synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { try { applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Post-processing of merged bean definition failed&quot;, ex); } mbd.postProcessed = true; } } // æ˜¯å¦å…è®¸å¾ªç¯å¼•ç”¨ // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isTraceEnabled()) { logger.trace(&quot;Eagerly caching bean '&quot; + beanName + &quot;' to allow for resolving potential circular references&quot;); } addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean)); } // Initialize the bean instance. Object exposedObject = bean; try { // å¡«å……beanå±æ€§ populateBean(beanName, mbd, instanceWrapper); // åˆå§‹åŒ–bean exposedObject = initializeBean(beanName, exposedObject, mbd); } catch (Throwable ex) { if (ex instanceof BeanCreationException &amp;amp;&amp;amp; beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex); } } // å¾ªç¯ä¾èµ–å¤„ç† if (earlySingletonExposure) { // è·å–å•åˆ©å¯¹è±¡ Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { if (exposedObject == bean) { exposedObject = earlySingletonReference; } else if (!this.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp; hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set&amp;lt;String&amp;gt; actualDependentBeans = new LinkedHashSet&amp;lt;&amp;gt;(dependentBeans.length); for (String dependentBean : dependentBeans) { if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + &quot;] in its raw version as part of a circular reference, but has eventually been &quot; + &quot;wrapped. This means that said other beans do not use the final version of the &quot; + &quot;bean. This is often the result of over-eager type matching - consider using &quot; + &quot;'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.&quot;); } } } } // Register bean as disposable. try { // æ³¨å†Œé”€æ¯å¤„ç†å™¨ registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex); } return exposedObject; } â€‹ è¿›è¿‡ä»¥ä¸Šéªšæ“ä½œå°±å®Œæˆäº†beançš„åˆ›å»º,åœ¨åˆ›å»ºçš„è¿‡ç¨‹ä¸­è¿˜ä¼šæœ‰å±æ€§çš„å¡«å……,beançš„åˆå§‹åŒ–ç­‰. å››ã€å°ç»“ â€‹ ç»§ç»­beançš„åˆå§‹åŒ–,ä¸å±æ€§çš„å¡«å…….</summary></entry><entry><title type="html">[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-BeanDefinitionHolderæ³¨å†Œ(ä¸ƒ)</title><link href="https://onew.me/spring/2020/03/02/debug-spring-7.html" rel="alternate" type="text/html" title="[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-BeanDefinitionHolderæ³¨å†Œ(ä¸ƒ)" /><published>2020-03-02T14:20:25+08:00</published><updated>2020-03-02T14:20:25+08:00</updated><id>https://onew.me/spring/2020/03/02/debug-spring-7</id><content type="html" xml:base="https://onew.me/spring/2020/03/02/debug-spring-7.html"># ä¸€ã€å‰è¨€

â€‹	é€šè¿‡å‰é¢å¤§æ‰¹é‡çš„å·¥ä½œ,ç»ˆäºè¦åˆ°æ³¨å†ŒBeanDefinitionHolderè¿™ä¸€æ­¥äº†.å½“ç„¶è¿˜æ˜¯é€šè¿‡ä¸€ä¸‹ä»£ç ä½œä¸ºå…¥å£è¿›è¡Œåˆ†æ.

```java
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
		// è§£æxmlå…ƒç´ 
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
		if (bdHolder != null) {
			// è£…é¥°bean
			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
			try {
				// Register the final decorated instance.
				// æ³¨å†Œbeanåˆ°å®¹å™¨ä¸­
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
						bdHolder.getBeanName() + &quot;'&quot;, ele, ex);
			}
			// Send registration event.
			// å‘é€äº‹ä»¶
			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
		}
	}
```

â€‹	è§£æã€è£…é¥°éƒ½å·²ç»è®°å½•äº†,è§£ææ¥çš„é‡ç‚¹å°±æ˜¯`BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());`è¿™å¥ä»£ç äº†.



# äºŒã€åˆ†æ

```java
public static void registerBeanDefinition(
			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
			throws BeanDefinitionStoreException {
		// æ³¨å†Œ bean
		// Register bean definition under primary name.
		// è·å– bean çš„åç§°
		String beanName = definitionHolder.getBeanName();
		// æ³¨å†Œ
		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

		//æ³¨å†Œ bean çš„æ‰€æœ‰åˆ«å
		// Register aliases for bean name, if any.
		String[] aliases = definitionHolder.getAliases();
		if (aliases != null) {
			for (String alias : aliases) {
				registry.registerAlias(beanName, alias);
			}
		}
	}
```

1. é€šè¿‡beançš„åç§°è¿›è¡Œæ³¨å†Œ
2. é€šè¿‡beançš„åˆ«åè¿›è¡Œæ³¨å†Œ



`BeanDefinitionRegistry`è¿™ä¸ªå¯¹è±¡æ˜¯é€šè¿‡`XmlReaderContext`ä¸­è·å–çš„.

```java
// XmlReaderContext
public final BeanDefinitionRegistry getRegistry() {
		return this.reader.getRegistry();
	}
```

â€‹	è€Œè¿™ä¸ªreaderåˆ™æ˜¯`XmlBeanDefinitionReader`,`registry`å¯¹è±¡åˆ™é€šè¿‡`XmlBeanDefinitionReader`çš„æ„é€ æ–¹æ³•ä¼ å…¥è¿›æ¥,å®é™…ä¸Šè¿™ä¸ª`registry`å¯¹è±¡å°±æ˜¯`XmlBeanFactory`æˆ–è€…è¯´æ˜¯`DefaultListableBeanFactory`,å› ä¸ºè¿™ä¸¤ä¸ªæœ‰ç»§æ‰¿å…³ç³».

â€‹	![images](https://gitee.com/oneww/onew_image/raw/master/XmlBeanFactory.png)





## 2.1 registerBeanDefinition



```java
// DefaultListableBeanFactory
@Override
	public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
			throws BeanDefinitionStoreException {

		Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);
		Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);

		if (beanDefinition instanceof AbstractBeanDefinition) {
			try {
				// æ ¡éªŒ bean çš„å®šä¹‰æ˜¯å¦åˆæ³•
				((AbstractBeanDefinition) beanDefinition).validate();
			}
			catch (BeanDefinitionValidationException ex) {
				throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
						&quot;Validation of bean definition failed&quot;, ex);
			}
		}
		// ä»ç¼“å­˜ä¸­å–å‡º BeanDefinition
		BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
		// bean å·²è¢«æ³¨å†Œè¿‡
		if (existingDefinition != null) {
			// å¦‚æœä¸å…è®¸é‡å¤æ³¨å†Œåˆ™æŠ›å‡ºå¼‚å¸¸
			if (!isAllowBeanDefinitionOverriding()) {
				throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
			}
			else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) {
				// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
				if (logger.isInfoEnabled()) {
					logger.info(&quot;Overriding user-defined bean definition for bean '&quot; + beanName +
							&quot;' with a framework-generated bean definition: replacing [&quot; +
							existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
				}
			}
			else if (!beanDefinition.equals(existingDefinition)) {
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Overriding bean definition for bean '&quot; + beanName +
							&quot;' with a different definition: replacing [&quot; + existingDefinition +
							&quot;] with [&quot; + beanDefinition + &quot;]&quot;);
				}
			}
			else {
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Overriding bean definition for bean '&quot; + beanName +
							&quot;' with an equivalent definition: replacing [&quot; + existingDefinition +
							&quot;] with [&quot; + beanDefinition + &quot;]&quot;);
				}
			}
			// æ”¾å…¥åˆ° map ä¸­
			// è¦†ç›–
			this.beanDefinitionMap.put(beanName, beanDefinition);
		}
		else {
			// åˆ¤æ–­æ˜¯å¦æœ‰åˆ›å»ºä¸­çš„bean
			if (hasBeanCreationStarted()) {
				// Cannot modify startup-time collection elements anymore (for stable iteration)
				// åŠ é”
				// ä¸èƒ½ä¿®æ”¹å¯åŠ¨æ—¶çš„é›†åˆ,éœ€è¦é‡æ–°åˆ›å»ºä¸€ä¸ªé›†åˆ
				synchronized (this.beanDefinitionMap) {
					// æ”¾å…¥mapä¸­
					this.beanDefinitionMap.put(beanName, beanDefinition);
					List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);
					updatedDefinitions.addAll(this.beanDefinitionNames);
					updatedDefinitions.add(beanName);
					this.beanDefinitionNames = updatedDefinitions;
					// å¦‚æœè¿™ä¸ªå·²ç» bean åœ¨å­˜åœ¨ åˆ™ç§»é™¤
					removeManualSingletonName(beanName);
				}
			}
			else {
				// Still in startup registration phase
				this.beanDefinitionMap.put(beanName, beanDefinition);
				this.beanDefinitionNames.add(beanName);
        // å¦‚æœè¿™ä¸ªå·²ç» bean åœ¨å­˜åœ¨ åˆ™ç§»é™¤
				removeManualSingletonName(beanName);
			}
			this.frozenBeanDefinitionNames = null;
		}
		//æ³¨å†ŒæˆåŠŸ,å¦‚æœæ˜¯é‡å¤æ³¨å†Œçš„åˆ™é”€æ¯ä¹‹å‰æ³¨å†Œçš„bean
		if (existingDefinition != null || containsSingleton(beanName)) {
			resetBeanDefinition(beanName);
		}
	}
```

â€‹	è¿™ä¸ªé˜¶æ®µå‘¢,beanéƒ½è¿˜æ²¡å¼€å§‹åˆ›å»º,éƒ½æ˜¯åœ¨åšè§£æ,æ³¨å†Œä¹‹ç±»çš„äº‹æƒ…,æ‰€ä»¥è¿™é‡Œæœ‰ä¸€ä¸ªåˆ¤æ–­çœ‹èµ·æ¥æ¯”è¾ƒè¿·æƒ‘`hasBeanCreationStarted`.æˆ–è®¸åé¢æ‰ä¼šçŸ¥é“è¿™ä¸ªåˆ¤æ–­æ¡ä»¶æœ‰å•¥ç”¨å§.

1. éªŒè¯`beanDefinition`æ˜¯å¦åˆæ³•

 	2. åˆ¤æ–­beanæ˜¯å¦è¢«æ³¨å†Œè¿‡,å¦‚æœä¸å…è®¸é‡å¤æ³¨å†Œåˆ™æŠ›å‡ºå¼‚å¸¸
 	3. å¦‚æœå…è®¸é‡å¤æ³¨å†Œåˆ™æ”¾å…¥`beanDefinitionMap`è¿™ä¸ªmapé›†åˆä¸­
 	4. å¦‚æœè¯¥`beanDefinition`æœªè¢«æ³¨å†Œè¿‡,åˆ™æ·»åŠ æ˜ å°„åˆ°`beanDefinitionMap`ä¸­å»å’Œ`beanDefinitionNames`é›†åˆä¸­å».
 	5. æ³¨å†ŒæˆåŠŸ,å¦‚æœæ˜¯é‡å¤æ³¨å†Œçš„åˆ™é”€æ¯ä¹‹å‰æ³¨å†Œçš„bean



## 2.2 registerAlias

```java
// SimpleAliasRegistry
@Override
	public void registerAlias(String name, String alias) {
		Assert.hasText(name, &quot;'name' must not be empty&quot;);
		Assert.hasText(alias, &quot;'alias' must not be empty&quot;);
		// åŠ é” å¹¶å‘æ§åˆ¶
		synchronized (this.aliasMap) {
			// åˆ¤æ–­ bean åç§°æ˜¯å¦ä¸åˆ«åç›¸åŒ,å¦‚æœç›¸åŒåˆ™å¿½ç•¥
			if (alias.equals(name)) {
				// ç§»é™¤åˆ«å
				this.aliasMap.remove(alias);
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Alias definition '&quot; + alias + &quot;' ignored since it points to same name&quot;);
				}
			}
			else {
				// åˆ¤æ–­åˆ«åæ˜¯å¦å·²å­˜åœ¨
				String registeredName = this.aliasMap.get(alias);
				if (registeredName != null) {
					// å¦‚æœåˆ«åå¯¹åº”çš„beançš„åç§°ä¸nameç›¸åŒåˆ™å¿½ç•¥
					if (registeredName.equals(name)) {
						// An existing alias - no need to re-register
						return;
					}
					// æ˜¯å¦å…è®¸è¦†ç›–,å¦‚æœä¸å…è®¸åˆ™æŠ¥é”™
					if (!allowAliasOverriding()) {
						throw new IllegalStateException(&quot;Cannot define alias '&quot; + alias + &quot;' for name '&quot; +
								name + &quot;': It is already registered for name '&quot; + registeredName + &quot;'.&quot;);
					}
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Overriding alias '&quot; + alias + &quot;' definition for registered name '&quot; +
								registeredName + &quot;' with new target name '&quot; + name + &quot;'&quot;);
					}
				}
				//æ£€æŸ¥æ˜¯å¦æœ‰å¾ªç¯å¼•ç”¨åˆ«å ä¾‹å¦‚:A-B C-B A-C
				checkForAliasCircle(name, alias);
				//æ˜ å°„åˆ«åå’Œåç§°åˆ°mapä¸­
				this.aliasMap.put(alias, name);
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Alias definition '&quot; + alias + &quot;' registered for name '&quot; + name + &quot;'&quot;);
				}
			}
		}
	}
```

1. åˆ¤æ–­åˆ«åæ˜¯å¦ä¸beanåç§°æ˜¯å¦ç›¸åŒ
2. å¦‚æœç›¸åŒåˆ™ç§»é™¤åˆ«å
3. åˆ¤æ–­åˆ«åæ˜¯å¦å·²ç»å­˜åœ¨
4. å¦‚æœä¸å­˜åœ¨æ£€æŸ¥æ˜¯å¦å­˜åœ¨å¾ªç¯å¼•ç”¨
5. æ˜ å°„åˆ«å



â€‹	è¿™é‡Œæ£€æµ‹æ˜¯å¦å­˜åœ¨å¾ªç¯å¼•ç”¨æ¯”è¾ƒæœ‰æ„æ€,ä¹‹å‰æ–‡ç« åº”è¯¥è®°å½•åˆ°äº†è¿™å—å„¿çš„é€»è¾‘.



# ä¸‰ã€å°ç»“

â€‹	beançš„è§£æä¸æ³¨å†Œå·²ç»åˆ†æå®Œäº†,æ¥ä¸‹æ¥å°±æ˜¯é‡å¤´æˆäº†,ç»ˆäºè¦çœ‹çœ‹ spring æ˜¯æ€ä¹ˆæ ¹æ®`BeanDefinition`æ¥åˆ›å»ºbeanå¯¹è±¡.</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">ä¸€ã€å‰è¨€ â€‹ é€šè¿‡å‰é¢å¤§æ‰¹é‡çš„å·¥ä½œ,ç»ˆäºè¦åˆ°æ³¨å†ŒBeanDefinitionHolderè¿™ä¸€æ­¥äº†.å½“ç„¶è¿˜æ˜¯é€šè¿‡ä¸€ä¸‹ä»£ç ä½œä¸ºå…¥å£è¿›è¡Œåˆ†æ. protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // è§£æxmlå…ƒç´  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { // è£…é¥°bean bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. // æ³¨å†Œbeanåˆ°å®¹å™¨ä¸­ BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(&quot;Failed to register bean definition with name '&quot; + bdHolder.getBeanName() + &quot;'&quot;, ele, ex); } // Send registration event. // å‘é€äº‹ä»¶ getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } â€‹ è§£æã€è£…é¥°éƒ½å·²ç»è®°å½•äº†,è§£ææ¥çš„é‡ç‚¹å°±æ˜¯BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());è¿™å¥ä»£ç äº†. äºŒã€åˆ†æ public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { // æ³¨å†Œ bean // Register bean definition under primary name. // è·å– bean çš„åç§° String beanName = definitionHolder.getBeanName(); // æ³¨å†Œ registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); //æ³¨å†Œ bean çš„æ‰€æœ‰åˆ«å // Register aliases for bean name, if any. String[] aliases = definitionHolder.getAliases(); if (aliases != null) { for (String alias : aliases) { registry.registerAlias(beanName, alias); } } } é€šè¿‡beançš„åç§°è¿›è¡Œæ³¨å†Œ é€šè¿‡beançš„åˆ«åè¿›è¡Œæ³¨å†Œ BeanDefinitionRegistryè¿™ä¸ªå¯¹è±¡æ˜¯é€šè¿‡XmlReaderContextä¸­è·å–çš„. // XmlReaderContext public final BeanDefinitionRegistry getRegistry() { return this.reader.getRegistry(); } â€‹ è€Œè¿™ä¸ªreaderåˆ™æ˜¯XmlBeanDefinitionReader,registryå¯¹è±¡åˆ™é€šè¿‡XmlBeanDefinitionReaderçš„æ„é€ æ–¹æ³•ä¼ å…¥è¿›æ¥,å®é™…ä¸Šè¿™ä¸ªregistryå¯¹è±¡å°±æ˜¯XmlBeanFactoryæˆ–è€…è¯´æ˜¯DefaultListableBeanFactory,å› ä¸ºè¿™ä¸¤ä¸ªæœ‰ç»§æ‰¿å…³ç³». â€‹ 2.1 registerBeanDefinition // DefaultListableBeanFactory @Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { Assert.hasText(beanName, &quot;Bean name must not be empty&quot;); Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;); if (beanDefinition instanceof AbstractBeanDefinition) { try { // æ ¡éªŒ bean çš„å®šä¹‰æ˜¯å¦åˆæ³• ((AbstractBeanDefinition) beanDefinition).validate(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, &quot;Validation of bean definition failed&quot;, ex); } } // ä»ç¼“å­˜ä¸­å–å‡º BeanDefinition BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName); // bean å·²è¢«æ³¨å†Œè¿‡ if (existingDefinition != null) { // å¦‚æœä¸å…è®¸é‡å¤æ³¨å†Œåˆ™æŠ›å‡ºå¼‚å¸¸ if (!isAllowBeanDefinitionOverriding()) { throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition); } else if (existingDefinition.getRole() &amp;lt; beanDefinition.getRole()) { // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE if (logger.isInfoEnabled()) { logger.info(&quot;Overriding user-defined bean definition for bean '&quot; + beanName + &quot;' with a framework-generated bean definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); } } else if (!beanDefinition.equals(existingDefinition)) { if (logger.isDebugEnabled()) { logger.debug(&quot;Overriding bean definition for bean '&quot; + beanName + &quot;' with a different definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); } } else { if (logger.isTraceEnabled()) { logger.trace(&quot;Overriding bean definition for bean '&quot; + beanName + &quot;' with an equivalent definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); } } // æ”¾å…¥åˆ° map ä¸­ // è¦†ç›– this.beanDefinitionMap.put(beanName, beanDefinition); } else { // åˆ¤æ–­æ˜¯å¦æœ‰åˆ›å»ºä¸­çš„bean if (hasBeanCreationStarted()) { // Cannot modify startup-time collection elements anymore (for stable iteration) // åŠ é” // ä¸èƒ½ä¿®æ”¹å¯åŠ¨æ—¶çš„é›†åˆ,éœ€è¦é‡æ–°åˆ›å»ºä¸€ä¸ªé›†åˆ synchronized (this.beanDefinitionMap) { // æ”¾å…¥mapä¸­ this.beanDefinitionMap.put(beanName, beanDefinition); List&amp;lt;String&amp;gt; updatedDefinitions = new ArrayList&amp;lt;&amp;gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; // å¦‚æœè¿™ä¸ªå·²ç» bean åœ¨å­˜åœ¨ åˆ™ç§»é™¤ removeManualSingletonName(beanName); } } else { // Still in startup registration phase this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); // å¦‚æœè¿™ä¸ªå·²ç» bean åœ¨å­˜åœ¨ åˆ™ç§»é™¤ removeManualSingletonName(beanName); } this.frozenBeanDefinitionNames = null; } //æ³¨å†ŒæˆåŠŸ,å¦‚æœæ˜¯é‡å¤æ³¨å†Œçš„åˆ™é”€æ¯ä¹‹å‰æ³¨å†Œçš„bean if (existingDefinition != null || containsSingleton(beanName)) { resetBeanDefinition(beanName); } } â€‹ è¿™ä¸ªé˜¶æ®µå‘¢,beanéƒ½è¿˜æ²¡å¼€å§‹åˆ›å»º,éƒ½æ˜¯åœ¨åšè§£æ,æ³¨å†Œä¹‹ç±»çš„äº‹æƒ…,æ‰€ä»¥è¿™é‡Œæœ‰ä¸€ä¸ªåˆ¤æ–­çœ‹èµ·æ¥æ¯”è¾ƒè¿·æƒ‘hasBeanCreationStarted.æˆ–è®¸åé¢æ‰ä¼šçŸ¥é“è¿™ä¸ªåˆ¤æ–­æ¡ä»¶æœ‰å•¥ç”¨å§. éªŒè¯beanDefinitionæ˜¯å¦åˆæ³• 2. åˆ¤æ–­beanæ˜¯å¦è¢«æ³¨å†Œè¿‡,å¦‚æœä¸å…è®¸é‡å¤æ³¨å†Œåˆ™æŠ›å‡ºå¼‚å¸¸ 3. å¦‚æœå…è®¸é‡å¤æ³¨å†Œåˆ™æ”¾å…¥beanDefinitionMapè¿™ä¸ªmapé›†åˆä¸­ 4. å¦‚æœè¯¥beanDefinitionæœªè¢«æ³¨å†Œè¿‡,åˆ™æ·»åŠ æ˜ å°„åˆ°beanDefinitionMapä¸­å»å’ŒbeanDefinitionNamesé›†åˆä¸­å». 5. æ³¨å†ŒæˆåŠŸ,å¦‚æœæ˜¯é‡å¤æ³¨å†Œçš„åˆ™é”€æ¯ä¹‹å‰æ³¨å†Œçš„bean 2.2 registerAlias // SimpleAliasRegistry @Override public void registerAlias(String name, String alias) { Assert.hasText(name, &quot;'name' must not be empty&quot;); Assert.hasText(alias, &quot;'alias' must not be empty&quot;); // åŠ é” å¹¶å‘æ§åˆ¶ synchronized (this.aliasMap) { // åˆ¤æ–­ bean åç§°æ˜¯å¦ä¸åˆ«åç›¸åŒ,å¦‚æœç›¸åŒåˆ™å¿½ç•¥ if (alias.equals(name)) { // ç§»é™¤åˆ«å this.aliasMap.remove(alias); if (logger.isDebugEnabled()) { logger.debug(&quot;Alias definition '&quot; + alias + &quot;' ignored since it points to same name&quot;); } } else { // åˆ¤æ–­åˆ«åæ˜¯å¦å·²å­˜åœ¨ String registeredName = this.aliasMap.get(alias); if (registeredName != null) { // å¦‚æœåˆ«åå¯¹åº”çš„beançš„åç§°ä¸nameç›¸åŒåˆ™å¿½ç•¥ if (registeredName.equals(name)) { // An existing alias - no need to re-register return; } // æ˜¯å¦å…è®¸è¦†ç›–,å¦‚æœä¸å…è®¸åˆ™æŠ¥é”™ if (!allowAliasOverriding()) { throw new IllegalStateException(&quot;Cannot define alias '&quot; + alias + &quot;' for name '&quot; + name + &quot;': It is already registered for name '&quot; + registeredName + &quot;'.&quot;); } if (logger.isDebugEnabled()) { logger.debug(&quot;Overriding alias '&quot; + alias + &quot;' definition for registered name '&quot; + registeredName + &quot;' with new target name '&quot; + name + &quot;'&quot;); } } //æ£€æŸ¥æ˜¯å¦æœ‰å¾ªç¯å¼•ç”¨åˆ«å ä¾‹å¦‚:A-B C-B A-C checkForAliasCircle(name, alias); //æ˜ å°„åˆ«åå’Œåç§°åˆ°mapä¸­ this.aliasMap.put(alias, name); if (logger.isTraceEnabled()) { logger.trace(&quot;Alias definition '&quot; + alias + &quot;' registered for name '&quot; + name + &quot;'&quot;); } } } } åˆ¤æ–­åˆ«åæ˜¯å¦ä¸beanåç§°æ˜¯å¦ç›¸åŒ å¦‚æœç›¸åŒåˆ™ç§»é™¤åˆ«å åˆ¤æ–­åˆ«åæ˜¯å¦å·²ç»å­˜åœ¨ å¦‚æœä¸å­˜åœ¨æ£€æŸ¥æ˜¯å¦å­˜åœ¨å¾ªç¯å¼•ç”¨ æ˜ å°„åˆ«å â€‹ è¿™é‡Œæ£€æµ‹æ˜¯å¦å­˜åœ¨å¾ªç¯å¼•ç”¨æ¯”è¾ƒæœ‰æ„æ€,ä¹‹å‰æ–‡ç« åº”è¯¥è®°å½•åˆ°äº†è¿™å—å„¿çš„é€»è¾‘. ä¸‰ã€å°ç»“ â€‹ beançš„è§£æä¸æ³¨å†Œå·²ç»åˆ†æå®Œäº†,æ¥ä¸‹æ¥å°±æ˜¯é‡å¤´æˆäº†,ç»ˆäºè¦çœ‹çœ‹ spring æ˜¯æ€ä¹ˆæ ¹æ®BeanDefinitionæ¥åˆ›å»ºbeanå¯¹è±¡.</summary></entry><entry><title type="html">[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-BeanDefinitionHolderè£…é¥°(å…­)</title><link href="https://onew.me/spring/2020/03/01/debug-spring-6.html" rel="alternate" type="text/html" title="[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-BeanDefinitionHolderè£…é¥°(å…­)" /><published>2020-03-01T14:20:25+08:00</published><updated>2020-03-01T14:20:25+08:00</updated><id>https://onew.me/spring/2020/03/01/debug-spring-6</id><content type="html" xml:base="https://onew.me/spring/2020/03/01/debug-spring-6.html"># ä¸€ã€å‰è¨€

â€‹	åœ¨xmlæ ‡ç­¾è§£æå®Œä¹‹åä¼šäº§ç”Ÿä¸€ä¸ª`BeanDefinitionHolder`å¯¹è±¡,ç´§æ¥ç€å°±æ¥è°ˆè°ˆ,`spring`ç”¨è¿™ä¸ªå¯¹è±¡æ¥å¹²å˜›å§.

```java
//DefaultBeanDefinitionDocumentReader.java
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
		// è§£æxmlå…ƒç´  
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
		if (bdHolder != null) {
			// è£…é¥°
			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
			try {
				// Register the final decorated instance.
				// æ³¨å†Œåˆ°å®¹å™¨ä¸­
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
						bdHolder.getBeanName() + &quot;'&quot;, ele, ex);
			}
			// Send registration event.
			// å‘é€äº‹ä»¶
			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
		}
	}
```

â€‹	è§£æxmlè¿™è¾¹å·²ç»è®°å½•è¿‡äº†,æ¥ä¸‹æ¥çš„é‡ç‚¹åœ¨äº`delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);`,ä»æ–¹æ³•åå¯ä»¥çœ‹å‡ºæ„æ€å¤§æ¦‚ä¸º:å¦‚æœæœ‰å¿…è¦å°±è¿›è¡Œè£…é¥°.è¯´åˆ°è£…é¥°æ„Ÿè§‰è·Ÿè£…é¥°æ¨¡å¼æœ‰å…³.



# äºŒã€åˆ†æ

```java
public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef) {
		return decorateBeanDefinitionIfRequired(ele, originalDef, null);
	}

	/**
	 * Decorate the given bean definition through a namespace handler, if applicable.
	 * @param ele the current element
	 * @param originalDef the current bean definition
	 * @param containingBd the containing bean definition (if any)
	 * @return the decorated bean definition
	 */
	public BeanDefinitionHolder decorateBeanDefinitionIfRequired(
			Element ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {

		BeanDefinitionHolder finalDefinition = originalDef;
		// éå†èŠ‚ç‚¹,å¯»æ‰¾å¯ä»¥è£…é¥°çš„å±æ€§
		// Decorate based on custom attributes first.
		NamedNodeMap attributes = ele.getAttributes();
		for (int i = 0; i &lt; attributes.getLength(); i++) {
			Node node = attributes.item(i);
			finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);
		}
		// éå†å­èŠ‚ç‚¹,å¯»æ‰¾å¯ä»¥è£…é¥°çš„å­èŠ‚ç‚¹
		// Decorate based on custom nested elements.
		NodeList children = ele.getChildNodes();
		for (int i = 0; i &lt; children.getLength(); i++) {
			Node node = children.item(i);
			if (node.getNodeType() == Node.ELEMENT_NODE) {
				finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);
			}
		}
		return finalDefinition;
	}
```

1. éå†å½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰å±æ€§è¿›è¡Œè£…é¥°
2. éå†å½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹è¿›è¡Œè£…é¥°
3. è¿”å›`BeanDefinitionHolder`



â€‹	ä»ä¸Šé¢å¯ä»¥çœ‹åˆ°æ ¸å¿ƒæ–¹æ³•åœ¨äº`decorateIfRequired`,è¿›å»çœ‹ä¸€çœ‹.

## 2.1 decorateIfRequired

```java
public BeanDefinitionHolder decorateIfRequired(
			Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {
		// è·å–åç§°ç©ºé—´URI
		String namespaceUri = getNamespaceURI(node);
		// åˆ¤æ–­æ˜¯å¦æ˜¯è‡ªå®šä¹‰åç§°ç©ºé—´,åªå¯¹è‡ªå®šä¹‰åç§°ç©ºé—´è¿›è¡Œå¤„ç†
		if (namespaceUri != null &amp;&amp; !isDefaultNamespace(namespaceUri)) {
			// è·å–åç§°ç©ºé—´å¯¹åº”çš„å¤„ç†å™¨
			NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
			if (handler != null) {
				// è¿›è¡Œè£…é¥°å¤„ç†
				BeanDefinitionHolder decorated =
						handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));
				if (decorated != null) {
					return decorated;
				}
			}
			else if (namespaceUri.startsWith(&quot;http://www.springframework.org/schema/&quot;)) {
				error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, node);
			}
			else {
				// A custom namespace, not to be handled by Spring - maybe &quot;xml:...&quot;.
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;No Spring NamespaceHandler found for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;);
				}
			}
		}
		return originalDef;
	}
```

1. åˆ¤æ–­æ˜¯å¦æ˜¯é»˜è®¤åç§°å‘½åç©ºé—´
2. éé»˜è®¤è¿›è¡Œè£…é¥°å¤„ç†



â€‹	é‚£ä¹ˆè¿™ä¸ªè£…é¥°æ˜¯ä¸ªä»€ä¹ˆé¬¼å‘¢ï¼Ÿé€šè¿‡åˆ¤æ–­æ˜¯å¦æ˜¯é»˜è®¤åç§°ç©ºé—´è¿™ä¸ªæ¡ä»¶æ„Ÿè§‰åœ¨å‰é¢åˆ†æçš„æ—¶å€™é‡åˆ°è¿‡.ä»è¿™ä¸ªæ¡ä»¶å¯ä»¥çœ‹å‡ºè¿™ä¸ªé€»è¾‘ä¸æœ€åè¾¾åˆ°çš„æ•ˆæœä¸å‰é¢è‡ªå®šä¹‰æ ‡ç­¾æ˜¯ä¸€å›äº‹.å¯ä»¥çœ‹çœ‹å®˜æ–¹ç»™å‡ºçš„ä¾‹å­.

- ç”¨äºæµ‹è¯•çš„xml

```xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	   xmlns:test=&quot;http://www.springframework.org/schema/beans/test&quot;
	   xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
	   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-2.0.xsd
       http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util-2.0.xsd
       http://www.springframework.org/schema/beans/test https://www.springframework.org/schema/beans/factory/xml/support/CustomNamespaceHandlerTests.xsd&quot;
	default-lazy-init=&quot;true&quot;&gt;

	&lt;test:testBean id=&quot;testBean&quot; name=&quot;Rob Harrop&quot; age=&quot;23&quot;/&gt;

	&lt;bean id=&quot;customisedTestBean&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot;&gt;
		&lt;test:set name=&quot;Rob Harrop&quot; age=&quot;23&quot;/&gt;
	&lt;/bean&gt;

	&lt;bean id=&quot;debuggingTestBean&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot;&gt;
		&lt;test:debug/&gt;
		&lt;property name=&quot;name&quot; value=&quot;Rob Harrop&quot;/&gt;
		&lt;property name=&quot;age&quot; value=&quot;23&quot;/&gt;
	&lt;/bean&gt;

	&lt;bean id=&quot;debuggingTestBeanNoInstance&quot; class=&quot;org.springframework.context.ApplicationListener&quot;&gt;
		&lt;test:debug/&gt;
	&lt;/bean&gt;

	&lt;bean id=&quot;chainedTestBean&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot;&gt;
		&lt;test:debug/&gt;
		&lt;test:nop/&gt;
		&lt;property name=&quot;name&quot; value=&quot;Rob Harrop&quot;/&gt;
		&lt;property name=&quot;age&quot; value=&quot;23&quot;/&gt;
	&lt;/bean&gt;

	&lt;bean id=&quot;decorateWithAttribute&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot; test:object-name=&quot;foo&quot;/&gt;

	&lt;util:list id=&quot;list.of.things&quot;&gt;
		&lt;test:person name=&quot;Fiona Apple&quot; age=&quot;20&quot;/&gt;
		&lt;test:person name=&quot;Harriet Wheeler&quot; age=&quot;30&quot;/&gt;
	&lt;/util:list&gt;

	&lt;util:set id=&quot;set.of.things&quot;&gt;
		&lt;test:person name=&quot;Fiona Apple&quot; age=&quot;20&quot;/&gt;
		&lt;test:person name=&quot;Harriet Wheeler&quot; age=&quot;30&quot;/&gt;
	&lt;/util:set&gt;

	&lt;util:map id=&quot;map.of.things&quot;&gt;
		&lt;entry key=&quot;fiona.apple&quot;&gt;
			&lt;test:person name=&quot;Fiona Apple&quot; age=&quot;20&quot;/&gt;
		&lt;/entry&gt;
		&lt;entry key=&quot;harriet.wheeler&quot;&gt;
			&lt;test:person name=&quot;Harriet Wheeler&quot; age=&quot;30&quot;/&gt;
		&lt;/entry&gt;
	&lt;/util:map&gt;

&lt;/beans&gt;


```

- ç”¨äºæµ‹è¯•çš„xsdæ–‡ä»¶

```xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;

&lt;xsd:schema xmlns=&quot;http://www.springframework.org/schema/beans/test&quot;
			xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
			targetNamespace=&quot;http://www.springframework.org/schema/beans/test&quot;
			elementFormDefault=&quot;qualified&quot;&gt;
	
	&lt;xsd:element name=&quot;person&quot;&gt;
		&lt;xsd:complexType&gt;
			&lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:string&quot; use=&quot;optional&quot; form=&quot;unqualified&quot;/&gt;
			&lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&gt;
			&lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:integer&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&gt;
		&lt;/xsd:complexType&gt;
	&lt;/xsd:element&gt;

	&lt;xsd:element name=&quot;testBean&quot;&gt;
		&lt;xsd:complexType&gt;
			&lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&gt;
			&lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&gt;
			&lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:integer&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&gt;
		&lt;/xsd:complexType&gt;
	&lt;/xsd:element&gt;

	&lt;xsd:element name=&quot;set&quot;&gt;
		&lt;xsd:complexType&gt;
			&lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&gt;
			&lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:integer&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&gt;
		&lt;/xsd:complexType&gt;
	&lt;/xsd:element&gt;

	&lt;xsd:element name=&quot;debug&quot;/&gt;
	&lt;xsd:element name=&quot;nop&quot;/&gt;

	&lt;xsd:attribute name=&quot;object-name&quot; type=&quot;xsd:string&quot;/&gt;

&lt;/xsd:schema&gt;

```

- ç”¨äºæµ‹è¯•çš„propertyæ–‡ä»¶

```properties
http\://www.springframework.org/schema/beans/test=org.springframework.beans.factory.xml.support.TestNamespaceHandler
http\://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler
```

- æµ‹è¯•ä»£ç 

```java
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.beans.factory.xml.support;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;

import org.springframework.aop.Advisor;
import org.springframework.aop.config.AbstractInterceptorDrivenBeanDefinitionDecorator;
import org.springframework.aop.framework.Advised;
import org.springframework.aop.interceptor.DebugInterceptor;
import org.springframework.aop.support.AopUtils;
import org.springframework.beans.BeanInstantiationException;
import org.springframework.beans.MutablePropertyValues;
import org.springframework.beans.factory.BeanCreationException;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanDefinitionHolder;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
import org.springframework.beans.factory.xml.BeanDefinitionDecorator;
import org.springframework.beans.factory.xml.BeanDefinitionParser;
import org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver;
import org.springframework.beans.factory.xml.NamespaceHandlerResolver;
import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.beans.factory.xml.PluggableSchemaResolver;
import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;
import org.springframework.context.ApplicationListener;
import org.springframework.context.support.GenericApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.tests.aop.interceptor.NopInterceptor;
import org.springframework.tests.sample.beans.ITestBean;
import org.springframework.tests.sample.beans.TestBean;

import static java.lang.String.format;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

/**
 * Unit tests for custom XML namespace handler implementations.
 *
 * @author Rob Harrop
 * @author Rick Evans
 * @author Chris Beams
 * @author Juergen Hoeller
 */
public class CustomNamespaceHandlerTests {

	private static final Class&lt;?&gt; CLASS = CustomNamespaceHandlerTests.class;
	private static final String CLASSNAME = CLASS.getSimpleName();
	private static final String FQ_PATH = &quot;org/springframework/beans/factory/xml/support&quot;;

	private static final String NS_PROPS = format(&quot;%s/%s.properties&quot;, FQ_PATH, CLASSNAME);
	private static final String NS_XML = format(&quot;%s/%s-context.xml&quot;, FQ_PATH, CLASSNAME);
	private static final String TEST_XSD = format(&quot;%s/%s.xsd&quot;, FQ_PATH, CLASSNAME);

	private GenericApplicationContext beanFactory;


	@BeforeEach
	public void setUp() throws Exception {
		NamespaceHandlerResolver resolver = new DefaultNamespaceHandlerResolver(CLASS.getClassLoader(), NS_PROPS);
		this.beanFactory = new GenericApplicationContext();
		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this.beanFactory);
		reader.setNamespaceHandlerResolver(resolver);
		reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_XSD);
		reader.setEntityResolver(new DummySchemaResolver());
		reader.loadBeanDefinitions(getResource());
		this.beanFactory.refresh();
	}


	@Test
	public void testSimpleParser() throws Exception {
		TestBean bean = (TestBean) this.beanFactory.getBean(&quot;testBean&quot;);
		assertTestBean(bean);
	}

	@Test
	public void testSimpleDecorator() throws Exception {
		TestBean bean = (TestBean) this.beanFactory.getBean(&quot;customisedTestBean&quot;);
		assertTestBean(bean);
	}

	@Test
	public void testProxyingDecorator() throws Exception {
		ITestBean bean = (ITestBean) this.beanFactory.getBean(&quot;debuggingTestBean&quot;);
		assertTestBean(bean);
		assertThat(AopUtils.isAopProxy(bean)).isTrue();
		Advisor[] advisors = ((Advised) bean).getAdvisors();
		assertThat(advisors.length).as(&quot;Incorrect number of advisors&quot;).isEqualTo(1);
		assertThat(advisors[0].getAdvice().getClass()).as(&quot;Incorrect advice class&quot;).isEqualTo(DebugInterceptor.class);
	}

	@Test
	public void testProxyingDecoratorNoInstance() throws Exception {
		String[] beanNames = this.beanFactory.getBeanNamesForType(ApplicationListener.class);
		assertThat(Arrays.asList(beanNames).contains(&quot;debuggingTestBeanNoInstance&quot;)).isTrue();
		assertThat(this.beanFactory.getType(&quot;debuggingTestBeanNoInstance&quot;)).isEqualTo(ApplicationListener.class);
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(() -&gt;
				this.beanFactory.getBean(&quot;debuggingTestBeanNoInstance&quot;))
			.satisfies(ex -&gt; assertThat(ex.getRootCause()).isInstanceOf(BeanInstantiationException.class));
	}

	@Test
	public void testChainedDecorators() throws Exception {
		ITestBean bean = (ITestBean) this.beanFactory.getBean(&quot;chainedTestBean&quot;);
		assertTestBean(bean);
		assertThat(AopUtils.isAopProxy(bean)).isTrue();
		Advisor[] advisors = ((Advised) bean).getAdvisors();
		assertThat(advisors.length).as(&quot;Incorrect number of advisors&quot;).isEqualTo(2);
		assertThat(advisors[0].getAdvice().getClass()).as(&quot;Incorrect advice class&quot;).isEqualTo(DebugInterceptor.class);
		assertThat(advisors[1].getAdvice().getClass()).as(&quot;Incorrect advice class&quot;).isEqualTo(NopInterceptor.class);
	}

	@Test
	public void testDecorationViaAttribute() throws Exception {
		BeanDefinition beanDefinition = this.beanFactory.getBeanDefinition(&quot;decorateWithAttribute&quot;);
		assertThat(beanDefinition.getAttribute(&quot;objectName&quot;)).isEqualTo(&quot;foo&quot;);
	}

	@Test  // SPR-2728
	public void testCustomElementNestedWithinUtilList() throws Exception {
		List&lt;?&gt; things = (List&lt;?&gt;) this.beanFactory.getBean(&quot;list.of.things&quot;);
		assertThat(things).isNotNull();
		assertThat(things.size()).isEqualTo(2);
	}

	@Test  // SPR-2728
	public void testCustomElementNestedWithinUtilSet() throws Exception {
		Set&lt;?&gt; things = (Set&lt;?&gt;) this.beanFactory.getBean(&quot;set.of.things&quot;);
		assertThat(things).isNotNull();
		assertThat(things.size()).isEqualTo(2);
	}

	@Test  // SPR-2728
	public void testCustomElementNestedWithinUtilMap() throws Exception {
		Map&lt;?, ?&gt; things = (Map&lt;?, ?&gt;) this.beanFactory.getBean(&quot;map.of.things&quot;);
		assertThat(things).isNotNull();
		assertThat(things.size()).isEqualTo(2);
	}


	private void assertTestBean(ITestBean bean) {
		assertThat(bean.getName()).as(&quot;Invalid name&quot;).isEqualTo(&quot;Rob Harrop&quot;);
		assertThat(bean.getAge()).as(&quot;Invalid age&quot;).isEqualTo(23);
	}

	private Resource getResource() {
		return new ClassPathResource(NS_XML);
	}


	private final class DummySchemaResolver extends PluggableSchemaResolver {

		public DummySchemaResolver() {
			super(CLASS.getClassLoader());
		}

		@Override
		public InputSource resolveEntity(String publicId, String systemId) throws IOException {
			InputSource source = super.resolveEntity(publicId, systemId);
			if (source == null) {
				Resource resource = new ClassPathResource(TEST_XSD);
				source = new InputSource(resource.getInputStream());
				source.setPublicId(publicId);
				source.setSystemId(systemId);
			}
			return source;
		}
	}

}


/**
 * Custom namespace handler implementation.
 *	è‡ªå®šä¹‰åç§°ç©ºé—´å¤„ç†å™¨
 * @author Rob Harrop
 */
final class TestNamespaceHandler extends NamespaceHandlerSupport {

	@Override
	public void init() {
    // æ³¨å†ŒèŠ‚ç‚¹ä¸º testBean çš„è§£æå™¨
		registerBeanDefinitionParser(&quot;testBean&quot;, new TestBeanDefinitionParser());
    // æ³¨å†ŒèŠ‚ç‚¹ä¸º person çš„è§£æå™¨
		registerBeanDefinitionParser(&quot;person&quot;, new PersonDefinitionParser());
		
    // æ³¨å†Œ set è£…é¥°å™¨
		registerBeanDefinitionDecorator(&quot;set&quot;, new PropertyModifyingBeanDefinitionDecorator());
    // æ³¨å†Œ debug è£…é¥°å™¨
		registerBeanDefinitionDecorator(&quot;debug&quot;, new DebugBeanDefinitionDecorator());
    // æ³¨å†Œ nop è£…é¥°å™¨
		registerBeanDefinitionDecorator(&quot;nop&quot;, new NopInterceptorBeanDefinitionDecorator());
    // æ³¨å†Œ å±æ€§ä¸º object-name çš„è£…é¥°å™¨
		registerBeanDefinitionDecoratorForAttribute(&quot;object-name&quot;, new ObjectNameBeanDefinitionDecorator());
	}

	// èŠ‚ç‚¹ä¸º testBean çš„è§£æå™¨
	private static class TestBeanDefinitionParser implements BeanDefinitionParser {

		@Override
		public BeanDefinition parse(Element element, ParserContext parserContext) {
			RootBeanDefinition definition = new RootBeanDefinition();
			definition.setBeanClass(TestBean.class);

			MutablePropertyValues mpvs = new MutablePropertyValues();
			mpvs.add(&quot;name&quot;, element.getAttribute(&quot;name&quot;));
			mpvs.add(&quot;age&quot;, element.getAttribute(&quot;age&quot;));
			definition.setPropertyValues(mpvs);

			parserContext.getRegistry().registerBeanDefinition(element.getAttribute(&quot;id&quot;), definition);
			return null;
		}
	}

	// èŠ‚ç‚¹ä¸º person çš„è§£æå™¨
	private static final class PersonDefinitionParser extends AbstractSingleBeanDefinitionParser {

		@Override
		protected Class&lt;?&gt; getBeanClass(Element element) {
			return TestBean.class;
		}

		@Override
		protected void doParse(Element element, BeanDefinitionBuilder builder) {
			builder.addPropertyValue(&quot;name&quot;, element.getAttribute(&quot;name&quot;));
			builder.addPropertyValue(&quot;age&quot;, element.getAttribute(&quot;age&quot;));
		}
	}

	// set è£…é¥°å™¨
	private static class PropertyModifyingBeanDefinitionDecorator implements BeanDefinitionDecorator {

		@Override
		public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {
			Element element = (Element) node;
			BeanDefinition def = definition.getBeanDefinition();

			MutablePropertyValues mpvs = (def.getPropertyValues() == null) ? new MutablePropertyValues() : def.getPropertyValues();
			mpvs.add(&quot;name&quot;, element.getAttribute(&quot;name&quot;));
			mpvs.add(&quot;age&quot;, element.getAttribute(&quot;age&quot;));

			((AbstractBeanDefinition) def).setPropertyValues(mpvs);
			return definition;
		}
	}

	// debug è£…é¥°å™¨
	private static class DebugBeanDefinitionDecorator extends AbstractInterceptorDrivenBeanDefinitionDecorator {

		@Override
		protected BeanDefinition createInterceptorDefinition(Node node) {
			return new RootBeanDefinition(DebugInterceptor.class);
		}
	}

	// nop è£…é¥°å™¨
	private static class NopInterceptorBeanDefinitionDecorator extends AbstractInterceptorDrivenBeanDefinitionDecorator {

		@Override
		protected BeanDefinition createInterceptorDefinition(Node node) {
			return new RootBeanDefinition(NopInterceptor.class);
		}
	}

	// å±æ€§ä¸º object-name çš„è£…é¥°å™¨
	private static class ObjectNameBeanDefinitionDecorator implements BeanDefinitionDecorator {

		@Override
		public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {
			Attr objectNameAttribute = (Attr) node;
			definition.getBeanDefinition().setAttribute(&quot;objectName&quot;, objectNameAttribute.getValue());
			return definition;
		}
	}

}

```

é€šè¿‡è¿è¡Œç»“æœå¯ä»¥çœ‹å‡ºè¿™ä¸ªè£…é¥°å™¨å¯ä»¥é’ˆå¯¹ä¸èŠ‚ç‚¹æˆ–è€…å±æ€§è¿›è¡Œæ“ä½œ,ç›¸å½“äºIOæµä¸­çš„è®¾è®¡æ¨¡å¼ä¸€æ ·,è¿›è¡Œé¢å¤–çš„å¢å¼º.



# ä¸‰ã€å°ç»“

â€‹	è§£æè¿‡äº†,ä¹Ÿè£…é¥°è¿‡äº†,é‚£å°±å¯ä»¥æ³¨å†Œ`BeanDefinitionHolder`å¯¹è±¡äº†.</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">ä¸€ã€å‰è¨€ â€‹ åœ¨xmlæ ‡ç­¾è§£æå®Œä¹‹åä¼šäº§ç”Ÿä¸€ä¸ªBeanDefinitionHolderå¯¹è±¡,ç´§æ¥ç€å°±æ¥è°ˆè°ˆ,springç”¨è¿™ä¸ªå¯¹è±¡æ¥å¹²å˜›å§. //DefaultBeanDefinitionDocumentReader.java protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // è§£æxmlå…ƒç´  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { // è£…é¥° bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. // æ³¨å†Œåˆ°å®¹å™¨ä¸­ BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(&quot;Failed to register bean definition with name '&quot; + bdHolder.getBeanName() + &quot;'&quot;, ele, ex); } // Send registration event. // å‘é€äº‹ä»¶ getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } â€‹ è§£æxmlè¿™è¾¹å·²ç»è®°å½•è¿‡äº†,æ¥ä¸‹æ¥çš„é‡ç‚¹åœ¨äºdelegate.decorateBeanDefinitionIfRequired(ele, bdHolder);,ä»æ–¹æ³•åå¯ä»¥çœ‹å‡ºæ„æ€å¤§æ¦‚ä¸º:å¦‚æœæœ‰å¿…è¦å°±è¿›è¡Œè£…é¥°.è¯´åˆ°è£…é¥°æ„Ÿè§‰è·Ÿè£…é¥°æ¨¡å¼æœ‰å…³. äºŒã€åˆ†æ public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef) { return decorateBeanDefinitionIfRequired(ele, originalDef, null); } /** * Decorate the given bean definition through a namespace handler, if applicable. * @param ele the current element * @param originalDef the current bean definition * @param containingBd the containing bean definition (if any) * @return the decorated bean definition */ public BeanDefinitionHolder decorateBeanDefinitionIfRequired( Element ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) { BeanDefinitionHolder finalDefinition = originalDef; // éå†èŠ‚ç‚¹,å¯»æ‰¾å¯ä»¥è£…é¥°çš„å±æ€§ // Decorate based on custom attributes first. NamedNodeMap attributes = ele.getAttributes(); for (int i = 0; i &amp;lt; attributes.getLength(); i++) { Node node = attributes.item(i); finalDefinition = decorateIfRequired(node, finalDefinition, containingBd); } // éå†å­èŠ‚ç‚¹,å¯»æ‰¾å¯ä»¥è£…é¥°çš„å­èŠ‚ç‚¹ // Decorate based on custom nested elements. NodeList children = ele.getChildNodes(); for (int i = 0; i &amp;lt; children.getLength(); i++) { Node node = children.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) { finalDefinition = decorateIfRequired(node, finalDefinition, containingBd); } } return finalDefinition; } éå†å½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰å±æ€§è¿›è¡Œè£…é¥° éå†å½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹è¿›è¡Œè£…é¥° è¿”å›BeanDefinitionHolder â€‹ ä»ä¸Šé¢å¯ä»¥çœ‹åˆ°æ ¸å¿ƒæ–¹æ³•åœ¨äºdecorateIfRequired,è¿›å»çœ‹ä¸€çœ‹. 2.1 decorateIfRequired public BeanDefinitionHolder decorateIfRequired( Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) { // è·å–åç§°ç©ºé—´URI String namespaceUri = getNamespaceURI(node); // åˆ¤æ–­æ˜¯å¦æ˜¯è‡ªå®šä¹‰åç§°ç©ºé—´,åªå¯¹è‡ªå®šä¹‰åç§°ç©ºé—´è¿›è¡Œå¤„ç† if (namespaceUri != null &amp;amp;&amp;amp; !isDefaultNamespace(namespaceUri)) { // è·å–åç§°ç©ºé—´å¯¹åº”çš„å¤„ç†å™¨ NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler != null) { // è¿›è¡Œè£…é¥°å¤„ç† BeanDefinitionHolder decorated = handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd)); if (decorated != null) { return decorated; } } else if (namespaceUri.startsWith(&quot;http://www.springframework.org/schema/&quot;)) { error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, node); } else { // A custom namespace, not to be handled by Spring - maybe &quot;xml:...&quot;. if (logger.isDebugEnabled()) { logger.debug(&quot;No Spring NamespaceHandler found for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;); } } } return originalDef; } åˆ¤æ–­æ˜¯å¦æ˜¯é»˜è®¤åç§°å‘½åç©ºé—´ éé»˜è®¤è¿›è¡Œè£…é¥°å¤„ç† â€‹ é‚£ä¹ˆè¿™ä¸ªè£…é¥°æ˜¯ä¸ªä»€ä¹ˆé¬¼å‘¢ï¼Ÿé€šè¿‡åˆ¤æ–­æ˜¯å¦æ˜¯é»˜è®¤åç§°ç©ºé—´è¿™ä¸ªæ¡ä»¶æ„Ÿè§‰åœ¨å‰é¢åˆ†æçš„æ—¶å€™é‡åˆ°è¿‡.ä»è¿™ä¸ªæ¡ä»¶å¯ä»¥çœ‹å‡ºè¿™ä¸ªé€»è¾‘ä¸æœ€åè¾¾åˆ°çš„æ•ˆæœä¸å‰é¢è‡ªå®šä¹‰æ ‡ç­¾æ˜¯ä¸€å›äº‹.å¯ä»¥çœ‹çœ‹å®˜æ–¹ç»™å‡ºçš„ä¾‹å­. ç”¨äºæµ‹è¯•çš„xml &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:test=&quot;http://www.springframework.org/schema/beans/test&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util-2.0.xsd http://www.springframework.org/schema/beans/test https://www.springframework.org/schema/beans/factory/xml/support/CustomNamespaceHandlerTests.xsd&quot; default-lazy-init=&quot;true&quot;&amp;gt; &amp;lt;test:testBean id=&quot;testBean&quot; name=&quot;Rob Harrop&quot; age=&quot;23&quot;/&amp;gt; &amp;lt;bean id=&quot;customisedTestBean&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot;&amp;gt; &amp;lt;test:set name=&quot;Rob Harrop&quot; age=&quot;23&quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&quot;debuggingTestBean&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot;&amp;gt; &amp;lt;test:debug/&amp;gt; &amp;lt;property name=&quot;name&quot; value=&quot;Rob Harrop&quot;/&amp;gt; &amp;lt;property name=&quot;age&quot; value=&quot;23&quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&quot;debuggingTestBeanNoInstance&quot; class=&quot;org.springframework.context.ApplicationListener&quot;&amp;gt; &amp;lt;test:debug/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&quot;chainedTestBean&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot;&amp;gt; &amp;lt;test:debug/&amp;gt; &amp;lt;test:nop/&amp;gt; &amp;lt;property name=&quot;name&quot; value=&quot;Rob Harrop&quot;/&amp;gt; &amp;lt;property name=&quot;age&quot; value=&quot;23&quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&quot;decorateWithAttribute&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot; test:object-name=&quot;foo&quot;/&amp;gt; &amp;lt;util:list id=&quot;list.of.things&quot;&amp;gt; &amp;lt;test:person name=&quot;Fiona Apple&quot; age=&quot;20&quot;/&amp;gt; &amp;lt;test:person name=&quot;Harriet Wheeler&quot; age=&quot;30&quot;/&amp;gt; &amp;lt;/util:list&amp;gt; &amp;lt;util:set id=&quot;set.of.things&quot;&amp;gt; &amp;lt;test:person name=&quot;Fiona Apple&quot; age=&quot;20&quot;/&amp;gt; &amp;lt;test:person name=&quot;Harriet Wheeler&quot; age=&quot;30&quot;/&amp;gt; &amp;lt;/util:set&amp;gt; &amp;lt;util:map id=&quot;map.of.things&quot;&amp;gt; &amp;lt;entry key=&quot;fiona.apple&quot;&amp;gt; &amp;lt;test:person name=&quot;Fiona Apple&quot; age=&quot;20&quot;/&amp;gt; &amp;lt;/entry&amp;gt; &amp;lt;entry key=&quot;harriet.wheeler&quot;&amp;gt; &amp;lt;test:person name=&quot;Harriet Wheeler&quot; age=&quot;30&quot;/&amp;gt; &amp;lt;/entry&amp;gt; &amp;lt;/util:map&amp;gt; &amp;lt;/beans&amp;gt; ç”¨äºæµ‹è¯•çš„xsdæ–‡ä»¶ &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&amp;gt; &amp;lt;xsd:schema xmlns=&quot;http://www.springframework.org/schema/beans/test&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://www.springframework.org/schema/beans/test&quot; elementFormDefault=&quot;qualified&quot;&amp;gt; &amp;lt;xsd:element name=&quot;person&quot;&amp;gt; &amp;lt;xsd:complexType&amp;gt; &amp;lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:string&quot; use=&quot;optional&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:integer&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;/xsd:complexType&amp;gt; &amp;lt;/xsd:element&amp;gt; &amp;lt;xsd:element name=&quot;testBean&quot;&amp;gt; &amp;lt;xsd:complexType&amp;gt; &amp;lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:integer&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;/xsd:complexType&amp;gt; &amp;lt;/xsd:element&amp;gt; &amp;lt;xsd:element name=&quot;set&quot;&amp;gt; &amp;lt;xsd:complexType&amp;gt; &amp;lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:integer&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;/xsd:complexType&amp;gt; &amp;lt;/xsd:element&amp;gt; &amp;lt;xsd:element name=&quot;debug&quot;/&amp;gt; &amp;lt;xsd:element name=&quot;nop&quot;/&amp;gt; &amp;lt;xsd:attribute name=&quot;object-name&quot; type=&quot;xsd:string&quot;/&amp;gt; &amp;lt;/xsd:schema&amp;gt; ç”¨äºæµ‹è¯•çš„propertyæ–‡ä»¶ http\://www.springframework.org/schema/beans/test=org.springframework.beans.factory.xml.support.TestNamespaceHandler http\://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler æµ‹è¯•ä»£ç  /* * Copyright 2002-2019 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.springframework.beans.factory.xml.support; import java.io.IOException; import java.util.Arrays; import java.util.List; import java.util.Map; import java.util.Set; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.w3c.dom.Attr; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.xml.sax.InputSource; import org.springframework.aop.Advisor; import org.springframework.aop.config.AbstractInterceptorDrivenBeanDefinitionDecorator; import org.springframework.aop.framework.Advised; import org.springframework.aop.interceptor.DebugInterceptor; import org.springframework.aop.support.AopUtils; import org.springframework.beans.BeanInstantiationException; import org.springframework.beans.MutablePropertyValues; import org.springframework.beans.factory.BeanCreationException; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.beans.factory.config.BeanDefinitionHolder; import org.springframework.beans.factory.support.AbstractBeanDefinition; import org.springframework.beans.factory.support.BeanDefinitionBuilder; import org.springframework.beans.factory.support.RootBeanDefinition; import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser; import org.springframework.beans.factory.xml.BeanDefinitionDecorator; import org.springframework.beans.factory.xml.BeanDefinitionParser; import org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver; import org.springframework.beans.factory.xml.NamespaceHandlerResolver; import org.springframework.beans.factory.xml.NamespaceHandlerSupport; import org.springframework.beans.factory.xml.ParserContext; import org.springframework.beans.factory.xml.PluggableSchemaResolver; import org.springframework.beans.factory.xml.XmlBeanDefinitionReader; import org.springframework.context.ApplicationListener; import org.springframework.context.support.GenericApplicationContext; import org.springframework.core.io.ClassPathResource; import org.springframework.core.io.Resource; import org.springframework.tests.aop.interceptor.NopInterceptor; import org.springframework.tests.sample.beans.ITestBean; import org.springframework.tests.sample.beans.TestBean; import static java.lang.String.format; import static org.assertj.core.api.Assertions.assertThat; import static org.assertj.core.api.Assertions.assertThatExceptionOfType; /** * Unit tests for custom XML namespace handler implementations. * * @author Rob Harrop * @author Rick Evans * @author Chris Beams * @author Juergen Hoeller */ public class CustomNamespaceHandlerTests { private static final Class&amp;lt;?&amp;gt; CLASS = CustomNamespaceHandlerTests.class; private static final String CLASSNAME = CLASS.getSimpleName(); private static final String FQ_PATH = &quot;org/springframework/beans/factory/xml/support&quot;; private static final String NS_PROPS = format(&quot;%s/%s.properties&quot;, FQ_PATH, CLASSNAME); private static final String NS_XML = format(&quot;%s/%s-context.xml&quot;, FQ_PATH, CLASSNAME); private static final String TEST_XSD = format(&quot;%s/%s.xsd&quot;, FQ_PATH, CLASSNAME); private GenericApplicationContext beanFactory; @BeforeEach public void setUp() throws Exception { NamespaceHandlerResolver resolver = new DefaultNamespaceHandlerResolver(CLASS.getClassLoader(), NS_PROPS); this.beanFactory = new GenericApplicationContext(); XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this.beanFactory); reader.setNamespaceHandlerResolver(resolver); reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_XSD); reader.setEntityResolver(new DummySchemaResolver()); reader.loadBeanDefinitions(getResource()); this.beanFactory.refresh(); } @Test public void testSimpleParser() throws Exception { TestBean bean = (TestBean) this.beanFactory.getBean(&quot;testBean&quot;); assertTestBean(bean); } @Test public void testSimpleDecorator() throws Exception { TestBean bean = (TestBean) this.beanFactory.getBean(&quot;customisedTestBean&quot;); assertTestBean(bean); } @Test public void testProxyingDecorator() throws Exception { ITestBean bean = (ITestBean) this.beanFactory.getBean(&quot;debuggingTestBean&quot;); assertTestBean(bean); assertThat(AopUtils.isAopProxy(bean)).isTrue(); Advisor[] advisors = ((Advised) bean).getAdvisors(); assertThat(advisors.length).as(&quot;Incorrect number of advisors&quot;).isEqualTo(1); assertThat(advisors[0].getAdvice().getClass()).as(&quot;Incorrect advice class&quot;).isEqualTo(DebugInterceptor.class); } @Test public void testProxyingDecoratorNoInstance() throws Exception { String[] beanNames = this.beanFactory.getBeanNamesForType(ApplicationListener.class); assertThat(Arrays.asList(beanNames).contains(&quot;debuggingTestBeanNoInstance&quot;)).isTrue(); assertThat(this.beanFactory.getType(&quot;debuggingTestBeanNoInstance&quot;)).isEqualTo(ApplicationListener.class); assertThatExceptionOfType(BeanCreationException.class).isThrownBy(() -&amp;gt; this.beanFactory.getBean(&quot;debuggingTestBeanNoInstance&quot;)) .satisfies(ex -&amp;gt; assertThat(ex.getRootCause()).isInstanceOf(BeanInstantiationException.class)); } @Test public void testChainedDecorators() throws Exception { ITestBean bean = (ITestBean) this.beanFactory.getBean(&quot;chainedTestBean&quot;); assertTestBean(bean); assertThat(AopUtils.isAopProxy(bean)).isTrue(); Advisor[] advisors = ((Advised) bean).getAdvisors(); assertThat(advisors.length).as(&quot;Incorrect number of advisors&quot;).isEqualTo(2); assertThat(advisors[0].getAdvice().getClass()).as(&quot;Incorrect advice class&quot;).isEqualTo(DebugInterceptor.class); assertThat(advisors[1].getAdvice().getClass()).as(&quot;Incorrect advice class&quot;).isEqualTo(NopInterceptor.class); } @Test public void testDecorationViaAttribute() throws Exception { BeanDefinition beanDefinition = this.beanFactory.getBeanDefinition(&quot;decorateWithAttribute&quot;); assertThat(beanDefinition.getAttribute(&quot;objectName&quot;)).isEqualTo(&quot;foo&quot;); } @Test // SPR-2728 public void testCustomElementNestedWithinUtilList() throws Exception { List&amp;lt;?&amp;gt; things = (List&amp;lt;?&amp;gt;) this.beanFactory.getBean(&quot;list.of.things&quot;); assertThat(things).isNotNull(); assertThat(things.size()).isEqualTo(2); } @Test // SPR-2728 public void testCustomElementNestedWithinUtilSet() throws Exception { Set&amp;lt;?&amp;gt; things = (Set&amp;lt;?&amp;gt;) this.beanFactory.getBean(&quot;set.of.things&quot;); assertThat(things).isNotNull(); assertThat(things.size()).isEqualTo(2); } @Test // SPR-2728 public void testCustomElementNestedWithinUtilMap() throws Exception { Map&amp;lt;?, ?&amp;gt; things = (Map&amp;lt;?, ?&amp;gt;) this.beanFactory.getBean(&quot;map.of.things&quot;); assertThat(things).isNotNull(); assertThat(things.size()).isEqualTo(2); } private void assertTestBean(ITestBean bean) { assertThat(bean.getName()).as(&quot;Invalid name&quot;).isEqualTo(&quot;Rob Harrop&quot;); assertThat(bean.getAge()).as(&quot;Invalid age&quot;).isEqualTo(23); } private Resource getResource() { return new ClassPathResource(NS_XML); } private final class DummySchemaResolver extends PluggableSchemaResolver { public DummySchemaResolver() { super(CLASS.getClassLoader()); } @Override public InputSource resolveEntity(String publicId, String systemId) throws IOException { InputSource source = super.resolveEntity(publicId, systemId); if (source == null) { Resource resource = new ClassPathResource(TEST_XSD); source = new InputSource(resource.getInputStream()); source.setPublicId(publicId); source.setSystemId(systemId); } return source; } } } /** * Custom namespace handler implementation. * è‡ªå®šä¹‰åç§°ç©ºé—´å¤„ç†å™¨ * @author Rob Harrop */ final class TestNamespaceHandler extends NamespaceHandlerSupport { @Override public void init() { // æ³¨å†ŒèŠ‚ç‚¹ä¸º testBean çš„è§£æå™¨ registerBeanDefinitionParser(&quot;testBean&quot;, new TestBeanDefinitionParser()); // æ³¨å†ŒèŠ‚ç‚¹ä¸º person çš„è§£æå™¨ registerBeanDefinitionParser(&quot;person&quot;, new PersonDefinitionParser()); // æ³¨å†Œ set è£…é¥°å™¨ registerBeanDefinitionDecorator(&quot;set&quot;, new PropertyModifyingBeanDefinitionDecorator()); // æ³¨å†Œ debug è£…é¥°å™¨ registerBeanDefinitionDecorator(&quot;debug&quot;, new DebugBeanDefinitionDecorator()); // æ³¨å†Œ nop è£…é¥°å™¨ registerBeanDefinitionDecorator(&quot;nop&quot;, new NopInterceptorBeanDefinitionDecorator()); // æ³¨å†Œ å±æ€§ä¸º object-name çš„è£…é¥°å™¨ registerBeanDefinitionDecoratorForAttribute(&quot;object-name&quot;, new ObjectNameBeanDefinitionDecorator()); } // èŠ‚ç‚¹ä¸º testBean çš„è§£æå™¨ private static class TestBeanDefinitionParser implements BeanDefinitionParser { @Override public BeanDefinition parse(Element element, ParserContext parserContext) { RootBeanDefinition definition = new RootBeanDefinition(); definition.setBeanClass(TestBean.class); MutablePropertyValues mpvs = new MutablePropertyValues(); mpvs.add(&quot;name&quot;, element.getAttribute(&quot;name&quot;)); mpvs.add(&quot;age&quot;, element.getAttribute(&quot;age&quot;)); definition.setPropertyValues(mpvs); parserContext.getRegistry().registerBeanDefinition(element.getAttribute(&quot;id&quot;), definition); return null; } } // èŠ‚ç‚¹ä¸º person çš„è§£æå™¨ private static final class PersonDefinitionParser extends AbstractSingleBeanDefinitionParser { @Override protected Class&amp;lt;?&amp;gt; getBeanClass(Element element) { return TestBean.class; } @Override protected void doParse(Element element, BeanDefinitionBuilder builder) { builder.addPropertyValue(&quot;name&quot;, element.getAttribute(&quot;name&quot;)); builder.addPropertyValue(&quot;age&quot;, element.getAttribute(&quot;age&quot;)); } } // set è£…é¥°å™¨ private static class PropertyModifyingBeanDefinitionDecorator implements BeanDefinitionDecorator { @Override public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) { Element element = (Element) node; BeanDefinition def = definition.getBeanDefinition(); MutablePropertyValues mpvs = (def.getPropertyValues() == null) ? new MutablePropertyValues() : def.getPropertyValues(); mpvs.add(&quot;name&quot;, element.getAttribute(&quot;name&quot;)); mpvs.add(&quot;age&quot;, element.getAttribute(&quot;age&quot;)); ((AbstractBeanDefinition) def).setPropertyValues(mpvs); return definition; } } // debug è£…é¥°å™¨ private static class DebugBeanDefinitionDecorator extends AbstractInterceptorDrivenBeanDefinitionDecorator { @Override protected BeanDefinition createInterceptorDefinition(Node node) { return new RootBeanDefinition(DebugInterceptor.class); } } // nop è£…é¥°å™¨ private static class NopInterceptorBeanDefinitionDecorator extends AbstractInterceptorDrivenBeanDefinitionDecorator { @Override protected BeanDefinition createInterceptorDefinition(Node node) { return new RootBeanDefinition(NopInterceptor.class); } } // å±æ€§ä¸º object-name çš„è£…é¥°å™¨ private static class ObjectNameBeanDefinitionDecorator implements BeanDefinitionDecorator { @Override public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) { Attr objectNameAttribute = (Attr) node; definition.getBeanDefinition().setAttribute(&quot;objectName&quot;, objectNameAttribute.getValue()); return definition; } } } é€šè¿‡è¿è¡Œç»“æœå¯ä»¥çœ‹å‡ºè¿™ä¸ªè£…é¥°å™¨å¯ä»¥é’ˆå¯¹ä¸èŠ‚ç‚¹æˆ–è€…å±æ€§è¿›è¡Œæ“ä½œ,ç›¸å½“äºIOæµä¸­çš„è®¾è®¡æ¨¡å¼ä¸€æ ·,è¿›è¡Œé¢å¤–çš„å¢å¼º. ä¸‰ã€å°ç»“ â€‹ è§£æè¿‡äº†,ä¹Ÿè£…é¥°è¿‡äº†,é‚£å°±å¯ä»¥æ³¨å†ŒBeanDefinitionHolderå¯¹è±¡äº†.</summary></entry><entry><title type="html">[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-beanæ ‡ç­¾è§£æ(äº”)</title><link href="https://onew.me/spring/2020/02/19/debug-spring-5.html" rel="alternate" type="text/html" title="[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-beanæ ‡ç­¾è§£æ(äº”)" /><published>2020-02-19T14:20:25+08:00</published><updated>2020-02-19T14:20:25+08:00</updated><id>https://onew.me/spring/2020/02/19/debug-spring-5</id><content type="html" xml:base="https://onew.me/spring/2020/02/19/debug-spring-5.html"># ä¸€ã€å‰è¨€

â€‹	åˆ†æäº†`import`æ ‡ç­¾ã€`alias`æ ‡ç­¾,é¡ºåŠ¿å¼•å‡ºäº†`bean`æ ‡ç­¾,åªä¸è¿‡`bean`æ ‡ç­¾é€»è¾‘è¾ƒä¸ºå¤æ‚æ²¡æœ‰è®°å½•å®Œ.

# äºŒã€ä»BeanDefinitionParserDelegateå¼€å§‹

```java
// BeanDefinitionParserDelegate
 @Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
		return parseBeanDefinitionElement(ele, null);
	}

	/**
	 * Parses the supplied {@code &lt;bean&gt;} element. May return {@code null}
	 * if there were errors during parse. Errors are reported to the
	 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
	 */
	@Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
		// è·å–id
		String id = ele.getAttribute(ID_ATTRIBUTE);
		// è·å–åç§°
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
		// è·å–åˆ«å,åˆ«åå¯ä»¥ä½¿ç”¨å¤šä¸ª
		List&lt;String&gt; aliases = new ArrayList&lt;&gt;();
		// åç§°ä¸ä¸ºç©º
		if (StringUtils.hasLength(nameAttr)) {
			// å¦‚æœæœ‰å¤šä¸ªåç§°,ä½¿ç”¨,;åˆ‡å‰²
			String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
			aliases.addAll(Arrays.asList(nameArr));
		}
		// beanåç§°å°±æ˜¯id
		String beanName = id;
		// å¦‚æœåç§°ä¸ºç©º,å¹¶ä¸”åˆ«åé›†åˆä¸ä¸ºç©º,åˆ™ä»åˆ«åä¸­è·å–ç¬¬ä¸€ä¸ª,ä½œä¸ºåç§°
		if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {
			beanName = aliases.remove(0);
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName +
						&quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;);
			}
		}

		if (containingBean == null) {
			// æ£€æŸ¥beanNameæ˜¯å¦å”¯ä¸€(åç§°æœªè¢«ä½¿ç”¨è¿‡)
			checkNameUniqueness(beanName, aliases, ele);
		}
		// è§£ææ ‡ç­¾å°è£…ä¸ºbeanDefinition
		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
		// beanDefinitionå¯¹è±¡ä¸ä¸ºç©º
		if (beanDefinition != null) {
			// beanNameä¸ºç©º
			if (!StringUtils.hasText(beanName)) {
				try {
					if (containingBean != null) {
						// ç”Ÿæˆbeançš„ name
						beanName = BeanDefinitionReaderUtils.generateBeanName(
								beanDefinition, this.readerContext.getRegistry(), true);
					}
					else {
            // ç”Ÿæˆbeançš„ name
						beanName = this.readerContext.generateBeanName(beanDefinition);
						// Register an alias for the plain bean class name, if still possible,
						// if the generator returned the class name plus a suffix.
						// This is expected for Spring 1.2/2.0 backwards compatibility.
            // è·å– className
						String beanClassName = beanDefinition.getBeanClassName();
            // åˆ¤æ–­beanåç§°ä¸ä¸ºç©º å¹¶ä¸” ä»¥ç±»åå¼€å¤´ å¹¶ä¸”åç§°æ²¡æœ‰è¢«ä½¿ç”¨
						if (beanClassName != null &amp;&amp;
								beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;
								!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
							aliases.add(beanClassName);
						}
					}
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; +
								&quot;using generated bean name [&quot; + beanName + &quot;]&quot;);
					}
				}
				catch (Exception ex) {
					error(ex.getMessage(), ele);
					return null;
				}
			}
			// åˆ«åé›†åˆè½¬ä¸ºæ•°ç»„
			String[] aliasesArray = StringUtils.toStringArray(aliases);
			// è¿”å›BeanDefinitionHolder
			return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
		}

		return null;
	}
```

â€‹	æ ¸å¿ƒé€»è¾‘åœ¨äº`	AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);`è¿™å¥ä»£ç ,è¿›å»çœ‹çœ‹.



## 2.1 parseBeanDefinitionElement

```java
  // BeanDefinitionParserDelegate
  @Nullable
	public AbstractBeanDefinition parseBeanDefinitionElement(
			Element ele, String beanName, @Nullable BeanDefinition containingBean) {
		// æ”¾å…¥çŠ¶æ€å¯¹è±¡åˆ°é“¾è¡¨ä¸­
		this.parseState.push(new BeanEntry(beanName));

		String className = null;
		// åˆ¤æ–­æ˜¯å¦æ‹¥æœ‰classå±æ€§
		if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
			// è·å–classNameå±æ€§å€¼
			className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
		}
		String parent = null;
		// åˆ¤æ–­æ˜¯å¦æ‹¥æœ‰parentå±æ€§
		if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
			// è·å–parentå±æ€§å€¼
			parent = ele.getAttribute(PARENT_ATTRIBUTE);
		}
		try {
			// åˆ›å»ºBeanDefinitioå¯¹è±¡,å°è£…beançš„æè¿°ä¿¡æ¯
			AbstractBeanDefinition bd = createBeanDefinition(className, parent);
			// è§£æbeanæ ‡ç­¾ä¸­çš„å„ç§å±æ€§,ä¾‹å¦‚:singleton,scope,abstractç­‰å±æ€§
			parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
			// æå–æè¿°ä¿¡æ¯
			bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));
			// è§£æå…ƒæ•°æ®
			parseMetaElements(ele, bd);
			// è§£ælookup-method,ç›¸å½“äºåŠ¨æ€ä»£ç†äº†,å¯åˆ©ç”¨æ­¤åŠŸèƒ½æ¥è¿›è¡Œçƒ­æ’æ‹”,ä¸ç”¨ä¿®æ”¹ä»£ç 
			// æ­¤åŠŸèƒ½å¯ä»¥ä¿®æ”¹æ–¹æ³•çš„è¿”å›å€¼
			parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
			// è§£æreplaced-method,æ­¤åŠŸèƒ½å¯åœ¨è¿è¡Œè¿‡ç¨‹ä¸­æ›¿æ¢æ‰åŸæœ‰çš„æ–¹æ³•,ä¸lookup-methodæœ‰ç‚¹ä¸åŒ
			// è¦æ›¿æ¢éœ€è¦å®ç°MethodReplaceræ¥å£æ‰èƒ½æ›¿æ¢æ‰ç›®æ ‡æ–¹æ³•
			parseReplacedMethodSubElements(ele, bd.getMethodOverrides());
			// è§£ææ„é€ æ–¹æ³•å‚æ•°
			parseConstructorArgElements(ele, bd);
			// è§£æpropertyå±æ€§
			parsePropertyElements(ele, bd);
			// è§£æqualifierå±æ€§
			parseQualifierElements(ele, bd);

			bd.setResource(this.readerContext.getResource());
			bd.setSource(extractSource(ele));

			return bd;
		}
		catch (ClassNotFoundException ex) {
			error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);
		}
		catch (NoClassDefFoundError err) {
			error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);
		}
		catch (Throwable ex) {
			error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);
		}
		finally {
			// å¼¹å‡ºè§£æçŠ¶æ€
			this.parseState.pop();
		}

		return null;
	}

```

1. åˆ¤æ–­æ˜¯å¦æ‹¥æœ‰classå±æ€§,è·å–classå±æ€§å€¼
2. åˆ¤æ–­æ˜¯å¦æ‹¥æœ‰parentå±æ€§,è·å–parentå±æ€§å€¼
3. åˆ›å»º`AbstractBeanDefinition`å¯¹è±¡
4. è§£æ`bean`æ ‡ç­¾ä¸­çš„æè¿°ä¿¡æ¯,ä¾‹å¦‚:singleton,scope,abstractç­‰å±æ€§
5. æå–æè¿°ä¿¡æ¯
6. è§£æå…ƒæ•°æ®
7. è§£æ`lookup-method`
8. è§£æ`replaced-method`
9. è§£ææ„é€ æ–¹æ³•å‚æ•°
10. è§£æ`property`å±æ€§
11. è§£æ`qualifier`å±æ€§

å¤§ä½“é€»è¾‘å¦‚ä¸Š,ä»¥ä¸Šæ­¥éª¤ä»æ­¥éª¤3å¼€å§‹è¿›è¡Œåˆ†æ.



## 2.2 createBeanDefinition

```java
// BeanDefinitionParserDelegate
protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)
			throws ClassNotFoundException {

		return BeanDefinitionReaderUtils.createBeanDefinition(
				parentName, className, this.readerContext.getBeanClassLoader());
	}
```

```java
// BeanDefinitionReaderUtils
public static AbstractBeanDefinition createBeanDefinition(
			@Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException {

		GenericBeanDefinition bd = new GenericBeanDefinition();
		bd.setParentName(parentName);
		if (className != null) {
			if (classLoader != null) {
				// åŠ è½½ç±»
				bd.setBeanClass(ClassUtils.forName(className, classLoader));
			}
			else {
				// å¦‚æœclass-loaderä¸ºç©ºåˆ™åªè®°å½•ç±»å
				bd.setBeanClassName(className);
			}
		}
		return bd;
	}
```

1. åˆ¤æ–­ç±»åŠ è½½å™¨æ˜¯å¦ä¸ºç©º,å¦‚æœç±»åŠ è½½å™¨ä¸ä¸ºç©ºåˆ™ä½¿ç”¨æŒ‡å®šçš„ç±»åŠ è½½å™¨åŠ è½½ç±»
2. è¿”å›`GenericBeanDefinition`å¯¹è±¡

ä»¥ä¸Šé€»è¾‘æ¯”è¾ƒç®€å•,é‡ç‚¹æ˜¯`GenericBeanDefinition`è¿™ä¸ªå¯¹è±¡.



## 2.3 GenericBeanDefinition

â€‹	`GenericBeanDefinition`æ˜¯ç”¨äºæè¿°`bean`,è¯¥ç±»ç»§æ‰¿äº†`AbstractBeanDefinition`.å¦‚ä¸‹å›¾:

![images](https://gitee.com/oneww/onew_image/raw/master/GenericBeanDefinition.png)

â€‹	æ€»å…±æœ‰2ä¸ªä½œç”¨,æè¿°`bean`çš„ä¿¡æ¯,è®¿é—®`bean`ä¸­çš„å±æ€§å€¼.

## 2.4 parseBeanDefinitionAttributes

```java
// BeanDefinitionParserDelegate
public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,
			@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {
		// è§£æsingletonå±æ€§
		// singletonå±æ€§ä¸èƒ½ä½¿ç”¨,å·²ç»è¿‡æ—¶
		if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {
			error(&quot;Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration&quot;, ele);
		}
		// åˆ¤æ–­æ˜¯å¦å­˜åœ¨scopeå±æ€§
		else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {
			// è®¾ç½®scopeå±æ€§å€¼
			bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));
		}
		else if (containingBean != null) {
			// Take default from containing bean in case of an inner bean definition.
			bd.setScope(containingBean.getScope());
		}
		// åˆ¤æ–­æ˜¯å¦å­˜åœ¨abstractå±æ€§
		if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {
			// è®¾ç½®abstractå±æ€§å€¼
			bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));
		}
		// è§£ælazy-initå±æ€§
		String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);
		if (isDefaultValue(lazyInit)) {
			lazyInit = this.defaults.getLazyInit();
		}
		// è®¾ç½®æ‡’åŠ è½½å€¼
		bd.setLazyInit(TRUE_VALUE.equals(lazyInit));
		// è·å–è‡ªåŠ¨è£…é…å±æ€§å€¼
		String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);
		// è®¾ç½®è‡ªåŠ¨è£…é…æ¨¡å¼
		bd.setAutowireMode(getAutowireMode(autowire));
		// åˆ¤æ–­æ˜¯å¦å­˜åœ¨depends-onå±æ€§
		if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
			// è·å–depends-onå±æ€§å€¼
			String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);
			// è®¾ç½®depends-onå±æ€§å€¼
			bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));
		}
		// è§£æautowireå±æ€§,è‡ªåŠ¨è£…é….å­˜åœ¨æ¡ä»¶åˆ¤æ–­
		String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);
		if (isDefaultValue(autowireCandidate)) {
			String candidatePattern = this.defaults.getAutowireCandidates();
			if (candidatePattern != null) {
				String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);
				bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));
			}
		}
		else {
			// è®¾ç½®autowire-candidateå±æ€§å€¼
			bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));
		}
		// åˆ¤æ–­æ˜¯å¦å­˜åœ¨primaryå±æ€§
		if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {
			// è®¾ç½®primaryå€¼
			bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));
		}
		// åˆ¤æ–­æ˜¯å¦å­˜åœ¨initå±æ€§
		if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {
			// è·å–initå±æ€§å€¼
			String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);
			// è®¾ç½®initå±æ€§å€¼
			bd.setInitMethodName(initMethodName);
		}
		// è®¾ç½®initå±æ€§é»˜è®¤å€¼
		else if (this.defaults.getInitMethod() != null) {
			bd.setInitMethodName(this.defaults.getInitMethod());
			bd.setEnforceInitMethod(false);
		}
		// åˆ¤æ–­æ˜¯å¦å­˜åœ¨destroyå±æ€§
		if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {
			// è·å–destroyå±æ€§å€¼
			String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);
			// è®¾ç½®destroyå±æ€§å€¼
			bd.setDestroyMethodName(destroyMethodName);
		}
		// è®¾ç½®destroyå±æ€§é»˜è®¤å€¼
		else if (this.defaults.getDestroyMethod() != null) {
			bd.setDestroyMethodName(this.defaults.getDestroyMethod());
			bd.setEnforceDestroyMethod(false);
		}
		// åˆ¤æ–­æ˜¯å¦å­˜åœ¨factoryå±æ€§
		if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {
			// è®¾ç½®factoryå±æ€§å€¼
			bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));
		}
		// åˆ¤æ–­æ˜¯å¦å­˜åœ¨factory-beanå±æ€§
		if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {
			// è®¾ç½®factory-beanå±æ€§å€¼
			bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));
		}

		return bd;
	}
```

1. è®¾ç½®`BeanDefinition`çš„scopeå±æ€§å€¼
2. è®¾ç½®`BeanDefinition`çš„abstractå±æ€§å€¼
3. è®¾ç½®`BeanDefinition`çš„lazy-initå±æ€§å€¼
4. è®¾ç½®`BeanDefinition`çš„autowireå±æ€§å€¼
5. è®¾ç½®`BeanDefinition`çš„depends-onå±æ€§å€¼
6. è®¾ç½®`BeanDefinition`çš„autowire-candidateå±æ€§å€¼
7. è®¾ç½®`BeanDefinition`çš„primaryå±æ€§å€¼
8. è®¾ç½®`BeanDefinition`çš„init-methodå±æ€§å€¼
9. è®¾ç½®`BeanDefinition`çš„destroy-methodå±æ€§å€¼
10. è®¾ç½®`BeanDefinition`çš„factory-methodå±æ€§å€¼
11. è®¾ç½®`BeanDefinition`çš„factory-beançš„å±æ€§å€¼

ä»¥ä¸Šä»£ç å°±æ˜¯å¯¹`BeanDefinition`å¯¹è±¡çš„ä¸€ä¸ªå±æ€§å¡«å…….



## 2.5 parseMetaElements

```java
// BeanDefinitionParserDelegate
public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {
		// è§£æå…ƒæ•°æ®
		NodeList nl = ele.getChildNodes();
		for (int i = 0; i &lt; nl.getLength(); i++) {
			Node node = nl.item(i);
			// è§£æmetaæ ‡ç­¾
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) {
				Element metaElement = (Element) node;
				String key = metaElement.getAttribute(KEY_ATTRIBUTE);
				String value = metaElement.getAttribute(VALUE_ATTRIBUTE);
				// ä½¿ç”¨kvæ–¹å¼åˆ›å»ºå¯¹è±¡
				BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);
				attribute.setSource(extractSource(metaElement));
				// è®°å½•å±æ€§
				attributeAccessor.addMetadataAttribute(attribute);
			}
		}
	}

```

	1. éå†æ‰€æœ‰èŠ‚ç‚¹
 	2. è§£æmetaæ ‡ç­¾
 	3. è®¾ç½®å€¼åˆ°attributeAccessorä¸­



## 2.6 parseLookupOverrideSubElements

```java
	// BeanDefinitionParserDelegate
public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) {
		// è·å–æ‰€æœ‰å­èŠ‚ç‚¹
		NodeList nl = beanEle.getChildNodes();
		for (int i = 0; i &lt; nl.getLength(); i++) {
			// éå†å­èŠ‚ç‚¹
			Node node = nl.item(i);
			// åˆ¤æ–­æ˜¯lookup-method èŠ‚ç‚¹
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) {
				Element ele = (Element) node;
				// è·å–nameå±æ€§ æ–¹æ³•å
				String methodName = ele.getAttribute(NAME_ATTRIBUTE);
				// è·å–beanå±æ€§ ç”¨äºæ›¿ä»£çš„beanåç§°,ç”¨äºå¼•ç”¨beanå¯¹è±¡
				String beanRef = ele.getAttribute(BEAN_ELEMENT);
				// åˆ›å»ºLookupOverride å¯¹è±¡
				LookupOverride override = new LookupOverride(methodName, beanRef);
				override.setSource(extractSource(ele));
				// æ·»åŠ åˆ°overrideså¯¹è±¡ä¸­çš„é›†åˆä¸­
				overrides.addOverride(override);
			}
		}
	}
```

1. éå†æ‰€æœ‰èŠ‚ç‚¹
2. è·å–nameå±æ€§
3. è·å–beanå±æ€§
4. åˆ›å»º`LookupOverride`å¯¹è±¡
5. æ·»åŠ åˆ°`MethodOverrides`ä¸­

â€‹	`lookup-method`è¿™ä¸ªä¸œè¥¿,ç›¸å½“äºæ˜¯æ›¿æ¢ä¸€ä¸ªæ–¹æ³•,ä¸`replaced-method`è¿™ä¸ªæœ‰äº›è®¸ä¸åŒ.åœ¨åé¢å¤„ç†beançš„æ—¶å€™è¿˜ä¼šå†æ¬¡å‡ºç°.



## 2.7 parseReplacedMethodSubElements

```java
// BeanDefinitionParserDelegate
public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {
		// è·å–æ‰€æœ‰èŠ‚ç‚¹
		NodeList nl = beanEle.getChildNodes();
		for (int i = 0; i &lt; nl.getLength(); i++) {
			// éå†æ‰€æœ‰èŠ‚ç‚¹
			Node node = nl.item(i);
			// åˆ¤æ–­æ˜¯replaced-method èŠ‚ç‚¹
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) {
				Element replacedMethodEle = (Element) node;
				// è·å–nameå±æ€§
				String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);
				// è·å–replacer å±æ€§
				String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);
				// åˆ›å»ºReplaceOverride å¯¹è±¡
				ReplaceOverride replaceOverride = new ReplaceOverride(name, callback);
				// Look for arg-type match elements.
				// è·å–arg-type å­èŠ‚ç‚¹
				List&lt;Element&gt; argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);
				// éå†arg-type èŠ‚ç‚¹
				for (Element argTypeEle : argTypeEles) {
					// è·å–match å±æ€§
					String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);
					// å¦‚æœmatchå±æ€§ä¸ºç©º è¯´æ˜æœ‰å­èŠ‚ç‚¹å¾ªç¯éå†å­èŠ‚ç‚¹å€¼,æ‹¼è£…å‚æ•°
					// å¦‚æœmatchå±æ€§ä¸ä¸ºç©º match å€¼å°±ä¸ºæœ¬èº«
					match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));
					if (StringUtils.hasText(match)) {
						replaceOverride.addTypeIdentifier(match);
					}
				}
				replaceOverride.setSource(extractSource(replacedMethodEle));
				// æ·»åŠ åˆ°é›†åˆ
				overrides.addOverride(replaceOverride);
			}
		}
	}

```

â€‹	é€»è¾‘ä¸lookup-methodå¤„ç†çš„å·®ä¸å¤š.



## 2.8 parseConstructorArgElements

```java
// BeanDefinitionParserDelegate
public void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {
		// è·å–æ‰€æœ‰å­èŠ‚ç‚¹
		NodeList nl = beanEle.getChildNodes();
		for (int i = 0; i &lt; nl.getLength(); i++) {
			// éå†å­èŠ‚ç‚¹
			Node node = nl.item(i);
			// åˆ¤æ–­æ˜¯constructor-arg èŠ‚ç‚¹
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {
				parseConstructorArgElement((Element) node, bd);
			}
		}
	}

```

1. éå†æ‰€æœ‰èŠ‚ç‚¹
2. æŸ¥æ‰¾èŠ‚ç‚¹`constructor-arg`
3. è§£æå‚æ•°

è§£æå‚æ•°çš„é€»è¾‘å•ç‹¬åœ¨ä¸€ä¸ªæ–¹æ³•ä¸­`parseConstructorArgElement`ã€‚

```java
// BeanDefinitionParserDelegate
public void parseConstructorArgElement(Element ele, BeanDefinition bd) {
		// æå– index å±æ€§
		String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);
		// æå– type å±æ€§
		String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);
		// æå– name å±æ€§
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
		// å¤„ç† index å±æ€§é€»è¾‘
		if (StringUtils.hasLength(indexAttr)) {
			try {
				// ä¸‹æ ‡è½¬æ¢ä¸º int
				int index = Integer.parseInt(indexAttr);
				// ä¸‹æ ‡ä¸å…è®¸å°äº0
				if (index &lt; 0) {
					error(&quot;'index' cannot be lower than 0&quot;, ele);
				}
				else {
					try {
						this.parseState.push(new ConstructorArgumentEntry(index));
						// è§£æ properties å±æ€§
						Object value = parsePropertyValue(ele, bd, null);
						ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
						// è®¾ç½® typeAttr å±æ€§å€¼
						if (StringUtils.hasLength(typeAttr)) {
							valueHolder.setType(typeAttr);
						}
						// è®¾ç½® name å±æ€§å€¼
						if (StringUtils.hasLength(nameAttr)) {
							valueHolder.setName(nameAttr);
						}
						valueHolder.setSource(extractSource(ele));
						// åˆ¤æ–­ä¸‹æ ‡æ˜¯å¦é‡å¤
						if (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) {
							error(&quot;Ambiguous constructor-arg entries for index &quot; + index, ele);
						}
						else {
							// æ·»åŠ  ä¸‹æ ‡ å‚æ•°
							bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);
						}
					}
					finally {
						this.parseState.pop();
					}
				}
			}
			catch (NumberFormatException ex) {
				error(&quot;Attribute 'index' of tag 'constructor-arg' must be an integer&quot;, ele);
			}
		}
		else {
			// ä¸åŒ…å« index å±æ€§å¤„ç†é€»è¾‘
			try {
				this.parseState.push(new ConstructorArgumentEntry());
				Object value = parsePropertyValue(ele, bd, null);
				ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
				if (StringUtils.hasLength(typeAttr)) {
					valueHolder.setType(typeAttr);
				}
				if (StringUtils.hasLength(nameAttr)) {
					valueHolder.setName(nameAttr);
				}
				valueHolder.setSource(extractSource(ele));
				bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);
			}
			finally {
				this.parseState.pop();
			}
		}
	}
```

é€šè¿‡åˆ¤æ–­æ˜¯å¦æœ‰indexå±æ€§æ¥è¿›è¡Œè§£æé…ç½®æ–‡ä»¶.è§£æå‚æ•°çš„ä»£ç ä¸º`parsePropertyValue(ele, bd, null);`

```java
// BeanDefinitionParserDelegate
@Nullable
	public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {
		String elementName = (propertyName != null ?
				&quot;&lt;property&gt; element for property '&quot; + propertyName + &quot;'&quot; :
				&quot;&lt;constructor-arg&gt; element&quot;);

		// Should only have one child element: ref, value, list, etc.
		// è·å–æ‰€æœ‰å­èŠ‚ç‚¹
		NodeList nl = ele.getChildNodes();
		Element subElement = null;
		// éå†æ‰€æœ‰å­èŠ‚ç‚¹
		for (int i = 0; i &lt; nl.getLength(); i++) {
			Node node = nl.item(i);
			// description èŠ‚ç‚¹ å’Œ metaèŠ‚ç‚¹ ä¸å¤„ç†
			if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;
					!nodeNameEquals(node, META_ELEMENT)) {
				// Child element is what we're looking for.
				if (subElement != null) {
					error(elementName + &quot; must not contain more than one sub-element&quot;, ele);
				}
				else {
					subElement = (Element) node;
				}
			}
		}
		// åˆ¤æ–­æ˜¯å¤ŸåŒ…å« ref å±æ€§
		boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);
		// åˆ¤æ–­æ˜¯å¦åŒ…å« value å±æ€§
		boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);
		// å¦‚æœ [[åŒæ—¶åŒ…å« ref å±æ€§ å’Œ value å±æ€§] æˆ–è€… [[åŒ…å« ref å±æ€§ æˆ–è€… valueå±æ€§ ä¹‹ä¸€] å¹¶ä¸” subElement ä¸ä¸ºç©º]]
		// åˆ™ æŠ›å‡ºå¼‚å¸¸
		if ((hasRefAttribute &amp;&amp; hasValueAttribute) ||
				((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) {
			error(elementName +
					&quot; is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element&quot;, ele);
		}
		// å¤„ç†åªåŒ…å« ref å±æ€§é€»è¾‘
		if (hasRefAttribute) {
			// è·å– ref å±æ€§å€¼
			String refName = ele.getAttribute(REF_ATTRIBUTE);
			// å¦‚æœ ref å±æ€§å€¼ä¸ºç©º error
			if (!StringUtils.hasText(refName)) {
				error(elementName + &quot; contains empty 'ref' attribute&quot;, ele);
			}
			// åˆ›å»º RuntimeBeanReference å¯¹è±¡
			RuntimeBeanReference ref = new RuntimeBeanReference(refName);
			ref.setSource(extractSource(ele));
			return ref;
		}
		// å¤„ç†å€¼åŒ…å« value å±æ€§é€»è¾‘
		else if (hasValueAttribute) {
			// åˆ›å»º TypedStringValue å¯¹è±¡
			TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));
			valueHolder.setSource(extractSource(ele));
			return valueHolder;
		}
		// å¤„ç†åªæœ‰å­å…ƒç´ é€»è¾‘
		else if (subElement != null) {
			return parsePropertySubElement(subElement, bd);
		}
		// error
		else {
			// Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found.
			error(elementName + &quot; must specify a ref or value&quot;, ele);
			return null;
		}
	}
```

1. éå†æ‰€æœ‰èŠ‚ç‚¹
2. description å’Œ meta èŠ‚ç‚¹ä¸å¤„ç†,è·³è¿‡.
3. åˆ¤æ–­æ˜¯å¦åŒ…å« ref å±æ€§
4. åˆ¤æ–­æ˜¯å¦åŒ…å« value å±æ€§
5. å¤„ç† ref
6. å¤„ç† value
7. å¤„ç†å­å…ƒç´ 

â€‹	å¤„ç†é€»è¾‘ä¸å¤æ‚,å¤æ‚ç‚¹çš„å¯èƒ½æ˜¯åœ¨å¤„ç†å­å…ƒç´ çš„å®æ—¶,ç›¸å¯¹å¤æ‚ç‚¹.é€šå¸¸å­å…ƒç´ çš„å¤„ç†å°±æ˜¯æŠŠå€¼è½¬æ¢ä¸º Map\List\Setç­‰æ•°æ®ç»“æ„.å¤„ç†å­å…ƒç´ çš„æ–¹æ³•æ˜¯`parsePropertySubElement`.

```java
// BeanDefinitionParserDelegate
@Nullable
	public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) {
		return parsePropertySubElement(ele, bd, null);
	}

	/**
	 * Parse a value, ref or collection sub-element of a property or
	 * constructor-arg element.
	 * @param ele subelement of property element; we don't know which yet
	 * @param bd the current bean definition (if any)
	 * @param defaultValueType the default type (class name) for any
	 * {@code &lt;value&gt;} tag that might be created
	 */
	@Nullable
	public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) {
		// å¤„ç†éé»˜è®¤åç§°ç©ºé—´
		if (!isDefaultNamespace(ele)) {
			return parseNestedCustomElement(ele, bd);
		}
		// å¤„ç† bean
		else if (nodeNameEquals(ele, BEAN_ELEMENT)) {
			BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);
			if (nestedBd != null) {
				nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);
			}
			return nestedBd;
		}
		// å¤„ç† ref
		else if (nodeNameEquals(ele, REF_ELEMENT)) {
			// A generic reference to any name of any bean.
			// è·å– éœ€è¦å¼•ç”¨çš„ bean åç§°
			String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);
			boolean toParent = false;
			// å¦‚æœ éœ€è¦å¼•ç”¨çš„bean åç§°ä¸ºç©º
			if (!StringUtils.hasLength(refName)) {
				// A reference to the id of another bean in a parent context.
				// è·å– éœ€è¦å¼•ç”¨çš„parent å±æ€§
				refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);
				toParent = true;
				// å¦‚æœ bean ä¸ºç©º å¹¶ä¸” parent å±æ€§éƒ½ä¸ºç©º åˆ™ error
				if (!StringUtils.hasLength(refName)) {
					error(&quot;'bean' or 'parent' is required for &lt;ref&gt; element&quot;, ele);
					return null;
				}
			}
			// å¦‚æœéœ€è¦å¼•ç”¨çš„ bean åç§° ä¾ç„¶ä¸ºç©º åˆ™ error
			if (!StringUtils.hasText(refName)) {
				error(&quot;&lt;ref&gt; element contains empty target attribute&quot;, ele);
				return null;
			}
			// åˆ›å»º RuntimeBeanReference å¯¹è±¡
			RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);
			ref.setSource(extractSource(ele));
			return ref;
		}
		// å¤„ç† idref
		else if (nodeNameEquals(ele, IDREF_ELEMENT)) {
			return parseIdRefElement(ele);
		}
		// å¤„ç† value
		else if (nodeNameEquals(ele, VALUE_ELEMENT)) {
			return parseValueElement(ele, defaultValueType);
		}
		// å¤„ç† null
		else if (nodeNameEquals(ele, NULL_ELEMENT)) {
			// It's a distinguished null value. Let's wrap it in a TypedStringValue
			// object in order to preserve the source location.
			// åˆ›å»º TypedStringValue å¯¹è±¡
			TypedStringValue nullHolder = new TypedStringValue(null);
			nullHolder.setSource(extractSource(ele));
			return nullHolder;
		}
		// å¤„ç† array
		else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {
			return parseArrayElement(ele, bd);
		}
		// å¤„ç† list
		else if (nodeNameEquals(ele, LIST_ELEMENT)) {
			return parseListElement(ele, bd);
		}
		// å¤„ç† set
		else if (nodeNameEquals(ele, SET_ELEMENT)) {
			return parseSetElement(ele, bd);
		}
		// å¤„ç† map
		else if (nodeNameEquals(ele, MAP_ELEMENT)) {
			return parseMapElement(ele, bd);
		}
		// å¤„ç† props
		else if (nodeNameEquals(ele, PROPS_ELEMENT)) {
			return parsePropsElement(ele);
		}
		// error
		else {
			error(&quot;Unknown property sub-element: [&quot; + ele.getNodeName() + &quot;]&quot;, ele);
			return null;
		}
	}
```

â€‹	å¼€å¤´å°±æ˜¯ä¸€ä¸ªåˆ¤æ–­,åˆ¤æ–­æ˜¯å¦æ˜¯é»˜è®¤åç§°ç©ºé—´,å¦‚æœéé»˜è®¤åç§°ç©ºé—´é‡‡ç”¨è‡ªå®šä¹‰è§£æé€»è¾‘.



### 2.8.1 è‡ªå®šä¹‰è§£æ

â€‹	åˆ›å»ºè‡ªå®šä¹‰xsd

```xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
			xmlns=&quot;https://onew.me/schema/adv&quot;
			targetNamespace=&quot;https://onew.me/schema/adv&quot; elementFormDefault=&quot;qualified&quot;&gt;
	&lt;xsd:element name=&quot;AdvProp&quot;&gt;
		&lt;xsd:complexType&gt;
			&lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; /&gt;
			&lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:string&quot; /&gt;
		&lt;/xsd:complexType&gt;
	&lt;/xsd:element&gt;

&lt;/xsd:schema&gt;
```

â€‹	åˆ›å»ºç±»

```java
package com.sjr.test.bean;

public class AdvProp {

	private String name;

	private String age;

	public String getName() {
		return name;
	}

	public AdvProp setName(String name) {
		this.name = name;
		return this;
	}

	public String getAge() {
		return age;
	}

	public AdvProp setAge(String age) {
		this.age = age;
		return this;
	}
}

```

â€‹	ä¿®æ”¹æµ‹è¯•ç±»

```java
package com.sjr.test.bean;

public class MyTestBean {

	private AdvProp advProp;

	private String testStr = &quot;test--one&quot;;

	public MyTestBean(AdvProp advProp) {
		this.advProp = advProp;
	}

	public MyTestBean() {
	}

	public String getTestStr() {
		return testStr;
	}

	public MyTestBean setTestStr(String testStr) {
		this.testStr = testStr;
		return this;
	}

	public AdvProp getAdvProp() {
		return advProp;
	}

	public MyTestBean setAdvProp(AdvProp advProp) {
		this.advProp = advProp;
		return this;
	}

	public void printAdvProp(){
		System.out.println(&quot;advProp: age-&quot; + advProp.getAge() + &quot;,name-&quot; + advProp.getName());
	}
}

```

â€‹	åˆ›å»ºè‡ªå®šä¹‰è§£æç±»

```java
public class TestAdvPropParser extends AbstractSingleBeanDefinitionParser {

	@Override
	protected Class&lt;?&gt; getBeanClass(Element element) {
		return AdvProp.class;
	}

	@Override
	protected void doParse(Element element, BeanDefinitionBuilder builder) {
		final String name = element.getAttribute(&quot;name&quot;);
		final String age = element.getAttribute(&quot;age&quot;);
		builder.addPropertyValue(&quot;name&quot;,name);
		builder.addPropertyValue(&quot;age&quot;,age);
	}
}

```

â€‹	åˆ›å»ºè‡ªå®šä¹‰NamespaceHandlerç±»

```java
public class TestNamespaceHandler extends NamespaceHandlerSupport {

	@Override
	public void init() {
		registerBeanDefinitionParser(&quot;AdvProp&quot;,new TestAdvPropParser());
	}
}

```

â€‹	é…ç½®spring.handlers

```properties
https\://onew.me/schema/adv=com.sjr.test.handler.TestNamespaceHandler
```

â€‹	é…ç½®spring.schemas

```properties
https\://onew.me/schema/adv/AdvProp.xsd=com/sjr/test/bean/AdvProp.xsd
```

â€‹	é…ç½®xml

```xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	   xmlns:adv=&quot;https://onew.me/schema/adv&quot;
	   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                       https://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                       https://onew.me/schema/adv https://onew.me/schema/adv/AdvProp.xsd
&quot;&gt;
	&lt;bean id=&quot;myTestBean&quot; class=&quot;com.sjr.test.bean.MyTestBean&quot;&gt;
		&lt;constructor-arg&gt;
			&lt;adv:AdvProp  name=&quot;testAdv&quot; age=&quot;31&quot;/&gt;
		&lt;/constructor-arg&gt;
	&lt;/bean&gt;
&lt;/beans&gt;

```

â€‹	ä¿®æ”¹æµ‹è¯•ä»£ç 

```java
@Test
	public void testSpringAdvParseTag(){
		BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/AdvTestBean.xml&quot;));
		final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);
		testBean.printAdvProp();
	}
```

â€‹	è¿è¡Œç»“æœ

```properties
advProp: age-31,name-testAdv
```



1. `TestNamespaceHandler`ç”¨äºæ³¨å†Œè‡ªå®šä¹‰è§£æå™¨
2. `TestAdvPropParser`ç”¨äºè§£æè‡ªå®šä¹‰æ ‡ç­¾
3. `spring.schemas`ç”¨äºæè¿°xsdæ–‡ä»¶è·¯å¾„
4. `spring.handlers`ç”¨äºæŒ‡å®šè‡ªå®šä¹‰åç§°ç©ºé—´ä½¿ç”¨æŒ‡å®šçš„handler



### 2.8.2 è§£æbeanæ ‡ç­¾

â€‹	è§£æé€»è¾‘ä¸beanæ ‡ç­¾é€»è¾‘ä¸€è‡´

```java
// BeanDefinitionParserDelegate	
// å¤„ç† bean
		else if (nodeNameEquals(ele, BEAN_ELEMENT)) {
			BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);
			if (nestedBd != null) {
				nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);
			}
			return nestedBd;
		}
```

### 2.8.3 è§£ærefæ ‡ç­¾

```java
// BeanDefinitionParserDelegate
if (nodeNameEquals(ele, REF_ELEMENT)) {
			// A generic reference to any name of any bean.
			// è·å– éœ€è¦å¼•ç”¨çš„ bean åç§°
			String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);
			boolean toParent = false;
			// å¦‚æœ éœ€è¦å¼•ç”¨çš„bean åç§°ä¸ºç©º
			if (!StringUtils.hasLength(refName)) {
				// A reference to the id of another bean in a parent context.
				// è·å– éœ€è¦å¼•ç”¨çš„parent å±æ€§
				refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);
				toParent = true;
				// å¦‚æœ bean ä¸ºç©º å¹¶ä¸” parent å±æ€§éƒ½ä¸ºç©º åˆ™ error
				if (!StringUtils.hasLength(refName)) {
					error(&quot;'bean' or 'parent' is required for &lt;ref&gt; element&quot;, ele);
					return null;
				}
			}
			// å¦‚æœéœ€è¦å¼•ç”¨çš„ bean åç§° ä¾ç„¶ä¸ºç©º åˆ™ error
			if (!StringUtils.hasText(refName)) {
				error(&quot;&lt;ref&gt; element contains empty target attribute&quot;, ele);
				return null;
			}
			// åˆ›å»º RuntimeBeanReference å¯¹è±¡
			RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);
			ref.setSource(extractSource(ele));
			return ref;
		}
```

### 2.8.4 è§£æidrefæ ‡ç­¾

```java
	// BeanDefinitionParserDelegate
	@Nullable
	public Object parseIdRefElement(Element ele) {
		// A generic reference to any name of any bean.
		// è·å–éœ€è¦å¼•ç”¨çš„ bean å±æ€§
		String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);
		// å¼•ç”¨çš„åç§°ä¸ºç©º åˆ™ error
		if (!StringUtils.hasLength(refName)) {
			error(&quot;'bean' is required for &lt;idref&gt; element&quot;, ele);
			return null;
		}
		// å¼•ç”¨çš„åç§°ä¸ºç©º åˆ™ error
		if (!StringUtils.hasText(refName)) {
			error(&quot;&lt;idref&gt; element contains empty target attribute&quot;, ele);
			return null;
		}
		// åˆ›å»º RuntimeBeanNameReference
		RuntimeBeanNameReference ref = new RuntimeBeanNameReference(refName);
		ref.setSource(extractSource(ele));
		return ref;
	}
```

### 2.8.5 è§£ævalueæ ‡ç­¾

```java
	// BeanDefinitionParserDelegate
	public Object parseValueElement(Element ele, @Nullable String defaultTypeName) {
		// It's a literal value.
		// è·å–æ–‡æœ¬å€¼
		String value = DomUtils.getTextValue(ele);
		// è·å– type å±æ€§
		String specifiedTypeName = ele.getAttribute(TYPE_ATTRIBUTE);
		String typeName = specifiedTypeName;
		// å¦‚æœ type å±æ€§ä¸ºç©º åˆ™ è®¾ç½®ä¸ºé»˜è®¤çš„ type
		if (!StringUtils.hasText(typeName)) {
			// é»˜è®¤ä¸º null
			typeName = defaultTypeName;
		}
		try {
			// åˆ›å»º TypedStringValue å¯¹è±¡
			TypedStringValue typedValue = buildTypedStringValue(value, typeName);
			typedValue.setSource(extractSource(ele));
			typedValue.setSpecifiedTypeName(specifiedTypeName);
			return typedValue;
		}
		catch (ClassNotFoundException ex) {
			error(&quot;Type class [&quot; + typeName + &quot;] not found for &lt;value&gt; element&quot;, ele, ex);
			return value;
		}
	}

```

### 2.8.6 è§£æarray æ ‡ç­¾

```java
	// BeanDefinitionParserDelegate
public Object parseArrayElement(Element arrayEle, @Nullable BeanDefinition bd) {
		// è·å– value-type å±æ€§
		String elementType = arrayEle.getAttribute(VALUE_TYPE_ATTRIBUTE);
		// è·å–æ‰€æœ‰å­èŠ‚ç‚¹
		NodeList nl = arrayEle.getChildNodes();
		// åˆ›å»º ManagedArray å¯¹è±¡
		ManagedArray target = new ManagedArray(elementType, nl.getLength());
		target.setSource(extractSource(arrayEle));
		target.setElementTypeName(elementType);
		target.setMergeEnabled(parseMergeAttribute(arrayEle));
		parseCollectionElements(nl, target, bd, elementType);
		return target;
	}
```

### 2.8.7 è§£ælistæ ‡ç­¾

```java
	// BeanDefinitionParserDelegate
public List&lt;Object&gt; parseListElement(Element collectionEle, @Nullable BeanDefinition bd) {
		// è·å– value-type å±æ€§
		String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);
		// è·å–æ‰€æœ‰å­èŠ‚ç‚¹
		NodeList nl = collectionEle.getChildNodes();
		// åˆ›å»º ManagedList å¯¹è±¡
		ManagedList&lt;Object&gt; target = new ManagedList&lt;&gt;(nl.getLength());
		target.setSource(extractSource(collectionEle));
		target.setElementTypeName(defaultElementType);
		target.setMergeEnabled(parseMergeAttribute(collectionEle));
		parseCollectionElements(nl, target, bd, defaultElementType);
		return target;
	}
```

### 2.8.8 è§£æsetæ ‡ç­¾

```java
	// BeanDefinitionParserDelegate
public Set&lt;Object&gt; parseSetElement(Element collectionEle, @Nullable BeanDefinition bd) {
		// è·å– value-type å±æ€§
		String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);
		// è·å–æ‰€æœ‰å­èŠ‚ç‚¹
		NodeList nl = collectionEle.getChildNodes();
		// åˆ›å»º ManagedSet å¯¹è±¡
		ManagedSet&lt;Object&gt; target = new ManagedSet&lt;&gt;(nl.getLength());
		target.setSource(extractSource(collectionEle));
		target.setElementTypeName(defaultElementType);
		target.setMergeEnabled(parseMergeAttribute(collectionEle));
		parseCollectionElements(nl, target, bd, defaultElementType);
		return target;
	}
```



### 2.8.9 è§£æmapæ ‡ç­¾

```java
	// BeanDefinitionParserDelegate
public Map&lt;Object, Object&gt; parseMapElement(Element mapEle, @Nullable BeanDefinition bd) {
		// è·å– key-type å±æ€§å€¼
		String defaultKeyType = mapEle.getAttribute(KEY_TYPE_ATTRIBUTE);
		// è·å– value-type å±æ€§å€¼
		String defaultValueType = mapEle.getAttribute(VALUE_TYPE_ATTRIBUTE);

		// è·å– entry å­èŠ‚ç‚¹
		List&lt;Element&gt; entryEles = DomUtils.getChildElementsByTagName(mapEle, ENTRY_ELEMENT);
		// åˆ›å»º ManagedMap å¯¹è±¡
		ManagedMap&lt;Object, Object&gt; map = new ManagedMap&lt;&gt;(entryEles.size());
		map.setSource(extractSource(mapEle));
		map.setKeyTypeName(defaultKeyType);
		map.setValueTypeName(defaultValueType);
		map.setMergeEnabled(parseMergeAttribute(mapEle));

		// éå† entryEles é›†åˆ
		for (Element entryEle : entryEles) {
			// Should only have one value child element: ref, value, list, etc.
			// Optionally, there might be a key child element.
			// è·å–å­èŠ‚ç‚¹
			NodeList entrySubNodes = entryEle.getChildNodes();
			Element keyEle = null;
			Element valueEle = null;
			// éå† entrySubNodes
			for (int j = 0; j &lt; entrySubNodes.getLength(); j++) {
				Node node = entrySubNodes.item(j);
				if (node instanceof Element) {
					Element candidateEle = (Element) node;
					// å¤„ç† key èŠ‚ç‚¹é€»è¾‘
					if (nodeNameEquals(candidateEle, KEY_ELEMENT)) {
						if (keyEle != null) {
							error(&quot;&lt;entry&gt; element is only allowed to contain one &lt;key&gt; sub-element&quot;, entryEle);
						}
						else {
							keyEle = candidateEle;
						}
					}
					else {
						// å¿½ç•¥ description èŠ‚ç‚¹
						// Child element is what we're looking for.
						if (nodeNameEquals(candidateEle, DESCRIPTION_ELEMENT)) {
							// the element is a &lt;description&gt; -&gt; ignore it
						}
						else if (valueEle != null) {
							error(&quot;&lt;entry&gt; element must not contain more than one value sub-element&quot;, entryEle);
						}
						else {
							valueEle = candidateEle;
						}
					}
				}
			}

			// Extract key from attribute or sub-element.
			Object key = null;
			// åˆ¤æ–­æ˜¯å¦åŒ…å« key å±æ€§
			boolean hasKeyAttribute = entryEle.hasAttribute(KEY_ATTRIBUTE);
			// åˆ¤æ–­æ˜¯å¦åŒ…å« key-ref å±æ€§
			boolean hasKeyRefAttribute = entryEle.hasAttribute(KEY_REF_ATTRIBUTE);
			// å¦‚æœ [[åŒ…å« key å±æ€§ å¹¶ä¸” åŒ…å« key-ref å±æ€§] æˆ–è€… [[åŒ…å« key å±æ€§ æˆ– åŒ…å« key-ref ä¹‹ä¸€]] å¹¶ä¸” keyEle ä¸ä¸ºç©º]
			// åˆ™ æŠ¥é”™
			if ((hasKeyAttribute &amp;&amp; hasKeyRefAttribute) ||
					(hasKeyAttribute || hasKeyRefAttribute) &amp;&amp; keyEle != null) {
				error(&quot;&lt;entry&gt; element is only allowed to contain either &quot; +
						&quot;a 'key' attribute OR a 'key-ref' attribute OR a &lt;key&gt; sub-element&quot;, entryEle);
			}
			// å¤„ç† key å±æ€§
			if (hasKeyAttribute) {
				key = buildTypedStringValueForMap(entryEle.getAttribute(KEY_ATTRIBUTE), defaultKeyType, entryEle);
			}
			// å¤„ç† key-ref å±æ€§
			else if (hasKeyRefAttribute) {
				String refName = entryEle.getAttribute(KEY_REF_ATTRIBUTE);
				if (!StringUtils.hasText(refName)) {
					error(&quot;&lt;entry&gt; element contains empty 'key-ref' attribute&quot;, entryEle);
				}
				RuntimeBeanReference ref = new RuntimeBeanReference(refName);
				ref.setSource(extractSource(entryEle));
				key = ref;
			}
			else if (keyEle != null) {
				key = parseKeyElement(keyEle, bd, defaultKeyType);
			}
			else {
				error(&quot;&lt;entry&gt; element must specify a key&quot;, entryEle);
			}

			// Extract value from attribute or sub-element.
			Object value = null;
			// åˆ¤æ–­ æ˜¯å¦åŒ…å« value å±æ€§
			boolean hasValueAttribute = entryEle.hasAttribute(VALUE_ATTRIBUTE);
			// åˆ¤æ–­ æ˜¯å¦åŒ…å« value-ref å±æ€§
			boolean hasValueRefAttribute = entryEle.hasAttribute(VALUE_REF_ATTRIBUTE);
			// åˆ¤æ–­ æ˜¯å¦åŒ…å« value-type å±æ€§
			boolean hasValueTypeAttribute = entryEle.hasAttribute(VALUE_TYPE_ATTRIBUTE);
			if ((hasValueAttribute &amp;&amp; hasValueRefAttribute) ||
					(hasValueAttribute || hasValueRefAttribute) &amp;&amp; valueEle != null) {
				error(&quot;&lt;entry&gt; element is only allowed to contain either &quot; +
						&quot;'value' attribute OR 'value-ref' attribute OR &lt;value&gt; sub-element&quot;, entryEle);
			}
			if ((hasValueTypeAttribute &amp;&amp; hasValueRefAttribute) ||
				(hasValueTypeAttribute &amp;&amp; !hasValueAttribute) ||
					(hasValueTypeAttribute &amp;&amp; valueEle != null)) {
				error(&quot;&lt;entry&gt; element is only allowed to contain a 'value-type' &quot; +
						&quot;attribute when it has a 'value' attribute&quot;, entryEle);
			}
			// å¤„ç† value å±æ€§
			if (hasValueAttribute) {
				String valueType = entryEle.getAttribute(VALUE_TYPE_ATTRIBUTE);
				if (!StringUtils.hasText(valueType)) {
					valueType = defaultValueType;
				}
				value = buildTypedStringValueForMap(entryEle.getAttribute(VALUE_ATTRIBUTE), valueType, entryEle);
			}
			// å¤„ç† value-ref å±æ€§
			else if (hasValueRefAttribute) {
				String refName = entryEle.getAttribute(VALUE_REF_ATTRIBUTE);
				if (!StringUtils.hasText(refName)) {
					error(&quot;&lt;entry&gt; element contains empty 'value-ref' attribute&quot;, entryEle);
				}
				RuntimeBeanReference ref = new RuntimeBeanReference(refName);
				ref.setSource(extractSource(entryEle));
				value = ref;
			}
			// å¤„ç† valueEle
			else if (valueEle != null) {
				value = parsePropertySubElement(valueEle, bd, defaultValueType);
			}
			else {
				error(&quot;&lt;entry&gt; element must specify a value&quot;, entryEle);
			}

			// Add final key and value to the Map.
			// æ·»åŠ æœ€ç»ˆçš„ key å’Œ value åˆ° map ä¸­å»
			map.put(key, value);
		}

		return map;
	}
```

è½¬æ¢ä¸ºmapçš„æ—¶å€™é€»è¾‘ç¨å¾®æœ‰ç‚¹å¤æ‚,æ…¢æ…¢çœ‹,è¿˜æ˜¯èƒ½çœ‹æ‡‚.

### 2.8.10 è§£æpropsæ ‡ç­¾

```java
	// BeanDefinitionParserDelegate
public Properties parsePropsElement(Element propsEle) {
		// åˆ›å»º ManagedProperties å¯¹è±¡
		ManagedProperties props = new ManagedProperties();
		props.setSource(extractSource(propsEle));
		props.setMergeEnabled(parseMergeAttribute(propsEle));

		//è·å–èŠ‚ç‚¹ä¸‹é¢ç´ æœ‰ prop èŠ‚ç‚¹
		List&lt;Element&gt; propEles = DomUtils.getChildElementsByTagName(propsEle, PROP_ELEMENT);
		// éå† prop èŠ‚ç‚¹
		for (Element propEle : propEles) {
			// è·å– key
			String key = propEle.getAttribute(KEY_ATTRIBUTE);
			// Trim the text value to avoid unwanted whitespace
			// caused by typical XML formatting.
			// è·å– å€¼
			String value = DomUtils.getTextValue(propEle).trim();
			TypedStringValue keyHolder = new TypedStringValue(key);
			keyHolder.setSource(extractSource(propEle));
			TypedStringValue valueHolder = new TypedStringValue(value);
			valueHolder.setSource(extractSource(propEle));
			// æ”¾å…¥åˆ° props å¯¹è±¡ä¸­
			props.put(keyHolder, valueHolder);
		}

		return props;
	}
```



## 2.9 parsePropertyElements

```java
	// BeanDefinitionParserDelegate	
 public void parsePropertyElements(Element beanEle, BeanDefinition bd) {
		// è·å–æ‰€æœ‰å­èŠ‚ç‚¹
		NodeList nl = beanEle.getChildNodes();
		for (int i = 0; i &lt; nl.getLength(); i++) {
			// éå† æ‰€æœ‰èŠ‚ç‚¹
			Node node = nl.item(i);
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) {
				parsePropertyElement((Element) node, bd);
			}
		}
	}
	
	public void parsePropertyElement(Element ele, BeanDefinition bd) {
		// è·å– name å±æ€§
		String propertyName = ele.getAttribute(NAME_ATTRIBUTE);
		// name å±æ€§ä¸ºç©º åˆ™æŠ¥é”™
		if (!StringUtils.hasLength(propertyName)) {
			error(&quot;Tag 'property' must have a 'name' attribute&quot;, ele);
			return;
		}
		this.parseState.push(new PropertyEntry(propertyName));
		try {
			// å±æ€§åç›¸åŒåˆ™æŠ¥é”™
			if (bd.getPropertyValues().contains(propertyName)) {
				error(&quot;Multiple 'property' definitions for property '&quot; + propertyName + &quot;'&quot;, ele);
				return;
			}
			Object val = parsePropertyValue(ele, bd, propertyName);
			PropertyValue pv = new PropertyValue(propertyName, val);
			parseMetaElements(ele, pv);
			pv.setSource(extractSource(ele));
			bd.getPropertyValues().addPropertyValue(pv);
		}
		finally {
			this.parseState.pop();
		}
	}
```

1. éå†æ‰€æœ‰èŠ‚ç‚¹
2. ä½¿ç”¨`parsePropertyValue`æ–¹æ³•å¤„ç†å€¼(è¯¥æ–¹æ³•å·²ç»å†™åˆ°è¿‡)
3. æŠŠè§£æåˆ°çš„å€¼æ”¾å…¥`BeanDefinition`ä¸­å»



## 2.10 parseQualifierElements

```java
	// BeanDefinitionParserDelegate
public void parseQualifierElements(Element beanEle, AbstractBeanDefinition bd) {
		// è·å–æ‰€æœ‰å­èŠ‚ç‚¹
		NodeList nl = beanEle.getChildNodes();
		for (int i = 0; i &lt; nl.getLength(); i++) {
			// éå†æ‰€æœ‰å­èŠ‚ç‚¹
			Node node = nl.item(i);
			// å¤„ç† qualifier èŠ‚ç‚¹
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ELEMENT)) {
				parseQualifierElement((Element) node, bd);
			}
		}
	}
	
```

1. éå†æ‰€æœ‰èŠ‚ç‚¹
2. é€šè¿‡`parseQualifierElement`æ–¹æ³•å¤„ç†

```java
// BeanDefinitionParserDelegate
public void parseQualifierElement(Element ele, AbstractBeanDefinition bd) {
		// è·å– type å±æ€§
		String typeName = ele.getAttribute(TYPE_ATTRIBUTE);
		// å¦‚æœ type å±æ€§ä¸ºç©º åˆ™ error
		if (!StringUtils.hasLength(typeName)) {
			error(&quot;Tag 'qualifier' must have a 'type' attribute&quot;, ele);
			return;
		}
		this.parseState.push(new QualifierEntry(typeName));
		try {
			// åˆ›å»º AutowireCandidateQualifier å¯¹è±¡
			AutowireCandidateQualifier qualifier = new AutowireCandidateQualifier(typeName);
			qualifier.setSource(extractSource(ele));
			// è·å– value å±æ€§
			String value = ele.getAttribute(VALUE_ATTRIBUTE);
			if (StringUtils.hasLength(value)) {
				qualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value);
			}
			// è·å–å½“å‰èŠ‚ç‚¹ä¸‹çš„æ‰€æœ‰èŠ‚ç‚¹
			NodeList nl = ele.getChildNodes();
			for (int i = 0; i &lt; nl.getLength(); i++) {
				// éå†æ‰€æœ‰å­èŠ‚ç‚¹
				Node node = nl.item(i);
				// å¤„ç† attribute å±æ€§
				if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) {
					Element attributeEle = (Element) node;
					// è·å– key å±æ€§
					String attributeName = attributeEle.getAttribute(KEY_ATTRIBUTE);
					// è·å– value å±æ€§
					String attributeValue = attributeEle.getAttribute(VALUE_ATTRIBUTE);
					// key and value is not null
					if (StringUtils.hasLength(attributeName) &amp;&amp; StringUtils.hasLength(attributeValue)) {
						BeanMetadataAttribute attribute = new BeanMetadataAttribute(attributeName, attributeValue);
						attribute.setSource(extractSource(attributeEle));
						qualifier.addMetadataAttribute(attribute);
					}
					else {
						error(&quot;Qualifier 'attribute' tag must have a 'name' and 'value'&quot;, attributeEle);
						return;
					}
				}
			}
			bd.addQualifier(qualifier);
		}
		finally {
			this.parseState.pop();
		}
	}
```

1. éå†æ‰€æœ‰èŠ‚ç‚¹
2. æŠŠè·å–åˆ°çš„kvå…¨éƒ¨æ”¾å…¥åˆ°`AutowireCandidateQualifier`å¯¹è±¡ä¸­å»
3. `BeanDefinition`å¯¹è±¡è®¾ç½®`qualifier`å±æ€§



# ä¸‰ã€å°ç»“

â€‹	è‡³æ­¤å·²ç»åˆ›å»ºä¸€äº†ä¸€ä¸ªå®Œæ•´çš„`AbstractBeanDefinition`å¯¹è±¡,ä¸€ä¸ªå¯¹beanä¿¡æ¯çš„æè¿°å¯¹è±¡æœ‰äº†,ä¼šè½¬ä¸º`BeanDefinitionHolder`ä¸ºåç»­æ“ä½œä½œä¸ºåŸºç¡€.</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">ä¸€ã€å‰è¨€ â€‹ åˆ†æäº†importæ ‡ç­¾ã€aliasæ ‡ç­¾,é¡ºåŠ¿å¼•å‡ºäº†beanæ ‡ç­¾,åªä¸è¿‡beanæ ‡ç­¾é€»è¾‘è¾ƒä¸ºå¤æ‚æ²¡æœ‰è®°å½•å®Œ. äºŒã€ä»BeanDefinitionParserDelegateå¼€å§‹ // BeanDefinitionParserDelegate @Nullable public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { return parseBeanDefinitionElement(ele, null); } /** * Parses the supplied {@code &amp;lt;bean&amp;gt;} element. May return {@code null} * if there were errors during parse. Errors are reported to the * {@link org.springframework.beans.factory.parsing.ProblemReporter}. */ @Nullable public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) { // è·å–id String id = ele.getAttribute(ID_ATTRIBUTE); // è·å–åç§° String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); // è·å–åˆ«å,åˆ«åå¯ä»¥ä½¿ç”¨å¤šä¸ª List&amp;lt;String&amp;gt; aliases = new ArrayList&amp;lt;&amp;gt;(); // åç§°ä¸ä¸ºç©º if (StringUtils.hasLength(nameAttr)) { // å¦‚æœæœ‰å¤šä¸ªåç§°,ä½¿ç”¨,;åˆ‡å‰² String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } // beanåç§°å°±æ˜¯id String beanName = id; // å¦‚æœåç§°ä¸ºç©º,å¹¶ä¸”åˆ«åé›†åˆä¸ä¸ºç©º,åˆ™ä»åˆ«åä¸­è·å–ç¬¬ä¸€ä¸ª,ä½œä¸ºåç§° if (!StringUtils.hasText(beanName) &amp;amp;&amp;amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isTraceEnabled()) { logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName + &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;); } } if (containingBean == null) { // æ£€æŸ¥beanNameæ˜¯å¦å”¯ä¸€(åç§°æœªè¢«ä½¿ç”¨è¿‡) checkNameUniqueness(beanName, aliases, ele); } // è§£ææ ‡ç­¾å°è£…ä¸ºbeanDefinition AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); // beanDefinitionå¯¹è±¡ä¸ä¸ºç©º if (beanDefinition != null) { // beanNameä¸ºç©º if (!StringUtils.hasText(beanName)) { try { if (containingBean != null) { // ç”Ÿæˆbeançš„ name beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { // ç”Ÿæˆbeançš„ name beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. // è·å– className String beanClassName = beanDefinition.getBeanClassName(); // åˆ¤æ–­beanåç§°ä¸ä¸ºç©º å¹¶ä¸” ä»¥ç±»åå¼€å¤´ å¹¶ä¸”åç§°æ²¡æœ‰è¢«ä½¿ç”¨ if (beanClassName != null &amp;amp;&amp;amp; beanName.startsWith(beanClassName) &amp;amp;&amp;amp; beanName.length() &amp;gt; beanClassName.length() &amp;amp;&amp;amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { aliases.add(beanClassName); } } if (logger.isTraceEnabled()) { logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } // åˆ«åé›†åˆè½¬ä¸ºæ•°ç»„ String[] aliasesArray = StringUtils.toStringArray(aliases); // è¿”å›BeanDefinitionHolder return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } return null; } â€‹ æ ¸å¿ƒé€»è¾‘åœ¨äº AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);è¿™å¥ä»£ç ,è¿›å»çœ‹çœ‹. 2.1 parseBeanDefinitionElement // BeanDefinitionParserDelegate @Nullable public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) { // æ”¾å…¥çŠ¶æ€å¯¹è±¡åˆ°é“¾è¡¨ä¸­ this.parseState.push(new BeanEntry(beanName)); String className = null; // åˆ¤æ–­æ˜¯å¦æ‹¥æœ‰classå±æ€§ if (ele.hasAttribute(CLASS_ATTRIBUTE)) { // è·å–classNameå±æ€§å€¼ className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } String parent = null; // åˆ¤æ–­æ˜¯å¦æ‹¥æœ‰parentå±æ€§ if (ele.hasAttribute(PARENT_ATTRIBUTE)) { // è·å–parentå±æ€§å€¼ parent = ele.getAttribute(PARENT_ATTRIBUTE); } try { // åˆ›å»ºBeanDefinitioå¯¹è±¡,å°è£…beançš„æè¿°ä¿¡æ¯ AbstractBeanDefinition bd = createBeanDefinition(className, parent); // è§£æbeanæ ‡ç­¾ä¸­çš„å„ç§å±æ€§,ä¾‹å¦‚:singleton,scope,abstractç­‰å±æ€§ parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); // æå–æè¿°ä¿¡æ¯ bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); // è§£æå…ƒæ•°æ® parseMetaElements(ele, bd); // è§£ælookup-method,ç›¸å½“äºåŠ¨æ€ä»£ç†äº†,å¯åˆ©ç”¨æ­¤åŠŸèƒ½æ¥è¿›è¡Œçƒ­æ’æ‹”,ä¸ç”¨ä¿®æ”¹ä»£ç  // æ­¤åŠŸèƒ½å¯ä»¥ä¿®æ”¹æ–¹æ³•çš„è¿”å›å€¼ parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); // è§£æreplaced-method,æ­¤åŠŸèƒ½å¯åœ¨è¿è¡Œè¿‡ç¨‹ä¸­æ›¿æ¢æ‰åŸæœ‰çš„æ–¹æ³•,ä¸lookup-methodæœ‰ç‚¹ä¸åŒ // è¦æ›¿æ¢éœ€è¦å®ç°MethodReplaceræ¥å£æ‰èƒ½æ›¿æ¢æ‰ç›®æ ‡æ–¹æ³• parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // è§£ææ„é€ æ–¹æ³•å‚æ•° parseConstructorArgElements(ele, bd); // è§£æpropertyå±æ€§ parsePropertyElements(ele, bd); // è§£æqualifierå±æ€§ parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex); } catch (NoClassDefFoundError err) { error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err); } catch (Throwable ex) { error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex); } finally { // å¼¹å‡ºè§£æçŠ¶æ€ this.parseState.pop(); } return null; } åˆ¤æ–­æ˜¯å¦æ‹¥æœ‰classå±æ€§,è·å–classå±æ€§å€¼ åˆ¤æ–­æ˜¯å¦æ‹¥æœ‰parentå±æ€§,è·å–parentå±æ€§å€¼ åˆ›å»ºAbstractBeanDefinitionå¯¹è±¡ è§£æbeanæ ‡ç­¾ä¸­çš„æè¿°ä¿¡æ¯,ä¾‹å¦‚:singleton,scope,abstractç­‰å±æ€§ æå–æè¿°ä¿¡æ¯ è§£æå…ƒæ•°æ® è§£ælookup-method è§£æreplaced-method è§£ææ„é€ æ–¹æ³•å‚æ•° è§£æpropertyå±æ€§ è§£æqualifierå±æ€§ å¤§ä½“é€»è¾‘å¦‚ä¸Š,ä»¥ä¸Šæ­¥éª¤ä»æ­¥éª¤3å¼€å§‹è¿›è¡Œåˆ†æ. 2.2 createBeanDefinition // BeanDefinitionParserDelegate protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName) throws ClassNotFoundException { return BeanDefinitionReaderUtils.createBeanDefinition( parentName, className, this.readerContext.getBeanClassLoader()); } // BeanDefinitionReaderUtils public static AbstractBeanDefinition createBeanDefinition( @Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException { GenericBeanDefinition bd = new GenericBeanDefinition(); bd.setParentName(parentName); if (className != null) { if (classLoader != null) { // åŠ è½½ç±» bd.setBeanClass(ClassUtils.forName(className, classLoader)); } else { // å¦‚æœclass-loaderä¸ºç©ºåˆ™åªè®°å½•ç±»å bd.setBeanClassName(className); } } return bd; } åˆ¤æ–­ç±»åŠ è½½å™¨æ˜¯å¦ä¸ºç©º,å¦‚æœç±»åŠ è½½å™¨ä¸ä¸ºç©ºåˆ™ä½¿ç”¨æŒ‡å®šçš„ç±»åŠ è½½å™¨åŠ è½½ç±» è¿”å›GenericBeanDefinitionå¯¹è±¡ ä»¥ä¸Šé€»è¾‘æ¯”è¾ƒç®€å•,é‡ç‚¹æ˜¯GenericBeanDefinitionè¿™ä¸ªå¯¹è±¡. 2.3 GenericBeanDefinition â€‹ GenericBeanDefinitionæ˜¯ç”¨äºæè¿°bean,è¯¥ç±»ç»§æ‰¿äº†AbstractBeanDefinition.å¦‚ä¸‹å›¾: â€‹ æ€»å…±æœ‰2ä¸ªä½œç”¨,æè¿°beançš„ä¿¡æ¯,è®¿é—®beanä¸­çš„å±æ€§å€¼. 2.4 parseBeanDefinitionAttributes // BeanDefinitionParserDelegate public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName, @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) { // è§£æsingletonå±æ€§ // singletonå±æ€§ä¸èƒ½ä½¿ç”¨,å·²ç»è¿‡æ—¶ if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) { error(&quot;Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration&quot;, ele); } // åˆ¤æ–­æ˜¯å¦å­˜åœ¨scopeå±æ€§ else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) { // è®¾ç½®scopeå±æ€§å€¼ bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE)); } else if (containingBean != null) { // Take default from containing bean in case of an inner bean definition. bd.setScope(containingBean.getScope()); } // åˆ¤æ–­æ˜¯å¦å­˜åœ¨abstractå±æ€§ if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) { // è®¾ç½®abstractå±æ€§å€¼ bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE))); } // è§£ælazy-initå±æ€§ String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE); if (isDefaultValue(lazyInit)) { lazyInit = this.defaults.getLazyInit(); } // è®¾ç½®æ‡’åŠ è½½å€¼ bd.setLazyInit(TRUE_VALUE.equals(lazyInit)); // è·å–è‡ªåŠ¨è£…é…å±æ€§å€¼ String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE); // è®¾ç½®è‡ªåŠ¨è£…é…æ¨¡å¼ bd.setAutowireMode(getAutowireMode(autowire)); // åˆ¤æ–­æ˜¯å¦å­˜åœ¨depends-onå±æ€§ if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) { // è·å–depends-onå±æ€§å€¼ String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE); // è®¾ç½®depends-onå±æ€§å€¼ bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS)); } // è§£æautowireå±æ€§,è‡ªåŠ¨è£…é….å­˜åœ¨æ¡ä»¶åˆ¤æ–­ String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE); if (isDefaultValue(autowireCandidate)) { String candidatePattern = this.defaults.getAutowireCandidates(); if (candidatePattern != null) { String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern); bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName)); } } else { // è®¾ç½®autowire-candidateå±æ€§å€¼ bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate)); } // åˆ¤æ–­æ˜¯å¦å­˜åœ¨primaryå±æ€§ if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) { // è®¾ç½®primaryå€¼ bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE))); } // åˆ¤æ–­æ˜¯å¦å­˜åœ¨initå±æ€§ if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) { // è·å–initå±æ€§å€¼ String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE); // è®¾ç½®initå±æ€§å€¼ bd.setInitMethodName(initMethodName); } // è®¾ç½®initå±æ€§é»˜è®¤å€¼ else if (this.defaults.getInitMethod() != null) { bd.setInitMethodName(this.defaults.getInitMethod()); bd.setEnforceInitMethod(false); } // åˆ¤æ–­æ˜¯å¦å­˜åœ¨destroyå±æ€§ if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) { // è·å–destroyå±æ€§å€¼ String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE); // è®¾ç½®destroyå±æ€§å€¼ bd.setDestroyMethodName(destroyMethodName); } // è®¾ç½®destroyå±æ€§é»˜è®¤å€¼ else if (this.defaults.getDestroyMethod() != null) { bd.setDestroyMethodName(this.defaults.getDestroyMethod()); bd.setEnforceDestroyMethod(false); } // åˆ¤æ–­æ˜¯å¦å­˜åœ¨factoryå±æ€§ if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) { // è®¾ç½®factoryå±æ€§å€¼ bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE)); } // åˆ¤æ–­æ˜¯å¦å­˜åœ¨factory-beanå±æ€§ if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) { // è®¾ç½®factory-beanå±æ€§å€¼ bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE)); } return bd; } è®¾ç½®BeanDefinitionçš„scopeå±æ€§å€¼ è®¾ç½®BeanDefinitionçš„abstractå±æ€§å€¼ è®¾ç½®BeanDefinitionçš„lazy-initå±æ€§å€¼ è®¾ç½®BeanDefinitionçš„autowireå±æ€§å€¼ è®¾ç½®BeanDefinitionçš„depends-onå±æ€§å€¼ è®¾ç½®BeanDefinitionçš„autowire-candidateå±æ€§å€¼ è®¾ç½®BeanDefinitionçš„primaryå±æ€§å€¼ è®¾ç½®BeanDefinitionçš„init-methodå±æ€§å€¼ è®¾ç½®BeanDefinitionçš„destroy-methodå±æ€§å€¼ è®¾ç½®BeanDefinitionçš„factory-methodå±æ€§å€¼ è®¾ç½®BeanDefinitionçš„factory-beançš„å±æ€§å€¼ ä»¥ä¸Šä»£ç å°±æ˜¯å¯¹BeanDefinitionå¯¹è±¡çš„ä¸€ä¸ªå±æ€§å¡«å……. 2.5 parseMetaElements // BeanDefinitionParserDelegate public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) { // è§£æå…ƒæ•°æ® NodeList nl = ele.getChildNodes(); for (int i = 0; i &amp;lt; nl.getLength(); i++) { Node node = nl.item(i); // è§£æmetaæ ‡ç­¾ if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, META_ELEMENT)) { Element metaElement = (Element) node; String key = metaElement.getAttribute(KEY_ATTRIBUTE); String value = metaElement.getAttribute(VALUE_ATTRIBUTE); // ä½¿ç”¨kvæ–¹å¼åˆ›å»ºå¯¹è±¡ BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value); attribute.setSource(extractSource(metaElement)); // è®°å½•å±æ€§ attributeAccessor.addMetadataAttribute(attribute); } } } 1. éå†æ‰€æœ‰èŠ‚ç‚¹ 2. è§£æmetaæ ‡ç­¾ 3. è®¾ç½®å€¼åˆ°attributeAccessorä¸­ 2.6 parseLookupOverrideSubElements // BeanDefinitionParserDelegate public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) { // è·å–æ‰€æœ‰å­èŠ‚ç‚¹ NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &amp;lt; nl.getLength(); i++) { // éå†å­èŠ‚ç‚¹ Node node = nl.item(i); // åˆ¤æ–­æ˜¯lookup-method èŠ‚ç‚¹ if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) { Element ele = (Element) node; // è·å–nameå±æ€§ æ–¹æ³•å String methodName = ele.getAttribute(NAME_ATTRIBUTE); // è·å–beanå±æ€§ ç”¨äºæ›¿ä»£çš„beanåç§°,ç”¨äºå¼•ç”¨beanå¯¹è±¡ String beanRef = ele.getAttribute(BEAN_ELEMENT); // åˆ›å»ºLookupOverride å¯¹è±¡ LookupOverride override = new LookupOverride(methodName, beanRef); override.setSource(extractSource(ele)); // æ·»åŠ åˆ°overrideså¯¹è±¡ä¸­çš„é›†åˆä¸­ overrides.addOverride(override); } } } éå†æ‰€æœ‰èŠ‚ç‚¹ è·å–nameå±æ€§ è·å–beanå±æ€§ åˆ›å»ºLookupOverrideå¯¹è±¡ æ·»åŠ åˆ°MethodOverridesä¸­ â€‹ lookup-methodè¿™ä¸ªä¸œè¥¿,ç›¸å½“äºæ˜¯æ›¿æ¢ä¸€ä¸ªæ–¹æ³•,ä¸replaced-methodè¿™ä¸ªæœ‰äº›è®¸ä¸åŒ.åœ¨åé¢å¤„ç†beançš„æ—¶å€™è¿˜ä¼šå†æ¬¡å‡ºç°. 2.7 parseReplacedMethodSubElements // BeanDefinitionParserDelegate public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) { // è·å–æ‰€æœ‰èŠ‚ç‚¹ NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &amp;lt; nl.getLength(); i++) { // éå†æ‰€æœ‰èŠ‚ç‚¹ Node node = nl.item(i); // åˆ¤æ–­æ˜¯replaced-method èŠ‚ç‚¹ if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) { Element replacedMethodEle = (Element) node; // è·å–nameå±æ€§ String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE); // è·å–replacer å±æ€§ String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE); // åˆ›å»ºReplaceOverride å¯¹è±¡ ReplaceOverride replaceOverride = new ReplaceOverride(name, callback); // Look for arg-type match elements. // è·å–arg-type å­èŠ‚ç‚¹ List&amp;lt;Element&amp;gt; argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT); // éå†arg-type èŠ‚ç‚¹ for (Element argTypeEle : argTypeEles) { // è·å–match å±æ€§ String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE); // å¦‚æœmatchå±æ€§ä¸ºç©º è¯´æ˜æœ‰å­èŠ‚ç‚¹å¾ªç¯éå†å­èŠ‚ç‚¹å€¼,æ‹¼è£…å‚æ•° // å¦‚æœmatchå±æ€§ä¸ä¸ºç©º match å€¼å°±ä¸ºæœ¬èº« match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle)); if (StringUtils.hasText(match)) { replaceOverride.addTypeIdentifier(match); } } replaceOverride.setSource(extractSource(replacedMethodEle)); // æ·»åŠ åˆ°é›†åˆ overrides.addOverride(replaceOverride); } } } â€‹ é€»è¾‘ä¸lookup-methodå¤„ç†çš„å·®ä¸å¤š. 2.8 parseConstructorArgElements // BeanDefinitionParserDelegate public void parseConstructorArgElements(Element beanEle, BeanDefinition bd) { // è·å–æ‰€æœ‰å­èŠ‚ç‚¹ NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &amp;lt; nl.getLength(); i++) { // éå†å­èŠ‚ç‚¹ Node node = nl.item(i); // åˆ¤æ–­æ˜¯constructor-arg èŠ‚ç‚¹ if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) { parseConstructorArgElement((Element) node, bd); } } } éå†æ‰€æœ‰èŠ‚ç‚¹ æŸ¥æ‰¾èŠ‚ç‚¹constructor-arg è§£æå‚æ•° è§£æå‚æ•°çš„é€»è¾‘å•ç‹¬åœ¨ä¸€ä¸ªæ–¹æ³•ä¸­parseConstructorArgElementã€‚ // BeanDefinitionParserDelegate public void parseConstructorArgElement(Element ele, BeanDefinition bd) { // æå– index å±æ€§ String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE); // æå– type å±æ€§ String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE); // æå– name å±æ€§ String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); // å¤„ç† index å±æ€§é€»è¾‘ if (StringUtils.hasLength(indexAttr)) { try { // ä¸‹æ ‡è½¬æ¢ä¸º int int index = Integer.parseInt(indexAttr); // ä¸‹æ ‡ä¸å…è®¸å°äº0 if (index &amp;lt; 0) { error(&quot;'index' cannot be lower than 0&quot;, ele); } else { try { this.parseState.push(new ConstructorArgumentEntry(index)); // è§£æ properties å±æ€§ Object value = parsePropertyValue(ele, bd, null); ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value); // è®¾ç½® typeAttr å±æ€§å€¼ if (StringUtils.hasLength(typeAttr)) { valueHolder.setType(typeAttr); } // è®¾ç½® name å±æ€§å€¼ if (StringUtils.hasLength(nameAttr)) { valueHolder.setName(nameAttr); } valueHolder.setSource(extractSource(ele)); // åˆ¤æ–­ä¸‹æ ‡æ˜¯å¦é‡å¤ if (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) { error(&quot;Ambiguous constructor-arg entries for index &quot; + index, ele); } else { // æ·»åŠ  ä¸‹æ ‡ å‚æ•° bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder); } } finally { this.parseState.pop(); } } } catch (NumberFormatException ex) { error(&quot;Attribute 'index' of tag 'constructor-arg' must be an integer&quot;, ele); } } else { // ä¸åŒ…å« index å±æ€§å¤„ç†é€»è¾‘ try { this.parseState.push(new ConstructorArgumentEntry()); Object value = parsePropertyValue(ele, bd, null); ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value); if (StringUtils.hasLength(typeAttr)) { valueHolder.setType(typeAttr); } if (StringUtils.hasLength(nameAttr)) { valueHolder.setName(nameAttr); } valueHolder.setSource(extractSource(ele)); bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder); } finally { this.parseState.pop(); } } } é€šè¿‡åˆ¤æ–­æ˜¯å¦æœ‰indexå±æ€§æ¥è¿›è¡Œè§£æé…ç½®æ–‡ä»¶.è§£æå‚æ•°çš„ä»£ç ä¸ºparsePropertyValue(ele, bd, null); // BeanDefinitionParserDelegate @Nullable public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) { String elementName = (propertyName != null ? &quot;&amp;lt;property&amp;gt; element for property '&quot; + propertyName + &quot;'&quot; : &quot;&amp;lt;constructor-arg&amp;gt; element&quot;); // Should only have one child element: ref, value, list, etc. // è·å–æ‰€æœ‰å­èŠ‚ç‚¹ NodeList nl = ele.getChildNodes(); Element subElement = null; // éå†æ‰€æœ‰å­èŠ‚ç‚¹ for (int i = 0; i &amp;lt; nl.getLength(); i++) { Node node = nl.item(i); // description èŠ‚ç‚¹ å’Œ metaèŠ‚ç‚¹ ä¸å¤„ç† if (node instanceof Element &amp;amp;&amp;amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;amp;&amp;amp; !nodeNameEquals(node, META_ELEMENT)) { // Child element is what we're looking for. if (subElement != null) { error(elementName + &quot; must not contain more than one sub-element&quot;, ele); } else { subElement = (Element) node; } } } // åˆ¤æ–­æ˜¯å¤ŸåŒ…å« ref å±æ€§ boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE); // åˆ¤æ–­æ˜¯å¦åŒ…å« value å±æ€§ boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE); // å¦‚æœ [[åŒæ—¶åŒ…å« ref å±æ€§ å’Œ value å±æ€§] æˆ–è€… [[åŒ…å« ref å±æ€§ æˆ–è€… valueå±æ€§ ä¹‹ä¸€] å¹¶ä¸” subElement ä¸ä¸ºç©º]] // åˆ™ æŠ›å‡ºå¼‚å¸¸ if ((hasRefAttribute &amp;amp;&amp;amp; hasValueAttribute) || ((hasRefAttribute || hasValueAttribute) &amp;amp;&amp;amp; subElement != null)) { error(elementName + &quot; is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element&quot;, ele); } // å¤„ç†åªåŒ…å« ref å±æ€§é€»è¾‘ if (hasRefAttribute) { // è·å– ref å±æ€§å€¼ String refName = ele.getAttribute(REF_ATTRIBUTE); // å¦‚æœ ref å±æ€§å€¼ä¸ºç©º error if (!StringUtils.hasText(refName)) { error(elementName + &quot; contains empty 'ref' attribute&quot;, ele); } // åˆ›å»º RuntimeBeanReference å¯¹è±¡ RuntimeBeanReference ref = new RuntimeBeanReference(refName); ref.setSource(extractSource(ele)); return ref; } // å¤„ç†å€¼åŒ…å« value å±æ€§é€»è¾‘ else if (hasValueAttribute) { // åˆ›å»º TypedStringValue å¯¹è±¡ TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE)); valueHolder.setSource(extractSource(ele)); return valueHolder; } // å¤„ç†åªæœ‰å­å…ƒç´ é€»è¾‘ else if (subElement != null) { return parsePropertySubElement(subElement, bd); } // error else { // Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found. error(elementName + &quot; must specify a ref or value&quot;, ele); return null; } } éå†æ‰€æœ‰èŠ‚ç‚¹ description å’Œ meta èŠ‚ç‚¹ä¸å¤„ç†,è·³è¿‡. åˆ¤æ–­æ˜¯å¦åŒ…å« ref å±æ€§ åˆ¤æ–­æ˜¯å¦åŒ…å« value å±æ€§ å¤„ç† ref å¤„ç† value å¤„ç†å­å…ƒç´  â€‹ å¤„ç†é€»è¾‘ä¸å¤æ‚,å¤æ‚ç‚¹çš„å¯èƒ½æ˜¯åœ¨å¤„ç†å­å…ƒç´ çš„å®æ—¶,ç›¸å¯¹å¤æ‚ç‚¹.é€šå¸¸å­å…ƒç´ çš„å¤„ç†å°±æ˜¯æŠŠå€¼è½¬æ¢ä¸º Map\List\Setç­‰æ•°æ®ç»“æ„.å¤„ç†å­å…ƒç´ çš„æ–¹æ³•æ˜¯parsePropertySubElement. // BeanDefinitionParserDelegate @Nullable public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) { return parsePropertySubElement(ele, bd, null); } /** * Parse a value, ref or collection sub-element of a property or * constructor-arg element. * @param ele subelement of property element; we don't know which yet * @param bd the current bean definition (if any) * @param defaultValueType the default type (class name) for any * {@code &amp;lt;value&amp;gt;} tag that might be created */ @Nullable public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) { // å¤„ç†éé»˜è®¤åç§°ç©ºé—´ if (!isDefaultNamespace(ele)) { return parseNestedCustomElement(ele, bd); } // å¤„ç† bean else if (nodeNameEquals(ele, BEAN_ELEMENT)) { BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd); if (nestedBd != null) { nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd); } return nestedBd; } // å¤„ç† ref else if (nodeNameEquals(ele, REF_ELEMENT)) { // A generic reference to any name of any bean. // è·å– éœ€è¦å¼•ç”¨çš„ bean åç§° String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE); boolean toParent = false; // å¦‚æœ éœ€è¦å¼•ç”¨çš„bean åç§°ä¸ºç©º if (!StringUtils.hasLength(refName)) { // A reference to the id of another bean in a parent context. // è·å– éœ€è¦å¼•ç”¨çš„parent å±æ€§ refName = ele.getAttribute(PARENT_REF_ATTRIBUTE); toParent = true; // å¦‚æœ bean ä¸ºç©º å¹¶ä¸” parent å±æ€§éƒ½ä¸ºç©º åˆ™ error if (!StringUtils.hasLength(refName)) { error(&quot;'bean' or 'parent' is required for &amp;lt;ref&amp;gt; element&quot;, ele); return null; } } // å¦‚æœéœ€è¦å¼•ç”¨çš„ bean åç§° ä¾ç„¶ä¸ºç©º åˆ™ error if (!StringUtils.hasText(refName)) { error(&quot;&amp;lt;ref&amp;gt; element contains empty target attribute&quot;, ele); return null; } // åˆ›å»º RuntimeBeanReference å¯¹è±¡ RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent); ref.setSource(extractSource(ele)); return ref; } // å¤„ç† idref else if (nodeNameEquals(ele, IDREF_ELEMENT)) { return parseIdRefElement(ele); } // å¤„ç† value else if (nodeNameEquals(ele, VALUE_ELEMENT)) { return parseValueElement(ele, defaultValueType); } // å¤„ç† null else if (nodeNameEquals(ele, NULL_ELEMENT)) { // It's a distinguished null value. Let's wrap it in a TypedStringValue // object in order to preserve the source location. // åˆ›å»º TypedStringValue å¯¹è±¡ TypedStringValue nullHolder = new TypedStringValue(null); nullHolder.setSource(extractSource(ele)); return nullHolder; } // å¤„ç† array else if (nodeNameEquals(ele, ARRAY_ELEMENT)) { return parseArrayElement(ele, bd); } // å¤„ç† list else if (nodeNameEquals(ele, LIST_ELEMENT)) { return parseListElement(ele, bd); } // å¤„ç† set else if (nodeNameEquals(ele, SET_ELEMENT)) { return parseSetElement(ele, bd); } // å¤„ç† map else if (nodeNameEquals(ele, MAP_ELEMENT)) { return parseMapElement(ele, bd); } // å¤„ç† props else if (nodeNameEquals(ele, PROPS_ELEMENT)) { return parsePropsElement(ele); } // error else { error(&quot;Unknown property sub-element: [&quot; + ele.getNodeName() + &quot;]&quot;, ele); return null; } } â€‹ å¼€å¤´å°±æ˜¯ä¸€ä¸ªåˆ¤æ–­,åˆ¤æ–­æ˜¯å¦æ˜¯é»˜è®¤åç§°ç©ºé—´,å¦‚æœéé»˜è®¤åç§°ç©ºé—´é‡‡ç”¨è‡ªå®šä¹‰è§£æé€»è¾‘. 2.8.1 è‡ªå®šä¹‰è§£æ â€‹ åˆ›å»ºè‡ªå®šä¹‰xsd &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns=&quot;https://onew.me/schema/adv&quot; targetNamespace=&quot;https://onew.me/schema/adv&quot; elementFormDefault=&quot;qualified&quot;&amp;gt; &amp;lt;xsd:element name=&quot;AdvProp&quot;&amp;gt; &amp;lt;xsd:complexType&amp;gt; &amp;lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; /&amp;gt; &amp;lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:string&quot; /&amp;gt; &amp;lt;/xsd:complexType&amp;gt; &amp;lt;/xsd:element&amp;gt; &amp;lt;/xsd:schema&amp;gt; â€‹ åˆ›å»ºç±» package com.sjr.test.bean; public class AdvProp { private String name; private String age; public String getName() { return name; } public AdvProp setName(String name) { this.name = name; return this; } public String getAge() { return age; } public AdvProp setAge(String age) { this.age = age; return this; } } â€‹ ä¿®æ”¹æµ‹è¯•ç±» package com.sjr.test.bean; public class MyTestBean { private AdvProp advProp; private String testStr = &quot;test--one&quot;; public MyTestBean(AdvProp advProp) { this.advProp = advProp; } public MyTestBean() { } public String getTestStr() { return testStr; } public MyTestBean setTestStr(String testStr) { this.testStr = testStr; return this; } public AdvProp getAdvProp() { return advProp; } public MyTestBean setAdvProp(AdvProp advProp) { this.advProp = advProp; return this; } public void printAdvProp(){ System.out.println(&quot;advProp: age-&quot; + advProp.getAge() + &quot;,name-&quot; + advProp.getName()); } } â€‹ åˆ›å»ºè‡ªå®šä¹‰è§£æç±» public class TestAdvPropParser extends AbstractSingleBeanDefinitionParser { @Override protected Class&amp;lt;?&amp;gt; getBeanClass(Element element) { return AdvProp.class; } @Override protected void doParse(Element element, BeanDefinitionBuilder builder) { final String name = element.getAttribute(&quot;name&quot;); final String age = element.getAttribute(&quot;age&quot;); builder.addPropertyValue(&quot;name&quot;,name); builder.addPropertyValue(&quot;age&quot;,age); } } â€‹ åˆ›å»ºè‡ªå®šä¹‰NamespaceHandlerç±» public class TestNamespaceHandler extends NamespaceHandlerSupport { @Override public void init() { registerBeanDefinitionParser(&quot;AdvProp&quot;,new TestAdvPropParser()); } } â€‹ é…ç½®spring.handlers https\://onew.me/schema/adv=com.sjr.test.handler.TestNamespaceHandler â€‹ é…ç½®spring.schemas https\://onew.me/schema/adv/AdvProp.xsd=com/sjr/test/bean/AdvProp.xsd â€‹ é…ç½®xml &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&amp;gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:adv=&quot;https://onew.me/schema/adv&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd https://onew.me/schema/adv https://onew.me/schema/adv/AdvProp.xsd &quot;&amp;gt; &amp;lt;bean id=&quot;myTestBean&quot; class=&quot;com.sjr.test.bean.MyTestBean&quot;&amp;gt; &amp;lt;constructor-arg&amp;gt; &amp;lt;adv:AdvProp name=&quot;testAdv&quot; age=&quot;31&quot;/&amp;gt; &amp;lt;/constructor-arg&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/beans&amp;gt; â€‹ ä¿®æ”¹æµ‹è¯•ä»£ç  @Test public void testSpringAdvParseTag(){ BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/AdvTestBean.xml&quot;)); final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class); testBean.printAdvProp(); } â€‹ è¿è¡Œç»“æœ advProp: age-31,name-testAdv TestNamespaceHandlerç”¨äºæ³¨å†Œè‡ªå®šä¹‰è§£æå™¨ TestAdvPropParserç”¨äºè§£æè‡ªå®šä¹‰æ ‡ç­¾ spring.schemasç”¨äºæè¿°xsdæ–‡ä»¶è·¯å¾„ spring.handlersç”¨äºæŒ‡å®šè‡ªå®šä¹‰åç§°ç©ºé—´ä½¿ç”¨æŒ‡å®šçš„handler 2.8.2 è§£æbeanæ ‡ç­¾ â€‹ è§£æé€»è¾‘ä¸beanæ ‡ç­¾é€»è¾‘ä¸€è‡´ // BeanDefinitionParserDelegate // å¤„ç† bean else if (nodeNameEquals(ele, BEAN_ELEMENT)) { BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd); if (nestedBd != null) { nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd); } return nestedBd; } 2.8.3 è§£ærefæ ‡ç­¾ // BeanDefinitionParserDelegate if (nodeNameEquals(ele, REF_ELEMENT)) { // A generic reference to any name of any bean. // è·å– éœ€è¦å¼•ç”¨çš„ bean åç§° String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE); boolean toParent = false; // å¦‚æœ éœ€è¦å¼•ç”¨çš„bean åç§°ä¸ºç©º if (!StringUtils.hasLength(refName)) { // A reference to the id of another bean in a parent context. // è·å– éœ€è¦å¼•ç”¨çš„parent å±æ€§ refName = ele.getAttribute(PARENT_REF_ATTRIBUTE); toParent = true; // å¦‚æœ bean ä¸ºç©º å¹¶ä¸” parent å±æ€§éƒ½ä¸ºç©º åˆ™ error if (!StringUtils.hasLength(refName)) { error(&quot;'bean' or 'parent' is required for &amp;lt;ref&amp;gt; element&quot;, ele); return null; } } // å¦‚æœéœ€è¦å¼•ç”¨çš„ bean åç§° ä¾ç„¶ä¸ºç©º åˆ™ error if (!StringUtils.hasText(refName)) { error(&quot;&amp;lt;ref&amp;gt; element contains empty target attribute&quot;, ele); return null; } // åˆ›å»º RuntimeBeanReference å¯¹è±¡ RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent); ref.setSource(extractSource(ele)); return ref; } 2.8.4 è§£æidrefæ ‡ç­¾ // BeanDefinitionParserDelegate @Nullable public Object parseIdRefElement(Element ele) { // A generic reference to any name of any bean. // è·å–éœ€è¦å¼•ç”¨çš„ bean å±æ€§ String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE); // å¼•ç”¨çš„åç§°ä¸ºç©º åˆ™ error if (!StringUtils.hasLength(refName)) { error(&quot;'bean' is required for &amp;lt;idref&amp;gt; element&quot;, ele); return null; } // å¼•ç”¨çš„åç§°ä¸ºç©º åˆ™ error if (!StringUtils.hasText(refName)) { error(&quot;&amp;lt;idref&amp;gt; element contains empty target attribute&quot;, ele); return null; } // åˆ›å»º RuntimeBeanNameReference RuntimeBeanNameReference ref = new RuntimeBeanNameReference(refName); ref.setSource(extractSource(ele)); return ref; } 2.8.5 è§£ævalueæ ‡ç­¾ // BeanDefinitionParserDelegate public Object parseValueElement(Element ele, @Nullable String defaultTypeName) { // It's a literal value. // è·å–æ–‡æœ¬å€¼ String value = DomUtils.getTextValue(ele); // è·å– type å±æ€§ String specifiedTypeName = ele.getAttribute(TYPE_ATTRIBUTE); String typeName = specifiedTypeName; // å¦‚æœ type å±æ€§ä¸ºç©º åˆ™ è®¾ç½®ä¸ºé»˜è®¤çš„ type if (!StringUtils.hasText(typeName)) { // é»˜è®¤ä¸º null typeName = defaultTypeName; } try { // åˆ›å»º TypedStringValue å¯¹è±¡ TypedStringValue typedValue = buildTypedStringValue(value, typeName); typedValue.setSource(extractSource(ele)); typedValue.setSpecifiedTypeName(specifiedTypeName); return typedValue; } catch (ClassNotFoundException ex) { error(&quot;Type class [&quot; + typeName + &quot;] not found for &amp;lt;value&amp;gt; element&quot;, ele, ex); return value; } } 2.8.6 è§£æarray æ ‡ç­¾ // BeanDefinitionParserDelegate public Object parseArrayElement(Element arrayEle, @Nullable BeanDefinition bd) { // è·å– value-type å±æ€§ String elementType = arrayEle.getAttribute(VALUE_TYPE_ATTRIBUTE); // è·å–æ‰€æœ‰å­èŠ‚ç‚¹ NodeList nl = arrayEle.getChildNodes(); // åˆ›å»º ManagedArray å¯¹è±¡ ManagedArray target = new ManagedArray(elementType, nl.getLength()); target.setSource(extractSource(arrayEle)); target.setElementTypeName(elementType); target.setMergeEnabled(parseMergeAttribute(arrayEle)); parseCollectionElements(nl, target, bd, elementType); return target; } 2.8.7 è§£ælistæ ‡ç­¾ // BeanDefinitionParserDelegate public List&amp;lt;Object&amp;gt; parseListElement(Element collectionEle, @Nullable BeanDefinition bd) { // è·å– value-type å±æ€§ String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE); // è·å–æ‰€æœ‰å­èŠ‚ç‚¹ NodeList nl = collectionEle.getChildNodes(); // åˆ›å»º ManagedList å¯¹è±¡ ManagedList&amp;lt;Object&amp;gt; target = new ManagedList&amp;lt;&amp;gt;(nl.getLength()); target.setSource(extractSource(collectionEle)); target.setElementTypeName(defaultElementType); target.setMergeEnabled(parseMergeAttribute(collectionEle)); parseCollectionElements(nl, target, bd, defaultElementType); return target; } 2.8.8 è§£æsetæ ‡ç­¾ // BeanDefinitionParserDelegate public Set&amp;lt;Object&amp;gt; parseSetElement(Element collectionEle, @Nullable BeanDefinition bd) { // è·å– value-type å±æ€§ String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE); // è·å–æ‰€æœ‰å­èŠ‚ç‚¹ NodeList nl = collectionEle.getChildNodes(); // åˆ›å»º ManagedSet å¯¹è±¡ ManagedSet&amp;lt;Object&amp;gt; target = new ManagedSet&amp;lt;&amp;gt;(nl.getLength()); target.setSource(extractSource(collectionEle)); target.setElementTypeName(defaultElementType); target.setMergeEnabled(parseMergeAttribute(collectionEle)); parseCollectionElements(nl, target, bd, defaultElementType); return target; } 2.8.9 è§£æmapæ ‡ç­¾ // BeanDefinitionParserDelegate public Map&amp;lt;Object, Object&amp;gt; parseMapElement(Element mapEle, @Nullable BeanDefinition bd) { // è·å– key-type å±æ€§å€¼ String defaultKeyType = mapEle.getAttribute(KEY_TYPE_ATTRIBUTE); // è·å– value-type å±æ€§å€¼ String defaultValueType = mapEle.getAttribute(VALUE_TYPE_ATTRIBUTE); // è·å– entry å­èŠ‚ç‚¹ List&amp;lt;Element&amp;gt; entryEles = DomUtils.getChildElementsByTagName(mapEle, ENTRY_ELEMENT); // åˆ›å»º ManagedMap å¯¹è±¡ ManagedMap&amp;lt;Object, Object&amp;gt; map = new ManagedMap&amp;lt;&amp;gt;(entryEles.size()); map.setSource(extractSource(mapEle)); map.setKeyTypeName(defaultKeyType); map.setValueTypeName(defaultValueType); map.setMergeEnabled(parseMergeAttribute(mapEle)); // éå† entryEles é›†åˆ for (Element entryEle : entryEles) { // Should only have one value child element: ref, value, list, etc. // Optionally, there might be a key child element. // è·å–å­èŠ‚ç‚¹ NodeList entrySubNodes = entryEle.getChildNodes(); Element keyEle = null; Element valueEle = null; // éå† entrySubNodes for (int j = 0; j &amp;lt; entrySubNodes.getLength(); j++) { Node node = entrySubNodes.item(j); if (node instanceof Element) { Element candidateEle = (Element) node; // å¤„ç† key èŠ‚ç‚¹é€»è¾‘ if (nodeNameEquals(candidateEle, KEY_ELEMENT)) { if (keyEle != null) { error(&quot;&amp;lt;entry&amp;gt; element is only allowed to contain one &amp;lt;key&amp;gt; sub-element&quot;, entryEle); } else { keyEle = candidateEle; } } else { // å¿½ç•¥ description èŠ‚ç‚¹ // Child element is what we're looking for. if (nodeNameEquals(candidateEle, DESCRIPTION_ELEMENT)) { // the element is a &amp;lt;description&amp;gt; -&amp;gt; ignore it } else if (valueEle != null) { error(&quot;&amp;lt;entry&amp;gt; element must not contain more than one value sub-element&quot;, entryEle); } else { valueEle = candidateEle; } } } } // Extract key from attribute or sub-element. Object key = null; // åˆ¤æ–­æ˜¯å¦åŒ…å« key å±æ€§ boolean hasKeyAttribute = entryEle.hasAttribute(KEY_ATTRIBUTE); // åˆ¤æ–­æ˜¯å¦åŒ…å« key-ref å±æ€§ boolean hasKeyRefAttribute = entryEle.hasAttribute(KEY_REF_ATTRIBUTE); // å¦‚æœ [[åŒ…å« key å±æ€§ å¹¶ä¸” åŒ…å« key-ref å±æ€§] æˆ–è€… [[åŒ…å« key å±æ€§ æˆ– åŒ…å« key-ref ä¹‹ä¸€]] å¹¶ä¸” keyEle ä¸ä¸ºç©º] // åˆ™ æŠ¥é”™ if ((hasKeyAttribute &amp;amp;&amp;amp; hasKeyRefAttribute) || (hasKeyAttribute || hasKeyRefAttribute) &amp;amp;&amp;amp; keyEle != null) { error(&quot;&amp;lt;entry&amp;gt; element is only allowed to contain either &quot; + &quot;a 'key' attribute OR a 'key-ref' attribute OR a &amp;lt;key&amp;gt; sub-element&quot;, entryEle); } // å¤„ç† key å±æ€§ if (hasKeyAttribute) { key = buildTypedStringValueForMap(entryEle.getAttribute(KEY_ATTRIBUTE), defaultKeyType, entryEle); } // å¤„ç† key-ref å±æ€§ else if (hasKeyRefAttribute) { String refName = entryEle.getAttribute(KEY_REF_ATTRIBUTE); if (!StringUtils.hasText(refName)) { error(&quot;&amp;lt;entry&amp;gt; element contains empty 'key-ref' attribute&quot;, entryEle); } RuntimeBeanReference ref = new RuntimeBeanReference(refName); ref.setSource(extractSource(entryEle)); key = ref; } else if (keyEle != null) { key = parseKeyElement(keyEle, bd, defaultKeyType); } else { error(&quot;&amp;lt;entry&amp;gt; element must specify a key&quot;, entryEle); } // Extract value from attribute or sub-element. Object value = null; // åˆ¤æ–­ æ˜¯å¦åŒ…å« value å±æ€§ boolean hasValueAttribute = entryEle.hasAttribute(VALUE_ATTRIBUTE); // åˆ¤æ–­ æ˜¯å¦åŒ…å« value-ref å±æ€§ boolean hasValueRefAttribute = entryEle.hasAttribute(VALUE_REF_ATTRIBUTE); // åˆ¤æ–­ æ˜¯å¦åŒ…å« value-type å±æ€§ boolean hasValueTypeAttribute = entryEle.hasAttribute(VALUE_TYPE_ATTRIBUTE); if ((hasValueAttribute &amp;amp;&amp;amp; hasValueRefAttribute) || (hasValueAttribute || hasValueRefAttribute) &amp;amp;&amp;amp; valueEle != null) { error(&quot;&amp;lt;entry&amp;gt; element is only allowed to contain either &quot; + &quot;'value' attribute OR 'value-ref' attribute OR &amp;lt;value&amp;gt; sub-element&quot;, entryEle); } if ((hasValueTypeAttribute &amp;amp;&amp;amp; hasValueRefAttribute) || (hasValueTypeAttribute &amp;amp;&amp;amp; !hasValueAttribute) || (hasValueTypeAttribute &amp;amp;&amp;amp; valueEle != null)) { error(&quot;&amp;lt;entry&amp;gt; element is only allowed to contain a 'value-type' &quot; + &quot;attribute when it has a 'value' attribute&quot;, entryEle); } // å¤„ç† value å±æ€§ if (hasValueAttribute) { String valueType = entryEle.getAttribute(VALUE_TYPE_ATTRIBUTE); if (!StringUtils.hasText(valueType)) { valueType = defaultValueType; } value = buildTypedStringValueForMap(entryEle.getAttribute(VALUE_ATTRIBUTE), valueType, entryEle); } // å¤„ç† value-ref å±æ€§ else if (hasValueRefAttribute) { String refName = entryEle.getAttribute(VALUE_REF_ATTRIBUTE); if (!StringUtils.hasText(refName)) { error(&quot;&amp;lt;entry&amp;gt; element contains empty 'value-ref' attribute&quot;, entryEle); } RuntimeBeanReference ref = new RuntimeBeanReference(refName); ref.setSource(extractSource(entryEle)); value = ref; } // å¤„ç† valueEle else if (valueEle != null) { value = parsePropertySubElement(valueEle, bd, defaultValueType); } else { error(&quot;&amp;lt;entry&amp;gt; element must specify a value&quot;, entryEle); } // Add final key and value to the Map. // æ·»åŠ æœ€ç»ˆçš„ key å’Œ value åˆ° map ä¸­å» map.put(key, value); } return map; } è½¬æ¢ä¸ºmapçš„æ—¶å€™é€»è¾‘ç¨å¾®æœ‰ç‚¹å¤æ‚,æ…¢æ…¢çœ‹,è¿˜æ˜¯èƒ½çœ‹æ‡‚. 2.8.10 è§£æpropsæ ‡ç­¾ // BeanDefinitionParserDelegate public Properties parsePropsElement(Element propsEle) { // åˆ›å»º ManagedProperties å¯¹è±¡ ManagedProperties props = new ManagedProperties(); props.setSource(extractSource(propsEle)); props.setMergeEnabled(parseMergeAttribute(propsEle)); //è·å–èŠ‚ç‚¹ä¸‹é¢ç´ æœ‰ prop èŠ‚ç‚¹ List&amp;lt;Element&amp;gt; propEles = DomUtils.getChildElementsByTagName(propsEle, PROP_ELEMENT); // éå† prop èŠ‚ç‚¹ for (Element propEle : propEles) { // è·å– key String key = propEle.getAttribute(KEY_ATTRIBUTE); // Trim the text value to avoid unwanted whitespace // caused by typical XML formatting. // è·å– å€¼ String value = DomUtils.getTextValue(propEle).trim(); TypedStringValue keyHolder = new TypedStringValue(key); keyHolder.setSource(extractSource(propEle)); TypedStringValue valueHolder = new TypedStringValue(value); valueHolder.setSource(extractSource(propEle)); // æ”¾å…¥åˆ° props å¯¹è±¡ä¸­ props.put(keyHolder, valueHolder); } return props; } 2.9 parsePropertyElements // BeanDefinitionParserDelegate public void parsePropertyElements(Element beanEle, BeanDefinition bd) { // è·å–æ‰€æœ‰å­èŠ‚ç‚¹ NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &amp;lt; nl.getLength(); i++) { // éå† æ‰€æœ‰èŠ‚ç‚¹ Node node = nl.item(i); if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, PROPERTY_ELEMENT)) { parsePropertyElement((Element) node, bd); } } } public void parsePropertyElement(Element ele, BeanDefinition bd) { // è·å– name å±æ€§ String propertyName = ele.getAttribute(NAME_ATTRIBUTE); // name å±æ€§ä¸ºç©º åˆ™æŠ¥é”™ if (!StringUtils.hasLength(propertyName)) { error(&quot;Tag 'property' must have a 'name' attribute&quot;, ele); return; } this.parseState.push(new PropertyEntry(propertyName)); try { // å±æ€§åç›¸åŒåˆ™æŠ¥é”™ if (bd.getPropertyValues().contains(propertyName)) { error(&quot;Multiple 'property' definitions for property '&quot; + propertyName + &quot;'&quot;, ele); return; } Object val = parsePropertyValue(ele, bd, propertyName); PropertyValue pv = new PropertyValue(propertyName, val); parseMetaElements(ele, pv); pv.setSource(extractSource(ele)); bd.getPropertyValues().addPropertyValue(pv); } finally { this.parseState.pop(); } } éå†æ‰€æœ‰èŠ‚ç‚¹ ä½¿ç”¨parsePropertyValueæ–¹æ³•å¤„ç†å€¼(è¯¥æ–¹æ³•å·²ç»å†™åˆ°è¿‡) æŠŠè§£æåˆ°çš„å€¼æ”¾å…¥BeanDefinitionä¸­å» 2.10 parseQualifierElements // BeanDefinitionParserDelegate public void parseQualifierElements(Element beanEle, AbstractBeanDefinition bd) { // è·å–æ‰€æœ‰å­èŠ‚ç‚¹ NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &amp;lt; nl.getLength(); i++) { // éå†æ‰€æœ‰å­èŠ‚ç‚¹ Node node = nl.item(i); // å¤„ç† qualifier èŠ‚ç‚¹ if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, QUALIFIER_ELEMENT)) { parseQualifierElement((Element) node, bd); } } } éå†æ‰€æœ‰èŠ‚ç‚¹ é€šè¿‡parseQualifierElementæ–¹æ³•å¤„ç† // BeanDefinitionParserDelegate public void parseQualifierElement(Element ele, AbstractBeanDefinition bd) { // è·å– type å±æ€§ String typeName = ele.getAttribute(TYPE_ATTRIBUTE); // å¦‚æœ type å±æ€§ä¸ºç©º åˆ™ error if (!StringUtils.hasLength(typeName)) { error(&quot;Tag 'qualifier' must have a 'type' attribute&quot;, ele); return; } this.parseState.push(new QualifierEntry(typeName)); try { // åˆ›å»º AutowireCandidateQualifier å¯¹è±¡ AutowireCandidateQualifier qualifier = new AutowireCandidateQualifier(typeName); qualifier.setSource(extractSource(ele)); // è·å– value å±æ€§ String value = ele.getAttribute(VALUE_ATTRIBUTE); if (StringUtils.hasLength(value)) { qualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value); } // è·å–å½“å‰èŠ‚ç‚¹ä¸‹çš„æ‰€æœ‰èŠ‚ç‚¹ NodeList nl = ele.getChildNodes(); for (int i = 0; i &amp;lt; nl.getLength(); i++) { // éå†æ‰€æœ‰å­èŠ‚ç‚¹ Node node = nl.item(i); // å¤„ç† attribute å±æ€§ if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) { Element attributeEle = (Element) node; // è·å– key å±æ€§ String attributeName = attributeEle.getAttribute(KEY_ATTRIBUTE); // è·å– value å±æ€§ String attributeValue = attributeEle.getAttribute(VALUE_ATTRIBUTE); // key and value is not null if (StringUtils.hasLength(attributeName) &amp;amp;&amp;amp; StringUtils.hasLength(attributeValue)) { BeanMetadataAttribute attribute = new BeanMetadataAttribute(attributeName, attributeValue); attribute.setSource(extractSource(attributeEle)); qualifier.addMetadataAttribute(attribute); } else { error(&quot;Qualifier 'attribute' tag must have a 'name' and 'value'&quot;, attributeEle); return; } } } bd.addQualifier(qualifier); } finally { this.parseState.pop(); } } éå†æ‰€æœ‰èŠ‚ç‚¹ æŠŠè·å–åˆ°çš„kvå…¨éƒ¨æ”¾å…¥åˆ°AutowireCandidateQualifierå¯¹è±¡ä¸­å» BeanDefinitionå¯¹è±¡è®¾ç½®qualifierå±æ€§ ä¸‰ã€å°ç»“ â€‹ è‡³æ­¤å·²ç»åˆ›å»ºä¸€äº†ä¸€ä¸ªå®Œæ•´çš„AbstractBeanDefinitionå¯¹è±¡,ä¸€ä¸ªå¯¹beanä¿¡æ¯çš„æè¿°å¯¹è±¡æœ‰äº†,ä¼šè½¬ä¸ºBeanDefinitionHolderä¸ºåç»­æ“ä½œä½œä¸ºåŸºç¡€.</summary></entry><entry><title type="html">[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-xmlæ ‡ç­¾è§£æ(å››)</title><link href="https://onew.me/spring/2020/02/14/debug-spring-4.html" rel="alternate" type="text/html" title="[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-xmlæ ‡ç­¾è§£æ(å››)" /><published>2020-02-14T14:20:25+08:00</published><updated>2020-02-14T14:20:25+08:00</updated><id>https://onew.me/spring/2020/02/14/debug-spring-4</id><content type="html" xml:base="https://onew.me/spring/2020/02/14/debug-spring-4.html"># ä¸€ã€å‰è¨€

â€‹	æ¥ä¸Šæ–‡,åˆ†æäº†spring æŠŠ xml æ–‡ä»¶è¯»å–åˆ°å†…å­˜ä¸­,å¹¶ç”Ÿæˆä¸€ä¸ª`document`å¯¹è±¡,ç„¶è€Œç¦»åˆ›å»º`bean`è¿˜æ¯”è¾ƒé¥è¿œ.åœ¨xmlä¸­å®šäº†`bean`è¯¥å¦‚ä½•åˆ›å»ºçš„è§„åˆ™,è€Œspringä¹Ÿæ˜¯éµå¾ªxmlä¸­çš„æ ‡ç­¾æ‰€æè¿°è§„åˆ™æ¥è¿›è¡Œåˆ›å»º`bean`.æ¥ä¸‹æ¥å°±æ˜¯è¦åˆ†æ,springæ˜¯å¦‚ä½•è§£æè¿™äº›æ ‡ç­¾çš„.



# äºŒã€åˆ†æ

â€‹	è¿˜æ˜¯å¸¸è§„å¥—è·¯,ä»ä¸‹é¢çš„æµ‹è¯•ä»£ç å¼€å§‹.

```java
@Test
	public void testSpringLoadXml(){
		BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBean.xml&quot;));
		final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);
		final String testStr = testBean.getTestStr();
		System.out.println(testStr);
	}
```

â€‹	xmlå†…å®¹å¦‚ä¸‹:

```xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                       https://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;
	&lt;bean id=&quot;myTestBean&quot; class=&quot;com.sjr.test.bean.MyTestBean&quot;/&gt;
&lt;/beans&gt;

```

â€‹	ç»“åˆxml,å°±å¯ä»¥è®©springåˆ›å»ºä¸€ä¸ª`MyTestBean`å¯¹è±¡å‡ºæ¥.é‚£ä¹ˆspringæ˜¯æ€ä¹ˆåŠåˆ°çš„å‘¢?

```java
// XmlBeanDefinitionReader
protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
			throws BeanDefinitionStoreException {

		try {
			// åŠ è½½xml
      // åŠ è½½xmlçš„æ—¶å€™è¿™é‡Œå·²ç»è®²è¿‡äº†
			Document doc = doLoadDocument(inputSource, resource);
			// æ³¨å†Œbean
			int count = registerBeanDefinitions(doc, resource);
			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource);
			}
			return count;
		}
		catch (BeanDefinitionStoreException ex) {
			throw ex;
		}
		catch (SAXParseException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					&quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);
		}
		catch (SAXException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					&quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);
		}
		catch (ParserConfigurationException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;Parser configuration exception parsing XML from &quot; + resource, ex);
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;IOException parsing XML document from &quot; + resource, ex);
		}
		catch (Throwable ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;Unexpected exception parsing XML document from &quot; + resource, ex);
		}
	}
```

â€‹	çœ‹æ¥ç­”æ¡ˆå‡ºç°åœ¨`int count = registerBeanDefinitions(doc, resource);`è¿™å¥ä»£ç é‡Œé¢

## 2.1 registerBeanDefinitions()

```java
//xmlBeanDefinitionReader
/***
* @param doc é€šè¿‡xml åˆ›å»ºçš„documentå¯¹è±¡
* @param resource xml èµ„æºå¯¹è±¡
* @return æ³¨å†Œçš„æ•°é‡
*/
public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
		// åˆ›å»ºBeanDefinitionDocumentReader é»˜è®¤æ˜¯DefaultBeanDefinitionDocumentReader
		BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
		// è·å–å·²ç»æ³¨å†Œçš„beançš„æ•°é‡,beanDefinitionMap.size()
		int countBefore = getRegistry().getBeanDefinitionCount();
    // æ³¨å†Œxml beanå®šä¹‰
		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
  	// è¿”å›å·²ç»æ³¨å†Œçš„æ•°é‡
		return getRegistry().getBeanDefinitionCount() - countBefore;
	}
```

â€‹	è§£æxmlæ ‡ç­¾çš„æ ¸å¿ƒé€»è¾‘åœ¨äº`documentReader.registerBeanDefinitions(doc, createReaderContext(resource));`,é€æ­¥åˆ†æä¸€ä¸‹.



## 2.2 createReaderContext(resource)

```java
//xmlBeanDefinitionReader
public XmlReaderContext createReaderContext(Resource resource) {
		return new XmlReaderContext(resource, this.problemReporter, this.eventListener,
				this.sourceExtractor, this, getNamespaceHandlerResolver());
	}
```

â€‹	è¿™ä¸ªå¯¹è±¡ç›¸å½“äºæ˜¯ä¸ªå·¥å…·ç±»,é‡Œé¢æœªå°è£…é€»è¾‘ä»£ç .å°è£…äº†ä¸€äº›æ—¥å¿—ç›¸å…³çš„å‡½æ•°,è·å–resourceçš„å‡½æ•°ç­‰.è¿™é‡Œå€¼å¾—æ³¨æ„æ˜¯`getNamespaceHandlerResolver()`è¿™ä¸ªæ–¹æ³•,è¿™ä¸ªæ–¹æ³•è¿”å›äº†ä¸€ä¸ª`NamespaceHandlerResolver`å¯¹è±¡,è¿™ä¸ªå¯¹è±¡æ˜¯ç”¨äºè§£ææŒ‡å®šåç§°ç©ºé—´çš„è§£æå™¨,å¦‚æœè¦è‡ªå®šä¹‰æ ‡ç­¾å°±å¾—è¦è¿™ä¸ªå¯¹è±¡æ¥å¸®å¿™.



```java
 //xmlBeanDefinitionReader
	public NamespaceHandlerResolver getNamespaceHandlerResolver() {
		// å¦‚æœåç§°ç©ºé—´è§£æå™¨ä¸ºç©º,åˆ™åˆ›å»ºä¸€ä¸ªé»˜è®¤çš„åç§°ç©ºé—´è§£æå™¨
    if (this.namespaceHandlerResolver == null) {
			this.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();
		}
		return this.namespaceHandlerResolver;
	}

	/**
	 * Create the default implementation of {@link NamespaceHandlerResolver} used if none is specified.
	 * &lt;p&gt;The default implementation returns an instance of {@link DefaultNamespaceHandlerResolver}.
	 * @see DefaultNamespaceHandlerResolver#DefaultNamespaceHandlerResolver(ClassLoader)
	 */
	protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() {
		// è·å–classLoader
    ClassLoader cl = (getResourceLoader() != null ? getResourceLoader().getClassLoader() : getBeanClassLoader());
    // åˆ›å»ºé»˜è®¤çš„åç§°ç©ºé—´è§£æå™¨
		return new DefaultNamespaceHandlerResolver(cl);
	}
```



## 2.3 registerBeanDefinitions()

```java
 // DefaultBeanDefinitionDocumentReader
	// bean
	public static final String BEAN_ELEMENT = BeanDefinitionParserDelegate.BEAN_ELEMENT;

	public static final String NESTED_BEANS_ELEMENT = &quot;beans&quot;;

	public static final String ALIAS_ELEMENT = &quot;alias&quot;;

	public static final String NAME_ATTRIBUTE = &quot;name&quot;;

	public static final String ALIAS_ATTRIBUTE = &quot;alias&quot;;

	public static final String IMPORT_ELEMENT = &quot;import&quot;;

	public static final String RESOURCE_ATTRIBUTE = &quot;resource&quot;;

	public static final String PROFILE_ATTRIBUTE = &quot;profile&quot;;


	@Override
	public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
		this.readerContext = readerContext;
		doRegisterBeanDefinitions(doc.getDocumentElement());
	}

	protected void doRegisterBeanDefinitions(Element root) {
		// Any nested &lt;beans&gt; elements will cause recursion in this method. In
		// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,
		// keep track of the current (parent) delegate, which may be null. Create
		// the new (child) delegate with a reference to the parent for fallback purposes,
		// then ultimately reset this.delegate back to its original (parent) reference.
		// this behavior emulates a stack of delegates without actually necessitating one.
		// rootèŠ‚ç‚¹è¿›æ¥é»˜è®¤å§”æ‰˜ä¸ºnull
		BeanDefinitionParserDelegate parent = this.delegate;
		// åˆ›å»ºå§”æ‰˜,ç”¨äºè§£æå„ä¸ªæ ‡ç­¾
    // BeanDefinitionParserDelegate
		this.delegate = createDelegate(getReaderContext(), root, parent);

		// å¤„ç†profileå±æ€§,ç”¨äºåˆ‡æ¢ä¸åŒç¯å¢ƒçš„é…ç½®æ–‡ä»¶
		if (this.delegate.isDefaultNamespace(root)) {
			// åˆ¤æ–­æ˜¯å¦å«æœ‰profileå±æ€§
			String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
			// å¦‚æœprofileå±æ€§ä¸ä¸ºç©º
			if (StringUtils.hasText(profileSpec)) {
				// å¯èƒ½ä¼šæœ‰å¤šä¸ªprofileå±æ€§,ä½¿ç”¨,;è¿›è¡Œåˆ†å‰²
				String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
						profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
				// We cannot use Profiles.of(...) since profile expressions are not supported
				// in XML config. See SPR-12458 for details.
				// å¦‚æœä¸æ˜¯æœ‰æ•ˆçš„profile åˆ™è¿”å›
				if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +
								&quot;] not matching: &quot; + getReaderContext().getResource());
					}
					return;
				}
			}
		}
		// å‰ç½®è§£æå™¨(ç©ºé€»è¾‘,ç•™ç»™å­ç±»å»å®Œå–„)
		preProcessXml(root);
		// æ ¸å¿ƒé€»è¾‘
		parseBeanDefinitions(root, this.delegate);
		// åç½®è§£æå™¨(ç©ºé€»è¾‘,ç•™ç»™å­ç±»å»å®Œå–„)
		postProcessXml(root);

		this.delegate = parent;
	}
```

1. æ ¹èŠ‚ç‚¹é»˜è®¤æ²¡æœ‰çˆ¶èŠ‚ç‚¹ä¸ºNULL
2. åˆ›å»ºå§”æ‰˜ç”¨äºè§£æxmlæ ‡ç­¾
3. åˆ¤æ–­æ˜¯å¦æœ‰å¤šä¸ªç¯å¢ƒé…ç½®,å¹¶åˆ‡æ¢é…ç½®
4. å¼€å§‹è§£æ

â€‹	`preProcessXml(root)`æ–¹æ³•å’Œ`postProcessXm(root)`é»˜è®¤éƒ½æ˜¯ç©ºå®ç°,è¿™é‡Œæ˜¯åº”ç”¨çš„è®¾è®¡æ¨¡å¼ä¸º æ¨¡æ¿æ¨¡å¼,å¢å¼ºæ‰©å±•æ–°,å­ç±»éœ€è¦æ‰©å±•åªéœ€è¦å»å®ç°è¿™ä¸¤ä¸ªæ–¹æ³•å³å¯.



## 2.4 parseBeanDefinitions

```java
protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
		// å¦‚æœæ ¹èŠ‚ç‚¹ä½¿ç”¨é»˜è®¤å‘½åç©ºé—´ï¼Œæ‰§è¡Œé»˜è®¤è§£æ
		if (delegate.isDefaultNamespace(root)) {
			// è·å–èŠ‚ç‚¹ä¸‹é¢çš„å­èŠ‚ç‚¹
			NodeList nl = root.getChildNodes();
			// éå†å­èŠ‚ç‚¹
			for (int i = 0; i &lt; nl.getLength(); i++) {
				Node node = nl.item(i);
				if (node instanceof Element) {
					Element ele = (Element) node;
					if (delegate.isDefaultNamespace(ele)) {
						// è§£æé»˜è®¤åç§°ç©ºé—´å…ƒç´ 
						parseDefaultElement(ele, delegate);
					}
					else {
						// è§£æè‡ªå®šä¹‰åç§°å‘½åç©ºé—´
						delegate.parseCustomElement(ele);
					}
				}
			}
		}
		else {
			// è§£æè‡ªå®šä¹‰åç§°å‘½åç©ºé—´
			delegate.parseCustomElement(root);
		}
	}
```

â€‹	è¿™é‡Œä»åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦æ˜¯é»˜è®¤çš„åç§°å‘½åç©ºé—´,ä»è€Œå¼•å‘äº†2ç§ä¸åŒçš„é€»è¾‘åˆ†æ”¯.ä¸€ä¸ªæ˜¯æ‰§è¡Œspringçš„å†…ç½®çš„è§£æé€»è¾‘,å¦ä¸€ä¸ªæ˜¯æ‰§è¡Œè‡ªå®šä¹‰çš„è§£æé€»è¾‘.

â€‹	springåˆ¤æ–­æ˜¯å¦æ˜¯é»˜è®¤çš„åç§°ç©ºé—´ä¾æ®æ˜¯:å¦‚æœ`namespaceUri`ä¸ºç©ºå¹¶ä¸”ä¸ç­‰äº`http://www.springframework.org/schema/beans`,åˆ™åˆ¤æ–­ä¸ºéé»˜è®¤åç§°ç©ºé—´.



# ä¸‰ã€é»˜è®¤è§£æ

```java
// DefaultBeanDefinitionDocumentReader
private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
		// é»˜è®¤åç§°ç©ºé—´è§£æ,ç”±æ­¤å¯è§springé»˜è®¤åç§°å‘½åç©ºé—´åªæœ‰4ä¸ª
		// import alias bean beans
		// import æ ‡ç­¾å¤„ç†.ç”¨äºåŠ è½½å¼•ç”¨è¿›æ¥çš„xml
		if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
			importBeanDefinitionResource(ele);
		}
		// alias æ ‡ç­¾å¤„ç†
		else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
			processAliasRegistration(ele);
		}
		// bean æ ‡ç­¾å¤„ç†
		else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
			processBeanDefinition(ele, delegate);
		}
		// beans æ ‡ç­¾å¤„ç†
		else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
			// recurse é€’å½’è§£æ
			doRegisterBeanDefinitions(ele);
		}
	}
```



## 3.1 importæ ‡ç­¾

```java
// DefaultBeanDefinitionDocumentReader
protected void importBeanDefinitionResource(Element ele) {
		// è·å–resourceå±æ€§,ç”¨äºåŠ è½½æ–‡ä»¶
		String location = ele.getAttribute(RESOURCE_ATTRIBUTE);
		// å¦‚æœä¸ºç©ºåˆ™é€€å‡º
		if (!StringUtils.hasText(location)) {
			getReaderContext().error(&quot;Resource location must not be empty&quot;, ele);
			return;
		}
		// è§£æå½“å‰ç¯å¢ƒä¸­çš„æ–‡ä»¶è·¯å¾„
		// Resolve system properties: e.g. &quot;${user.dir}&quot;
		location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);

		Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;&gt;(4);

		// Discover whether the location is an absolute or relative URI
		boolean absoluteLocation = false;
		try {
			absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();
		}
		catch (URISyntaxException ex) {
			// cannot convert to an URI, considering the location relative
			// unless it is the well-known Spring prefix &quot;classpath*:&quot;
		}

		// åˆ¤æ–­æ˜¯ç»å¯¹è·¯å¾„è¿˜æ˜¯ç›¸å¯¹è·¯å¾„
		// Absolute or relative?
		if (absoluteLocation) {
			// ç»å¯¹è·¯å¾„
			try {
				// åŠ è½½resourceå±æ€§ä¸­çš„xmlæ–‡ä»¶,åŠ è½½beanå®šä¹‰
				int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from URL location [&quot; + location + &quot;]&quot;);
				}
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(
						&quot;Failed to import bean definitions from URL location [&quot; + location + &quot;]&quot;, ele, ex);
			}
		}
		else {
			// ç›¸å¯¹è·¯å¾„
			// No URL -&gt; considering resource location as relative to the current file.
			try {
				int importCount;
				Resource relativeResource = getReaderContext().getResource().createRelative(location);
				// åˆ¤æ–­èµ„æºæ–‡ä»¶æ˜¯å¦å­˜åœ¨
				if (relativeResource.exists()) {
					// åŠ è½½æ–‡ä»¶
					importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);
					actualResources.add(relativeResource);
				}
				else {
					// è½¬æ¢ä¸ºç»å¯¹è·¯å¾„
					String baseLocation = getReaderContext().getResource().getURL().toString();
					// åŠ è½½æ–‡ä»¶
					importCount = getReaderContext().getReader().loadBeanDefinitions(
							// è®¡ç®—ç»å¯¹è·¯å¾„
							StringUtils.applyRelativePath(baseLocation, location), actualResources);
				}
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from relative location [&quot; + location + &quot;]&quot;);
				}
			}
			catch (IOException ex) {
				getReaderContext().error(&quot;Failed to resolve current resource location&quot;, ele, ex);
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(
						&quot;Failed to import bean definitions from relative location [&quot; + location + &quot;]&quot;, ele, ex);
			}
		}
		// è½¬æ¢ä¸ºæ•°ç»„
		Resource[] actResArray = actualResources.toArray(new Resource[0]);
		// é‡Šæ”¾èµ„æº
		getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));
	}

```

1. åˆ¤æ–­è·¯å¾„æ˜¯å¦ä¸ºç©º
2. å¦‚æœä¸ºç›¸å¯¹è·¯å¾„,åŠ è½½xmlæ–‡ä»¶
3. å¦‚æœä¸ºç»å¯¹è·¯å¾„,åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨,å­˜åœ¨åˆ™åŠ è½½æ–‡ä»¶
4. å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨,è½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„,åŠ è½½æ–‡ä»¶

## 3.2 aliasæ ‡ç­¾

```java
// DefaultBeanDefinitionDocumentReader	
protected void processAliasRegistration(Element ele) {
    // è·å–nameå±æ€§å€¼
		String name = ele.getAttribute(NAME_ATTRIBUTE);
    // è·å–aliaså±æ€§å€¼
		String alias = ele.getAttribute(ALIAS_ATTRIBUTE);
		boolean valid = true;
		// éªŒè¯åç§°æ˜¯å¦åˆæ³•
		if (!StringUtils.hasText(name)) {
			getReaderContext().error(&quot;Name must not be empty&quot;, ele);
			valid = false;
		}
		// éªŒè¯åˆ«åæ˜¯å¦åˆæ³•
		if (!StringUtils.hasText(alias)) {
			getReaderContext().error(&quot;Alias must not be empty&quot;, ele);
			valid = false;
		}
		// éªŒè¯é€šè¿‡æ˜ å°„åˆ«å
		if (valid) {
			try {
        // æ³¨å†Œåˆ«å
				getReaderContext().getRegistry().registerAlias(name, alias);
			}
			catch (Exception ex) {
				getReaderContext().error(&quot;Failed to register alias '&quot; + alias +
						&quot;' for bean with name '&quot; + name + &quot;'&quot;, ele, ex);
			}
			// å‘é€äº‹ä»¶
			getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));
		}
	}
```

1. è·å–nameå±æ€§å€¼
2. è·å–aliaså±æ€§å€¼
3. éªŒè¯aliasæ˜¯å¦åˆæ³•
4. å¦‚æœåˆæ³•åˆ™è¿›è¡Œæ³¨å†Œ

```java
// DefaultBeanDefinitionDocumentReader
	@Override
	public void registerAlias(String name, String alias) {
		Assert.hasText(name, &quot;'name' must not be empty&quot;);
		Assert.hasText(alias, &quot;'alias' must not be empty&quot;);
		// åŠ é” å¹¶å‘æ§åˆ¶
		synchronized (this.aliasMap) {
			// åˆ¤æ–­ bean åç§°æ˜¯å¦ä¸åˆ«åç›¸åŒ,å¦‚æœç›¸åŒåˆ™å¿½ç•¥
			if (alias.equals(name)) {
				// ç§»é™¤åˆ«å
				this.aliasMap.remove(alias);
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Alias definition '&quot; + alias + &quot;' ignored since it points to same name&quot;);
				}
			}
			else {
				// åˆ¤æ–­åˆ«åæ˜¯å¦å·²å­˜åœ¨
				String registeredName = this.aliasMap.get(alias);
				if (registeredName != null) {
					// å¦‚æœåˆ«åå¯¹åº”çš„beançš„åç§°ä¸nameç›¸åŒåˆ™å¿½ç•¥
					if (registeredName.equals(name)) {
						// An existing alias - no need to re-register
						return;
					}
					// æ˜¯å¦å…è®¸è¦†ç›–,å¦‚æœä¸å…è®¸åˆ™æŠ¥é”™
					if (!allowAliasOverriding()) {
						throw new IllegalStateException(&quot;Cannot define alias '&quot; + alias + &quot;' for name '&quot; +
								name + &quot;': It is already registered for name '&quot; + registeredName + &quot;'.&quot;);
					}
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Overriding alias '&quot; + alias + &quot;' definition for registered name '&quot; +
								registeredName + &quot;' with new target name '&quot; + name + &quot;'&quot;);
					}
				}
				//æ£€æŸ¥æ˜¯å¦æœ‰å¾ªç¯å¼•ç”¨åˆ«å ä¾‹å¦‚:A-B C-B A-C
				checkForAliasCircle(name, alias);
				//æ˜ å°„åˆ«åå’Œåç§°åˆ°mapä¸­
				this.aliasMap.put(alias, name);
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Alias definition '&quot; + alias + &quot;' registered for name '&quot; + name + &quot;'&quot;);
				}
			}
		}
	}
```

â€‹	è¿™é‡Œçš„é€»è¾‘æ¯”è¾ƒç®€å•,å¾ªç¯å¼•ç”¨è¿™é‡Œæœ‰ç‚¹æ„æ€.

```java
// DefaultBeanDefinitionDocumentReader
protected void checkForAliasCircle(String name, String alias) {
  	// æ³¨æ„è¿™é‡ŒæŠŠ alias å’Œ name è°ƒæ¢äº†ä¸€ä¸‹ä½ç½®
		if (hasAlias(alias, name)) {
			throw new IllegalStateException(&quot;Cannot register alias '&quot; + alias +
					&quot;' for name '&quot; + name + &quot;': Circular reference - '&quot; +
					name + &quot;' is a direct or indirect alias for '&quot; + alias + &quot;' already&quot;);
		}
	}
/**
* ç”±äºè°ƒæ¢è¿‡å‚æ•°é¡ºåº,æ‰€ä»¥ç†è§£çš„æ—¶å€™éœ€è¦è°ƒæ¢å›æ¥
*/
public boolean hasAlias(String name, String alias) {
		for (Map.Entry&lt;String, String&gt; entry : this.aliasMap.entrySet()) {
			String registeredName = entry.getValue();
			if (registeredName.equals(name)) {
				String registeredAlias = entry.getKey();
				if (registeredAlias.equals(alias) || hasAlias(registeredAlias, alias)) {
					return true;
				}
			}
		}
		return false;
	}

```

â€‹	å…‰çœ‹ä»£ç ä¼°è®¡ä¼šæ¯”è¾ƒè’™,æ¥ä¸¾ä¾‹çœ‹çœ‹.

â€‹	å‡†å¤‡ä¸‰å¯¹ åˆ«å-&gt;åç§°:

| alias | name |
| ----- | ---- |
| A     | B    |
| B     | C    |
| C     | A    |

1. æ£€æŸ¥ A-&gt;B æ˜¯å¦å­˜åœ¨å¾ªç¯å¼•ç”¨
   - ç”±äºé›†åˆæ˜¯ç©ºçš„,æ‰€ä»¥ä¸å­˜åœ¨å¾ªç¯å¼•ç”¨.
2. æ£€æŸ¥B-&gt;Cæ˜¯å¦å­˜åœ¨å¾ªç¯å¼•ç”¨
   - éå†é›†åˆè·å–value: B
   - B==B(æ³¨æ„è¿™é‡Œçš„nameå…¶å®æ˜¯alias)
   - è·å–é›†åˆä¸­çš„key: A 
   - A != C æŠŠ A-&gt;Cå½“ä½œå‚æ•°è¿›è¡Œé€’å½’
   - é€’å½’æ£€æŸ¥ä¸å­˜åœ¨å¾ªç¯å¼•ç”¨
3. æ£€æŸ¥C-Aæ˜¯å¦å­˜åœ¨å¾ªç¯å¼•ç”¨
   - éå†é›†åˆè·å–value: B
   - B != C
   - éå†é›†åˆè·å–value: C
   - C == C
   - è·å–é›†åˆä¸­çš„key: B
   - B != A,æŠŠB-&gt;Aä½œä¸ºå‚æ•°é€’å½’
   - éå†é›†åˆè·å–value: B
   - B==B
   - è·å–é›†åˆä¸­çš„key: A
   - A == A åœæ­¢é€’å½’,è¿”å›true
   - å­˜åœ¨å¾ªç¯å¼•ç”¨

ä¹‹æ‰€ä»¥è¿™ä¸ªé€»è¾‘æœ‰ç‚¹ç»•å› ä¸ºè¿™ä¸ªå‚æ•°è°ƒæ¢äº†ä¸€ä¸‹ä½ç½®,å»ºè®®ç”¨ç¬”ç”»ä¸€ä¸‹å°±è±è¾¾äº†.LOL :).



## 3.3 beanæ ‡ç­¾

```java
// DefaultBeanDefinitionDocumentReader
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
		// è§£æxmlå…ƒç´ 
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
		if (bdHolder != null) {
			// è£…é¥°bean
			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
			try {
				// Register the final decorated instance.
				// æ³¨å†Œbeanåˆ°å®¹å™¨ä¸­
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
						bdHolder.getBeanName() + &quot;'&quot;, ele, ex);
			}
			// Send registration event.
			// å‘é€äº‹ä»¶
			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
		}
	}
```

1. è§£æxmlåˆ›å»º`BeanDefinitionHolder`
2. å¦‚æœä¸ä¸ºç©º,è¿›è¡Œè¿›è¡Œè£…é¥°
3. æ³¨å†Œåˆ°å®¹å™¨ä¸­
4. å‘é€äº‹ä»¶

### 3.3.1 parseBeanDefinitionElement()

```java
// BeanDefinitionParserDelegate
 @Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
		return parseBeanDefinitionElement(ele, null);
	}

	/**
	 * Parses the supplied {@code &lt;bean&gt;} element. May return {@code null}
	 * if there were errors during parse. Errors are reported to the
	 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
	 */
	@Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
		// è·å–id
		String id = ele.getAttribute(ID_ATTRIBUTE);
		// è·å–åç§°
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
		// è·å–åˆ«å,åˆ«åå¯ä»¥ä½¿ç”¨å¤šä¸ª
		List&lt;String&gt; aliases = new ArrayList&lt;&gt;();
		// åç§°ä¸ä¸ºç©º
		if (StringUtils.hasLength(nameAttr)) {
			// å¦‚æœæœ‰å¤šä¸ªåç§°,ä½¿ç”¨,;åˆ‡å‰²
			String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
			aliases.addAll(Arrays.asList(nameArr));
		}
		// beanåç§°å°±æ˜¯id
		String beanName = id;
		// å¦‚æœåç§°ä¸ºç©º,å¹¶ä¸”åˆ«åé›†åˆä¸ä¸ºç©º,åˆ™ä»åˆ«åä¸­è·å–ç¬¬ä¸€ä¸ª,ä½œä¸ºåç§°
		if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {
			beanName = aliases.remove(0);
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName +
						&quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;);
			}
		}

		if (containingBean == null) {
			// æ£€æŸ¥beanNameæ˜¯å¦å”¯ä¸€(åç§°æœªè¢«ä½¿ç”¨è¿‡)
			checkNameUniqueness(beanName, aliases, ele);
		}
		// è§£ææ ‡ç­¾å°è£…ä¸ºbeanDefinition
		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
		// beanDefinitionå¯¹è±¡ä¸ä¸ºç©º
		if (beanDefinition != null) {
			// beanNameä¸ºç©º
			if (!StringUtils.hasText(beanName)) {
				try {
					if (containingBean != null) {
						// ç”Ÿæˆbeançš„ name
						beanName = BeanDefinitionReaderUtils.generateBeanName(
								beanDefinition, this.readerContext.getRegistry(), true);
					}
					else {
            // ç”Ÿæˆbeançš„ name
						beanName = this.readerContext.generateBeanName(beanDefinition);
						// Register an alias for the plain bean class name, if still possible,
						// if the generator returned the class name plus a suffix.
						// This is expected for Spring 1.2/2.0 backwards compatibility.
            // è·å– className
						String beanClassName = beanDefinition.getBeanClassName();
            // åˆ¤æ–­beanåç§°ä¸ä¸ºç©º å¹¶ä¸” ä»¥ç±»åå¼€å¤´ å¹¶ä¸”åç§°æ²¡æœ‰è¢«ä½¿ç”¨
						if (beanClassName != null &amp;&amp;
								beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;
								!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
							aliases.add(beanClassName);
						}
					}
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; +
								&quot;using generated bean name [&quot; + beanName + &quot;]&quot;);
					}
				}
				catch (Exception ex) {
					error(ex.getMessage(), ele);
					return null;
				}
			}
			// åˆ«åé›†åˆè½¬ä¸ºæ•°ç»„
			String[] aliasesArray = StringUtils.toStringArray(aliases);
			// è¿”å›BeanDefinitionHolder
			return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
		}

		return null;
	}
```

â€‹	ä»¥ä¸Šä»£ç é€»è¾‘ä¸æ˜¯å¾ˆå¤æ‚,æ ¸å¿ƒé€»è¾‘åœ¨äºé€šè¿‡`AbstractBeanDefinition`è½¬æ¢ä¸º`BeanDefinitionHolder`,æ ¸å¿ƒä»£ç `AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);`



# å››ã€å°ç»“

â€‹	ç”±äºåé¢çš„é€»è¾‘æ¯”è¾ƒå¤æ‚,æ‰“ç®—åˆ†ä¸¤ç« æ¥å†™,å¤©è‰²å·²æ™š,å‡†å¤‡åƒé¥­.</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">ä¸€ã€å‰è¨€ â€‹ æ¥ä¸Šæ–‡,åˆ†æäº†spring æŠŠ xml æ–‡ä»¶è¯»å–åˆ°å†…å­˜ä¸­,å¹¶ç”Ÿæˆä¸€ä¸ªdocumentå¯¹è±¡,ç„¶è€Œç¦»åˆ›å»ºbeanè¿˜æ¯”è¾ƒé¥è¿œ.åœ¨xmlä¸­å®šäº†beanè¯¥å¦‚ä½•åˆ›å»ºçš„è§„åˆ™,è€Œspringä¹Ÿæ˜¯éµå¾ªxmlä¸­çš„æ ‡ç­¾æ‰€æè¿°è§„åˆ™æ¥è¿›è¡Œåˆ›å»ºbean.æ¥ä¸‹æ¥å°±æ˜¯è¦åˆ†æ,springæ˜¯å¦‚ä½•è§£æè¿™äº›æ ‡ç­¾çš„. äºŒã€åˆ†æ â€‹ è¿˜æ˜¯å¸¸è§„å¥—è·¯,ä»ä¸‹é¢çš„æµ‹è¯•ä»£ç å¼€å§‹. @Test public void testSpringLoadXml(){ BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBean.xml&quot;)); final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class); final String testStr = testBean.getTestStr(); System.out.println(testStr); } â€‹ xmlå†…å®¹å¦‚ä¸‹: &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&amp;gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&amp;gt; &amp;lt;bean id=&quot;myTestBean&quot; class=&quot;com.sjr.test.bean.MyTestBean&quot;/&amp;gt; &amp;lt;/beans&amp;gt; â€‹ ç»“åˆxml,å°±å¯ä»¥è®©springåˆ›å»ºä¸€ä¸ªMyTestBeanå¯¹è±¡å‡ºæ¥.é‚£ä¹ˆspringæ˜¯æ€ä¹ˆåŠåˆ°çš„å‘¢? // XmlBeanDefinitionReader protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { // åŠ è½½xml // åŠ è½½xmlçš„æ—¶å€™è¿™é‡Œå·²ç»è®²è¿‡äº† Document doc = doLoadDocument(inputSource, resource); // æ³¨å†Œbean int count = registerBeanDefinitions(doc, resource); if (logger.isDebugEnabled()) { logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource); } return count; } catch (BeanDefinitionStoreException ex) { throw ex; } catch (SAXParseException ex) { throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex); } catch (SAXException ex) { throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex); } catch (ParserConfigurationException ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Parser configuration exception parsing XML from &quot; + resource, ex); } catch (IOException ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;IOException parsing XML document from &quot; + resource, ex); } catch (Throwable ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Unexpected exception parsing XML document from &quot; + resource, ex); } } â€‹ çœ‹æ¥ç­”æ¡ˆå‡ºç°åœ¨int count = registerBeanDefinitions(doc, resource);è¿™å¥ä»£ç é‡Œé¢ 2.1 registerBeanDefinitions() //xmlBeanDefinitionReader /*** * @param doc é€šè¿‡xml åˆ›å»ºçš„documentå¯¹è±¡ * @param resource xml èµ„æºå¯¹è±¡ * @return æ³¨å†Œçš„æ•°é‡ */ public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { // åˆ›å»ºBeanDefinitionDocumentReader é»˜è®¤æ˜¯DefaultBeanDefinitionDocumentReader BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); // è·å–å·²ç»æ³¨å†Œçš„beançš„æ•°é‡,beanDefinitionMap.size() int countBefore = getRegistry().getBeanDefinitionCount(); // æ³¨å†Œxml beanå®šä¹‰ documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); // è¿”å›å·²ç»æ³¨å†Œçš„æ•°é‡ return getRegistry().getBeanDefinitionCount() - countBefore; } â€‹ è§£æxmlæ ‡ç­¾çš„æ ¸å¿ƒé€»è¾‘åœ¨äºdocumentReader.registerBeanDefinitions(doc, createReaderContext(resource));,é€æ­¥åˆ†æä¸€ä¸‹. 2.2 createReaderContext(resource) //xmlBeanDefinitionReader public XmlReaderContext createReaderContext(Resource resource) { return new XmlReaderContext(resource, this.problemReporter, this.eventListener, this.sourceExtractor, this, getNamespaceHandlerResolver()); } â€‹ è¿™ä¸ªå¯¹è±¡ç›¸å½“äºæ˜¯ä¸ªå·¥å…·ç±»,é‡Œé¢æœªå°è£…é€»è¾‘ä»£ç .å°è£…äº†ä¸€äº›æ—¥å¿—ç›¸å…³çš„å‡½æ•°,è·å–resourceçš„å‡½æ•°ç­‰.è¿™é‡Œå€¼å¾—æ³¨æ„æ˜¯getNamespaceHandlerResolver()è¿™ä¸ªæ–¹æ³•,è¿™ä¸ªæ–¹æ³•è¿”å›äº†ä¸€ä¸ªNamespaceHandlerResolverå¯¹è±¡,è¿™ä¸ªå¯¹è±¡æ˜¯ç”¨äºè§£ææŒ‡å®šåç§°ç©ºé—´çš„è§£æå™¨,å¦‚æœè¦è‡ªå®šä¹‰æ ‡ç­¾å°±å¾—è¦è¿™ä¸ªå¯¹è±¡æ¥å¸®å¿™. //xmlBeanDefinitionReader public NamespaceHandlerResolver getNamespaceHandlerResolver() { // å¦‚æœåç§°ç©ºé—´è§£æå™¨ä¸ºç©º,åˆ™åˆ›å»ºä¸€ä¸ªé»˜è®¤çš„åç§°ç©ºé—´è§£æå™¨ if (this.namespaceHandlerResolver == null) { this.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver(); } return this.namespaceHandlerResolver; } /** * Create the default implementation of {@link NamespaceHandlerResolver} used if none is specified. * &amp;lt;p&amp;gt;The default implementation returns an instance of {@link DefaultNamespaceHandlerResolver}. * @see DefaultNamespaceHandlerResolver#DefaultNamespaceHandlerResolver(ClassLoader) */ protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() { // è·å–classLoader ClassLoader cl = (getResourceLoader() != null ? getResourceLoader().getClassLoader() : getBeanClassLoader()); // åˆ›å»ºé»˜è®¤çš„åç§°ç©ºé—´è§£æå™¨ return new DefaultNamespaceHandlerResolver(cl); } 2.3 registerBeanDefinitions() // DefaultBeanDefinitionDocumentReader // bean public static final String BEAN_ELEMENT = BeanDefinitionParserDelegate.BEAN_ELEMENT; public static final String NESTED_BEANS_ELEMENT = &quot;beans&quot;; public static final String ALIAS_ELEMENT = &quot;alias&quot;; public static final String NAME_ATTRIBUTE = &quot;name&quot;; public static final String ALIAS_ATTRIBUTE = &quot;alias&quot;; public static final String IMPORT_ELEMENT = &quot;import&quot;; public static final String RESOURCE_ATTRIBUTE = &quot;resource&quot;; public static final String PROFILE_ATTRIBUTE = &quot;profile&quot;; @Override public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) { this.readerContext = readerContext; doRegisterBeanDefinitions(doc.getDocumentElement()); } protected void doRegisterBeanDefinitions(Element root) { // Any nested &amp;lt;beans&amp;gt; elements will cause recursion in this method. In // order to propagate and preserve &amp;lt;beans&amp;gt; default-* attributes correctly, // keep track of the current (parent) delegate, which may be null. Create // the new (child) delegate with a reference to the parent for fallback purposes, // then ultimately reset this.delegate back to its original (parent) reference. // this behavior emulates a stack of delegates without actually necessitating one. // rootèŠ‚ç‚¹è¿›æ¥é»˜è®¤å§”æ‰˜ä¸ºnull BeanDefinitionParserDelegate parent = this.delegate; // åˆ›å»ºå§”æ‰˜,ç”¨äºè§£æå„ä¸ªæ ‡ç­¾ // BeanDefinitionParserDelegate this.delegate = createDelegate(getReaderContext(), root, parent); // å¤„ç†profileå±æ€§,ç”¨äºåˆ‡æ¢ä¸åŒç¯å¢ƒçš„é…ç½®æ–‡ä»¶ if (this.delegate.isDefaultNamespace(root)) { // åˆ¤æ–­æ˜¯å¦å«æœ‰profileå±æ€§ String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); // å¦‚æœprofileå±æ€§ä¸ä¸ºç©º if (StringUtils.hasText(profileSpec)) { // å¯èƒ½ä¼šæœ‰å¤šä¸ªprofileå±æ€§,ä½¿ç”¨,;è¿›è¡Œåˆ†å‰² String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); // We cannot use Profiles.of(...) since profile expressions are not supported // in XML config. See SPR-12458 for details. // å¦‚æœä¸æ˜¯æœ‰æ•ˆçš„profile åˆ™è¿”å› if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isDebugEnabled()) { logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + getReaderContext().getResource()); } return; } } } // å‰ç½®è§£æå™¨(ç©ºé€»è¾‘,ç•™ç»™å­ç±»å»å®Œå–„) preProcessXml(root); // æ ¸å¿ƒé€»è¾‘ parseBeanDefinitions(root, this.delegate); // åç½®è§£æå™¨(ç©ºé€»è¾‘,ç•™ç»™å­ç±»å»å®Œå–„) postProcessXml(root); this.delegate = parent; } æ ¹èŠ‚ç‚¹é»˜è®¤æ²¡æœ‰çˆ¶èŠ‚ç‚¹ä¸ºNULL åˆ›å»ºå§”æ‰˜ç”¨äºè§£æxmlæ ‡ç­¾ åˆ¤æ–­æ˜¯å¦æœ‰å¤šä¸ªç¯å¢ƒé…ç½®,å¹¶åˆ‡æ¢é…ç½® å¼€å§‹è§£æ â€‹ preProcessXml(root)æ–¹æ³•å’ŒpostProcessXm(root)é»˜è®¤éƒ½æ˜¯ç©ºå®ç°,è¿™é‡Œæ˜¯åº”ç”¨çš„è®¾è®¡æ¨¡å¼ä¸º æ¨¡æ¿æ¨¡å¼,å¢å¼ºæ‰©å±•æ–°,å­ç±»éœ€è¦æ‰©å±•åªéœ€è¦å»å®ç°è¿™ä¸¤ä¸ªæ–¹æ³•å³å¯. 2.4 parseBeanDefinitions protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { // å¦‚æœæ ¹èŠ‚ç‚¹ä½¿ç”¨é»˜è®¤å‘½åç©ºé—´ï¼Œæ‰§è¡Œé»˜è®¤è§£æ if (delegate.isDefaultNamespace(root)) { // è·å–èŠ‚ç‚¹ä¸‹é¢çš„å­èŠ‚ç‚¹ NodeList nl = root.getChildNodes(); // éå†å­èŠ‚ç‚¹ for (int i = 0; i &amp;lt; nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) { // è§£æé»˜è®¤åç§°ç©ºé—´å…ƒç´  parseDefaultElement(ele, delegate); } else { // è§£æè‡ªå®šä¹‰åç§°å‘½åç©ºé—´ delegate.parseCustomElement(ele); } } } } else { // è§£æè‡ªå®šä¹‰åç§°å‘½åç©ºé—´ delegate.parseCustomElement(root); } } â€‹ è¿™é‡Œä»åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦æ˜¯é»˜è®¤çš„åç§°å‘½åç©ºé—´,ä»è€Œå¼•å‘äº†2ç§ä¸åŒçš„é€»è¾‘åˆ†æ”¯.ä¸€ä¸ªæ˜¯æ‰§è¡Œspringçš„å†…ç½®çš„è§£æé€»è¾‘,å¦ä¸€ä¸ªæ˜¯æ‰§è¡Œè‡ªå®šä¹‰çš„è§£æé€»è¾‘. â€‹ springåˆ¤æ–­æ˜¯å¦æ˜¯é»˜è®¤çš„åç§°ç©ºé—´ä¾æ®æ˜¯:å¦‚æœnamespaceUriä¸ºç©ºå¹¶ä¸”ä¸ç­‰äºhttp://www.springframework.org/schema/beans,åˆ™åˆ¤æ–­ä¸ºéé»˜è®¤åç§°ç©ºé—´. ä¸‰ã€é»˜è®¤è§£æ // DefaultBeanDefinitionDocumentReader private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { // é»˜è®¤åç§°ç©ºé—´è§£æ,ç”±æ­¤å¯è§springé»˜è®¤åç§°å‘½åç©ºé—´åªæœ‰4ä¸ª // import alias bean beans // import æ ‡ç­¾å¤„ç†.ç”¨äºåŠ è½½å¼•ç”¨è¿›æ¥çš„xml if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { importBeanDefinitionResource(ele); } // alias æ ‡ç­¾å¤„ç† else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { processAliasRegistration(ele); } // bean æ ‡ç­¾å¤„ç† else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { processBeanDefinition(ele, delegate); } // beans æ ‡ç­¾å¤„ç† else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // recurse é€’å½’è§£æ doRegisterBeanDefinitions(ele); } } 3.1 importæ ‡ç­¾ // DefaultBeanDefinitionDocumentReader protected void importBeanDefinitionResource(Element ele) { // è·å–resourceå±æ€§,ç”¨äºåŠ è½½æ–‡ä»¶ String location = ele.getAttribute(RESOURCE_ATTRIBUTE); // å¦‚æœä¸ºç©ºåˆ™é€€å‡º if (!StringUtils.hasText(location)) { getReaderContext().error(&quot;Resource location must not be empty&quot;, ele); return; } // è§£æå½“å‰ç¯å¢ƒä¸­çš„æ–‡ä»¶è·¯å¾„ // Resolve system properties: e.g. &quot;${user.dir}&quot; location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location); Set&amp;lt;Resource&amp;gt; actualResources = new LinkedHashSet&amp;lt;&amp;gt;(4); // Discover whether the location is an absolute or relative URI boolean absoluteLocation = false; try { absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute(); } catch (URISyntaxException ex) { // cannot convert to an URI, considering the location relative // unless it is the well-known Spring prefix &quot;classpath*:&quot; } // åˆ¤æ–­æ˜¯ç»å¯¹è·¯å¾„è¿˜æ˜¯ç›¸å¯¹è·¯å¾„ // Absolute or relative? if (absoluteLocation) { // ç»å¯¹è·¯å¾„ try { // åŠ è½½resourceå±æ€§ä¸­çš„xmlæ–‡ä»¶,åŠ è½½beanå®šä¹‰ int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources); if (logger.isTraceEnabled()) { logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from URL location [&quot; + location + &quot;]&quot;); } } catch (BeanDefinitionStoreException ex) { getReaderContext().error( &quot;Failed to import bean definitions from URL location [&quot; + location + &quot;]&quot;, ele, ex); } } else { // ç›¸å¯¹è·¯å¾„ // No URL -&amp;gt; considering resource location as relative to the current file. try { int importCount; Resource relativeResource = getReaderContext().getResource().createRelative(location); // åˆ¤æ–­èµ„æºæ–‡ä»¶æ˜¯å¦å­˜åœ¨ if (relativeResource.exists()) { // åŠ è½½æ–‡ä»¶ importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource); actualResources.add(relativeResource); } else { // è½¬æ¢ä¸ºç»å¯¹è·¯å¾„ String baseLocation = getReaderContext().getResource().getURL().toString(); // åŠ è½½æ–‡ä»¶ importCount = getReaderContext().getReader().loadBeanDefinitions( // è®¡ç®—ç»å¯¹è·¯å¾„ StringUtils.applyRelativePath(baseLocation, location), actualResources); } if (logger.isTraceEnabled()) { logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from relative location [&quot; + location + &quot;]&quot;); } } catch (IOException ex) { getReaderContext().error(&quot;Failed to resolve current resource location&quot;, ele, ex); } catch (BeanDefinitionStoreException ex) { getReaderContext().error( &quot;Failed to import bean definitions from relative location [&quot; + location + &quot;]&quot;, ele, ex); } } // è½¬æ¢ä¸ºæ•°ç»„ Resource[] actResArray = actualResources.toArray(new Resource[0]); // é‡Šæ”¾èµ„æº getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele)); } åˆ¤æ–­è·¯å¾„æ˜¯å¦ä¸ºç©º å¦‚æœä¸ºç›¸å¯¹è·¯å¾„,åŠ è½½xmlæ–‡ä»¶ å¦‚æœä¸ºç»å¯¹è·¯å¾„,åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨,å­˜åœ¨åˆ™åŠ è½½æ–‡ä»¶ å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨,è½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„,åŠ è½½æ–‡ä»¶ 3.2 aliasæ ‡ç­¾ // DefaultBeanDefinitionDocumentReader protected void processAliasRegistration(Element ele) { // è·å–nameå±æ€§å€¼ String name = ele.getAttribute(NAME_ATTRIBUTE); // è·å–aliaså±æ€§å€¼ String alias = ele.getAttribute(ALIAS_ATTRIBUTE); boolean valid = true; // éªŒè¯åç§°æ˜¯å¦åˆæ³• if (!StringUtils.hasText(name)) { getReaderContext().error(&quot;Name must not be empty&quot;, ele); valid = false; } // éªŒè¯åˆ«åæ˜¯å¦åˆæ³• if (!StringUtils.hasText(alias)) { getReaderContext().error(&quot;Alias must not be empty&quot;, ele); valid = false; } // éªŒè¯é€šè¿‡æ˜ å°„åˆ«å if (valid) { try { // æ³¨å†Œåˆ«å getReaderContext().getRegistry().registerAlias(name, alias); } catch (Exception ex) { getReaderContext().error(&quot;Failed to register alias '&quot; + alias + &quot;' for bean with name '&quot; + name + &quot;'&quot;, ele, ex); } // å‘é€äº‹ä»¶ getReaderContext().fireAliasRegistered(name, alias, extractSource(ele)); } } è·å–nameå±æ€§å€¼ è·å–aliaså±æ€§å€¼ éªŒè¯aliasæ˜¯å¦åˆæ³• å¦‚æœåˆæ³•åˆ™è¿›è¡Œæ³¨å†Œ // DefaultBeanDefinitionDocumentReader @Override public void registerAlias(String name, String alias) { Assert.hasText(name, &quot;'name' must not be empty&quot;); Assert.hasText(alias, &quot;'alias' must not be empty&quot;); // åŠ é” å¹¶å‘æ§åˆ¶ synchronized (this.aliasMap) { // åˆ¤æ–­ bean åç§°æ˜¯å¦ä¸åˆ«åç›¸åŒ,å¦‚æœç›¸åŒåˆ™å¿½ç•¥ if (alias.equals(name)) { // ç§»é™¤åˆ«å this.aliasMap.remove(alias); if (logger.isDebugEnabled()) { logger.debug(&quot;Alias definition '&quot; + alias + &quot;' ignored since it points to same name&quot;); } } else { // åˆ¤æ–­åˆ«åæ˜¯å¦å·²å­˜åœ¨ String registeredName = this.aliasMap.get(alias); if (registeredName != null) { // å¦‚æœåˆ«åå¯¹åº”çš„beançš„åç§°ä¸nameç›¸åŒåˆ™å¿½ç•¥ if (registeredName.equals(name)) { // An existing alias - no need to re-register return; } // æ˜¯å¦å…è®¸è¦†ç›–,å¦‚æœä¸å…è®¸åˆ™æŠ¥é”™ if (!allowAliasOverriding()) { throw new IllegalStateException(&quot;Cannot define alias '&quot; + alias + &quot;' for name '&quot; + name + &quot;': It is already registered for name '&quot; + registeredName + &quot;'.&quot;); } if (logger.isDebugEnabled()) { logger.debug(&quot;Overriding alias '&quot; + alias + &quot;' definition for registered name '&quot; + registeredName + &quot;' with new target name '&quot; + name + &quot;'&quot;); } } //æ£€æŸ¥æ˜¯å¦æœ‰å¾ªç¯å¼•ç”¨åˆ«å ä¾‹å¦‚:A-B C-B A-C checkForAliasCircle(name, alias); //æ˜ å°„åˆ«åå’Œåç§°åˆ°mapä¸­ this.aliasMap.put(alias, name); if (logger.isTraceEnabled()) { logger.trace(&quot;Alias definition '&quot; + alias + &quot;' registered for name '&quot; + name + &quot;'&quot;); } } } } â€‹ è¿™é‡Œçš„é€»è¾‘æ¯”è¾ƒç®€å•,å¾ªç¯å¼•ç”¨è¿™é‡Œæœ‰ç‚¹æ„æ€. // DefaultBeanDefinitionDocumentReader protected void checkForAliasCircle(String name, String alias) { // æ³¨æ„è¿™é‡ŒæŠŠ alias å’Œ name è°ƒæ¢äº†ä¸€ä¸‹ä½ç½® if (hasAlias(alias, name)) { throw new IllegalStateException(&quot;Cannot register alias '&quot; + alias + &quot;' for name '&quot; + name + &quot;': Circular reference - '&quot; + name + &quot;' is a direct or indirect alias for '&quot; + alias + &quot;' already&quot;); } } /** * ç”±äºè°ƒæ¢è¿‡å‚æ•°é¡ºåº,æ‰€ä»¥ç†è§£çš„æ—¶å€™éœ€è¦è°ƒæ¢å›æ¥ */ public boolean hasAlias(String name, String alias) { for (Map.Entry&amp;lt;String, String&amp;gt; entry : this.aliasMap.entrySet()) { String registeredName = entry.getValue(); if (registeredName.equals(name)) { String registeredAlias = entry.getKey(); if (registeredAlias.equals(alias) || hasAlias(registeredAlias, alias)) { return true; } } } return false; } â€‹ å…‰çœ‹ä»£ç ä¼°è®¡ä¼šæ¯”è¾ƒè’™,æ¥ä¸¾ä¾‹çœ‹çœ‹. â€‹ å‡†å¤‡ä¸‰å¯¹ åˆ«å-&amp;gt;åç§°: alias name A B B C C A æ£€æŸ¥ A-&amp;gt;B æ˜¯å¦å­˜åœ¨å¾ªç¯å¼•ç”¨ ç”±äºé›†åˆæ˜¯ç©ºçš„,æ‰€ä»¥ä¸å­˜åœ¨å¾ªç¯å¼•ç”¨. æ£€æŸ¥B-&amp;gt;Cæ˜¯å¦å­˜åœ¨å¾ªç¯å¼•ç”¨ éå†é›†åˆè·å–value: B B==B(æ³¨æ„è¿™é‡Œçš„nameå…¶å®æ˜¯alias) è·å–é›†åˆä¸­çš„key: A A != C æŠŠ A-&amp;gt;Cå½“ä½œå‚æ•°è¿›è¡Œé€’å½’ é€’å½’æ£€æŸ¥ä¸å­˜åœ¨å¾ªç¯å¼•ç”¨ æ£€æŸ¥C-Aæ˜¯å¦å­˜åœ¨å¾ªç¯å¼•ç”¨ éå†é›†åˆè·å–value: B B != C éå†é›†åˆè·å–value: C C == C è·å–é›†åˆä¸­çš„key: B B != A,æŠŠB-&amp;gt;Aä½œä¸ºå‚æ•°é€’å½’ éå†é›†åˆè·å–value: B B==B è·å–é›†åˆä¸­çš„key: A A == A åœæ­¢é€’å½’,è¿”å›true å­˜åœ¨å¾ªç¯å¼•ç”¨ ä¹‹æ‰€ä»¥è¿™ä¸ªé€»è¾‘æœ‰ç‚¹ç»•å› ä¸ºè¿™ä¸ªå‚æ•°è°ƒæ¢äº†ä¸€ä¸‹ä½ç½®,å»ºè®®ç”¨ç¬”ç”»ä¸€ä¸‹å°±è±è¾¾äº†.LOL :). 3.3 beanæ ‡ç­¾ // DefaultBeanDefinitionDocumentReader protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // è§£æxmlå…ƒç´  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { // è£…é¥°bean bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. // æ³¨å†Œbeanåˆ°å®¹å™¨ä¸­ BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(&quot;Failed to register bean definition with name '&quot; + bdHolder.getBeanName() + &quot;'&quot;, ele, ex); } // Send registration event. // å‘é€äº‹ä»¶ getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } è§£æxmlåˆ›å»ºBeanDefinitionHolder å¦‚æœä¸ä¸ºç©º,è¿›è¡Œè¿›è¡Œè£…é¥° æ³¨å†Œåˆ°å®¹å™¨ä¸­ å‘é€äº‹ä»¶ 3.3.1 parseBeanDefinitionElement() // BeanDefinitionParserDelegate @Nullable public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { return parseBeanDefinitionElement(ele, null); } /** * Parses the supplied {@code &amp;lt;bean&amp;gt;} element. May return {@code null} * if there were errors during parse. Errors are reported to the * {@link org.springframework.beans.factory.parsing.ProblemReporter}. */ @Nullable public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) { // è·å–id String id = ele.getAttribute(ID_ATTRIBUTE); // è·å–åç§° String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); // è·å–åˆ«å,åˆ«åå¯ä»¥ä½¿ç”¨å¤šä¸ª List&amp;lt;String&amp;gt; aliases = new ArrayList&amp;lt;&amp;gt;(); // åç§°ä¸ä¸ºç©º if (StringUtils.hasLength(nameAttr)) { // å¦‚æœæœ‰å¤šä¸ªåç§°,ä½¿ç”¨,;åˆ‡å‰² String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } // beanåç§°å°±æ˜¯id String beanName = id; // å¦‚æœåç§°ä¸ºç©º,å¹¶ä¸”åˆ«åé›†åˆä¸ä¸ºç©º,åˆ™ä»åˆ«åä¸­è·å–ç¬¬ä¸€ä¸ª,ä½œä¸ºåç§° if (!StringUtils.hasText(beanName) &amp;amp;&amp;amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isTraceEnabled()) { logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName + &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;); } } if (containingBean == null) { // æ£€æŸ¥beanNameæ˜¯å¦å”¯ä¸€(åç§°æœªè¢«ä½¿ç”¨è¿‡) checkNameUniqueness(beanName, aliases, ele); } // è§£ææ ‡ç­¾å°è£…ä¸ºbeanDefinition AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); // beanDefinitionå¯¹è±¡ä¸ä¸ºç©º if (beanDefinition != null) { // beanNameä¸ºç©º if (!StringUtils.hasText(beanName)) { try { if (containingBean != null) { // ç”Ÿæˆbeançš„ name beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { // ç”Ÿæˆbeançš„ name beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. // è·å– className String beanClassName = beanDefinition.getBeanClassName(); // åˆ¤æ–­beanåç§°ä¸ä¸ºç©º å¹¶ä¸” ä»¥ç±»åå¼€å¤´ å¹¶ä¸”åç§°æ²¡æœ‰è¢«ä½¿ç”¨ if (beanClassName != null &amp;amp;&amp;amp; beanName.startsWith(beanClassName) &amp;amp;&amp;amp; beanName.length() &amp;gt; beanClassName.length() &amp;amp;&amp;amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { aliases.add(beanClassName); } } if (logger.isTraceEnabled()) { logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } // åˆ«åé›†åˆè½¬ä¸ºæ•°ç»„ String[] aliasesArray = StringUtils.toStringArray(aliases); // è¿”å›BeanDefinitionHolder return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } return null; } â€‹ ä»¥ä¸Šä»£ç é€»è¾‘ä¸æ˜¯å¾ˆå¤æ‚,æ ¸å¿ƒé€»è¾‘åœ¨äºé€šè¿‡AbstractBeanDefinitionè½¬æ¢ä¸ºBeanDefinitionHolder,æ ¸å¿ƒä»£ç AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); å››ã€å°ç»“ â€‹ ç”±äºåé¢çš„é€»è¾‘æ¯”è¾ƒå¤æ‚,æ‰“ç®—åˆ†ä¸¤ç« æ¥å†™,å¤©è‰²å·²æ™š,å‡†å¤‡åƒé¥­.</summary></entry><entry><title type="html">[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-xmlæ–‡ä»¶è§£æ(ä¸‰)</title><link href="https://onew.me/spring/2020/02/05/debug-spring-3.html" rel="alternate" type="text/html" title="[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-xmlæ–‡ä»¶è§£æ(ä¸‰)" /><published>2020-02-05T22:20:25+08:00</published><updated>2020-02-05T22:20:25+08:00</updated><id>https://onew.me/spring/2020/02/05/debug-spring-3</id><content type="html" xml:base="https://onew.me/spring/2020/02/05/debug-spring-3.html"># ä¸€ã€å‰è¨€

â€‹	å‰é¢èµ„æºæ–‡ä»¶åŠ è½½æå®šäº†,æ¥çœ‹çœ‹ spring æ˜¯å¦‚ä½•æŠŠ xml æ–‡ä»¶å˜æˆ bean çš„å§.



# äºŒã€åˆ†æ

â€‹	è¿˜æ˜¯ä»4å¥ä»£ç çœ‹èµ·.

````java
@Test
	public void testSpringLoadXml(){
    // åŠ è½½xml
		BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBean.xml&quot;));
    // è·å–bean
		final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);
		final String testStr = testBean.getTestStr();
		System.out.println(testStr);
	}
````

â€‹	ä»è§£æxml åˆ° è·å–beanéƒ½æ˜¯ä»`XmlBeanFactory`ä¸­æ“ä½œçš„,é‚£ä¹ˆå°±æ¥çœ‹çœ‹`XmlBeanFactory`é‡Œé¢æœ‰å•¥.

```java
public class XmlBeanFactory extends DefaultListableBeanFactory {

	private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);


	/**
	 * æ„é€ å‡½æ•°
	 */
	public XmlBeanFactory(Resource resource) throws BeansException {
		this(resource, null);
	}

	/**
	 * æ„é€ å‡½æ•°
	 * æŒ‡å®š çˆ¶BeanFactory
	 */
	public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
		super(parentBeanFactory);
    // æ ¸å¿ƒä»£ç  A
		this.reader.loadBeanDefinitions(resource);
	}

}

```

â€‹	å¯ä»¥çœ‹åˆ°æ ¸å¿ƒä»£ç åœ¨Aå¤„,Aå¤„ç”¨`XmlBeanDefinitionReader`è¿›è¡Œè¯»å–æ–‡ä»¶,ç»§ç»­è·Ÿä¸‹å».

```java
@Override
	public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
		// æŠŠclassPathsResourceè½¬æ¢ä¸ºEncodedResource,é»˜è®¤å­—ç¬¦ç¼–ç ä¸ºç©º
		return loadBeanDefinitions(new EncodedResource(resource));
	}

	public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
		//åŠ è½½èµ„æº,èµ„æºä¸èƒ½ä¸ºç©º
		Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Loading XML bean definitions from &quot; + encodedResource);
		}
		//åˆ¤æ–­å½“å‰çº¿ç¨‹æ˜¯å¦åŠ è½½è¿‡èµ„æº,å¦‚æœæ²¡æœ‰åˆ™åˆ›å»ºä¸€ä¸ªsetæ¥ä¿å­˜encodedResource
		Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();
		if (currentResources == null) {
			currentResources = new HashSet&lt;&gt;(4);
			this.resourcesCurrentlyBeingLoaded.set(currentResources);
		}
		//åˆ¤æ–­æ˜¯å¦æœ‰å·²è¿‘æ·»åŠ è¿‡ç›¸åŒçš„encodedResource
		if (!currentResources.add(encodedResource)) {
			throw new BeanDefinitionStoreException(
					&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);
		}
		try {
			//è·å–xmlæ–‡ä»¶æµ
			InputStream inputStream = encodedResource.getResource().getInputStream();
			try {
				InputSource inputSource = new InputSource(inputStream);
				//å¦‚æœç¼–ç ä¸ä¸ºç©º,åˆ™è®¾ç½®æ–‡ä»¶ç¼–ç 
				if (encodedResource.getEncoding() != null) {
					inputSource.setEncoding(encodedResource.getEncoding());
				}
				//åŠ è½½bean
        // B
				return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
			}
			finally {
				inputStream.close();
			}
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(
					&quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);
		}
		finally {
			currentResources.remove(encodedResource);
			if (currentResources.isEmpty()) {
				this.resourcesCurrentlyBeingLoaded.remove();
			}
		}
	}
```

â€‹	ä»¥ä¸Šä»£ç åœ¨å‰é¢åˆ†æåŠ è½½æ–‡ä»¶çš„æ—¶å€™å·²ç»çœ‹è¿‡äº†,ä¸è¿‡è¿™æ¬¡çš„é‡ç‚¹æ˜¯åœ¨Bå¤„,ç»§ç»­è·Ÿä¸‹å».

```java
protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
			throws BeanDefinitionStoreException {

		try {
			// åŠ è½½xml
			// C
			Document doc = doLoadDocument(inputSource, resource);
			// æ³¨å†Œbean
			// D
			int count = registerBeanDefinitions(doc, resource);
			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource);
			}
			return count;
		}
		catch (BeanDefinitionStoreException ex) {
			throw ex;
		}
		catch (SAXParseException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					&quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);
		}
		catch (SAXException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					&quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);
		}
		catch (ParserConfigurationException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;Parser configuration exception parsing XML from &quot; + resource, ex);
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;IOException parsing XML document from &quot; + resource, ex);
		}
		catch (Throwable ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;Unexpected exception parsing XML document from &quot; + resource, ex);
		}
	}
```

â€‹	å¯ä»¥çœ‹åˆ°åŠ è½½xmlçš„åœ°æ–¹æ˜¯åœ¨Cå¤„,è·Ÿä¸‹å»çœ‹çœ‹spring æœ‰æ²¡æœ‰å¯¹åŠ è½½xmlæ–‡ä»¶åšä»€ä¹ˆç‰¹æ®Šå¤„ç†.

```java
protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception {
		return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,
				getValidationModeForResource(resource), isNamespaceAware());
	}
```

â€‹	`doLoadDocument`æ–¹æ³•å¹¶æœªå¯¹xmlè¿›è¡Œå¤„ç†,è€Œæ˜¯å§”æ‰˜`DocumentLoader`è¿›è¡Œå¤„ç†,è€Œ`DocumentLoader`åˆæ˜¯ä¸ªæ¥å£,è¿™é‡Œä½¿ç”¨çš„æ˜¯å®ƒçš„é»˜è®¤å®ç°`DefaultDocumentLoader`.

â€‹	åœ¨`DocumentLoader`æ¥å£ä¸­åªæœ‰ä¸€ä¸ªæ–¹æ³•.

```java
public interface DocumentLoader {

	/**
	 * @param inputSource xml æ–‡ä»¶
	 * @param entityResolver å®ä½“è§£æå¯¹è±¡
	 * @param errorHandler é”™è¯¯å¤„ç†å™¨
	 * @param validationMode éªŒè¯æ¨¡å¼
	 * @param namespaceAware æ˜¯å¦è‡ªåŠ¨æ„ŸçŸ¥åç§°ç©ºé—´
	 */
	Document loadDocument(
			InputSource inputSource, EntityResolver entityResolver,
			ErrorHandler errorHandler, int validationMode, boolean namespaceAware)
			throws Exception;
}

```

â€‹	å‚æ•°è¯´æ˜:

 - InputSource

   è¿™ä¸ªæ˜¯æŒ‡xmlæ–‡ä»¶,è¿™ä¸ªæ²¡æœ‰ä»€ä¹ˆå¥½è¯´çš„

- EntityResolver

  ç”¨äºåŠ è½½çº¦æŸæ–‡ä»¶,è¿™ä¸ªçº¦æŸæ–‡ä»¶å°±æ˜¯xmlçš„dtdå’Œxsd.dtdå’Œxsdæ˜¯ç”¨äºæ ¡éªŒxmlå†…å®¹

  æ˜¯å¦åˆæ³•.è€Œè¿™ä¸ªè§£æå™¨è·Ÿå‰é¢ResourceLoaderä¸€æ ·,æœ€åéƒ½æ˜¯ç”¨æ¥æŸ¥æ‰¾æ–‡ä»¶,æ— è®ºæ˜¯

  åœ¨æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿ,è¿˜æ˜¯åœ¨è¿œç¨‹ä¸»æœºä¸Š.

- ErrorHandler

  ç”¨äºå¤„ç†åŠ è½½xmlè¿‡ç¨‹ä¸­å‡ºç°çš„å¼‚å¸¸,ä¸€èˆ¬æ˜¯è®°å½•æ—¥å¿—

- validationMode

  ç”¨äºæŒ‡å®šéªŒè¯æ¨¡å¼,éªŒè¯æ¨¡å¼æœ‰å››ç§:

  1. VALIDATION_NONE

     ç¦ç”¨éªŒè¯

  2. VALIDATION_AUTO

     è‡ªåŠ¨æ£€æµ‹éªŒè¯,é»˜è®¤å€¼

  3. VALIDATION_DTD

     é‡‡ç”¨DTDéªŒè¯

  4. VALIDATION_XSD

     é‡‡ç”¨XSDéªŒè¯

- namespaceAware

  å‘½åç©ºé—´æ”¯æŒã€‚å¦‚æœè¦æä¾›å¯¹ XML åç§°ç©ºé—´çš„æ”¯æŒï¼Œåˆ™éœ€è¦å€¼ä¸ºtrue

## 2.1 EntityResolver

â€‹	`EntityResolver` æ˜¯é€šè¿‡ `getEntityResolver`æ–¹æ³•è·å–çš„,`EntityResolver`ä¹Ÿæ˜¯ä¸ªæ¥å£,ç”¨äºè§£ædtd,xsdæ–‡ä»¶.

```java
public interface EntityResolver {

    public abstract InputSource resolveEntity (String publicId,
                                               String systemId)
        throws SAXException, IOException;

}
```

â€‹	è‡³äºè¿™ä¸¤ä¸ªå‚æ•°,æ˜¯ä»€ä¹ˆæ„æ€,å¯ä»¥ç™¾åº¦ä¸€ä¸‹.

## 2.2 getEntityResolver() æ–¹æ³•

```java
protected EntityResolver getEntityResolver() {
		// å¦‚æœè§£æå™¨ä¸ºç©º
		if (this.entityResolver == null) {
			// Determine default EntityResolver to use.
			// è·å–èµ„æºåŠ è½½å™¨
			ResourceLoader resourceLoader = getResourceLoader();
			if (resourceLoader != null) {
				// å¦‚æœèµ„æºåŠ è½½å™¨ä¸ä¸ºç©º,åˆ™ä½¿ç”¨èµ„æºå®ä½“è§£æå™¨
				this.entityResolver = new ResourceEntityResolver(resourceLoader);
			}
			else {
				// å¦‚æœä¸ºç©º,åˆ™å§”æ‰˜å…¶ä»–çš„è§£æå™¨
				// é»˜è®¤çš„ä¸º BeansDtdResolver å’Œ PluggableSchemaResolver
				this.entityResolver = new DelegatingEntityResolver(getBeanClassLoader());
			}
		}
		return this.entityResolver;
	}
```

â€‹	ä»¥ä¸Šä»£ç é€šè¿‡å¤šæ¬¡åˆ¤æ–­,è¦ä¹ˆè¿”å›`ResourceEntityResolver`è¦ä¹ˆè¿”å›`DelegatingEntityResolver`.è¿™ä¸¤ä¸ªè§£æå™¨æ˜¯ä¸ªä»€ä¹ˆå…³ç³»?

â€‹	![images](https://gitee.com/oneww/onew_image/raw/master/ResourceEntityResolver.png)	

â€‹	å¯ä»¥çœ‹åˆ° `ResourceEntityResolver`æ˜¯ç»§æ‰¿`DelegatingEntityResolver`,è€Œ`DelegatingEntityResolver`å®ç°äº†`EntityResolver`æ¥å£.

```java
public class ResourceEntityResolver extends DelegatingEntityResolver {

	private static final Log logger = LogFactory.getLog(ResourceEntityResolver.class);

	private final ResourceLoader resourceLoader;


	/**
	 * Create a ResourceEntityResolver for the specified ResourceLoader
	 * (usually, an ApplicationContext).
	 * @param resourceLoader the ResourceLoader (or ApplicationContext)
	 * to load XML entity includes with
	 */
	public ResourceEntityResolver(ResourceLoader resourceLoader) {
		super(resourceLoader.getClassLoader());
		this.resourceLoader = resourceLoader;
	}


	@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId)
			throws SAXException, IOException {
		// è°ƒç”¨çˆ¶ç±» DelegatingEntityResolver::resolveEntity è·å–xsdæˆ–è€…dtd,éƒ½æ˜¯ä»æœ¬åœ°çš„classpathè·¯å¾„ä¸‹åŠ è½½æ–‡ä»¶
		InputSource source = super.resolveEntity(publicId, systemId);

		//å¦‚æœ DelegatingEntityResolver::resolveEntity æœ¬åœ°æœªèƒ½åŠ è½½åˆ°xsdæˆ–è€…dtdæ–‡ä»¶
		if (source == null &amp;&amp; systemId != null) {
			String resourcePath = null;
			try {
				// ä½¿ç”¨UTF-8 è§£ç 
				String decodedSystemId = URLDecoder.decode(systemId, &quot;UTF-8&quot;);
				// è½¬ä¸ºURL
				String givenUrl = new URL(decodedSystemId).toString();
				// è§£ææ–‡ä»¶èµ„æºçš„ç›¸å¯¹è·¯å¾„ï¼ˆç›¸å¯¹äºç³»ç»Ÿæ ¹è·¯å¾„ï¼‰
				String systemRootUrl = new File(&quot;&quot;).toURI().toURL().toString();
				// Try relative to resource base if currently in system root.
				if (givenUrl.startsWith(systemRootUrl)) {
					resourcePath = givenUrl.substring(systemRootUrl.length());
				}
			}
			catch (Exception ex) {
				// Typically a MalformedURLException or AccessControlException.
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Could not resolve XML entity [&quot; + systemId + &quot;] against system root URL&quot;, ex);
				}
				// No URL (or no resolvable URL) -&gt; try relative to resource base.
				resourcePath = systemId;
			}
			if (resourcePath != null) {
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Trying to locate XML entity [&quot; + systemId + &quot;] as resource [&quot; + resourcePath + &quot;]&quot;);
				}
				// å†æ¬¡å°è¯•ä»classpathè·¯å¾„ä¸‹åŠ è½½æ–‡ä»¶
				Resource resource = this.resourceLoader.getResource(resourcePath);
				source = new InputSource(resource.getInputStream());
				source.setPublicId(publicId);
				source.setSystemId(systemId);
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Found XML entity [&quot; + systemId + &quot;]: &quot; + resource);
				}
			}//å®åœ¨æ²¡æœ‰åŠæ³•äº†,ä»ç½‘ç»œä¸Šè¿›è¡ŒåŠ è½½
			else if (systemId.endsWith(DTD_SUFFIX) || systemId.endsWith(XSD_SUFFIX)) {
				// External dtd/xsd lookup via https even for canonical http declaration
				String url = systemId;
				if (url.startsWith(&quot;http:&quot;)) {
					url = &quot;https:&quot; + url.substring(5);
				}
				try {
					//é€šè¿‡url httpåŠ è½½èµ„æº,ç½‘ç»œæƒ…å†µä¸å¥½çš„æƒ…å†µä¸‹å¾ˆå®¹æ˜“æŒ‚
					source = new InputSource(new URL(url).openStream());
					source.setPublicId(publicId);
					source.setSystemId(systemId);
				}
				catch (IOException ex) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Could not resolve XML entity [&quot; + systemId + &quot;] through URL [&quot; + url + &quot;]&quot;, ex);
					}
					// Fall back to the parser's default behavior.
					source = null;
				}
			}
		}

		return source;
	}

}

```

â€‹	å¤§è‡´é€»è¾‘å¦‚ä¸‹:

1. è°ƒç”¨çˆ¶è§£æå™¨,è¿›è¡Œè§£æ.å¦‚æœèƒ½åŠ è½½åˆ°æ–‡ä»¶,åˆ™è¿”å›.

 	2. å°è¯•ä»classpathè·¯å¾„è¿›è¡ŒåŠ è½½
 	3. å°è¯•ä»ç½‘ç»œä¸Šè¿›è¡ŒåŠ è½½
 	4. åŠ è½½æˆåŠŸ è¿”å› InputSource å¯¹è±¡ å¦åˆ™ è¿”å› NULL

é€»è¾‘å¹¶ä¸å¤æ‚,è¿™é‡Œæ¶‰åŠåˆ°çˆ¶è§£æå™¨`DelegatingEntityResolver`.

```java
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.beans.factory.xml;

import java.io.IOException;

import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * {@link EntityResolver} implementation that delegates to a {@link BeansDtdResolver}
 * and a {@link PluggableSchemaResolver} for DTDs and XML schemas, respectively.
 *
 * @author Rob Harrop
 * @author Juergen Hoeller
 * @author Rick Evans
 * @since 2.0
 * @see BeansDtdResolver
 * @see PluggableSchemaResolver
 */
public class DelegatingEntityResolver implements EntityResolver {

	/** Suffix for DTD files. */
  // åç¼€å¸¸é‡
	public static final String DTD_SUFFIX = &quot;.dtd&quot;;

	/** Suffix for schema definition files. */
  // åç¼€å¸¸é‡
	public static final String XSD_SUFFIX = &quot;.xsd&quot;;

	// dtd è§£æå™¨
	private final EntityResolver dtdResolver;
	// xsd è§£æå™¨
	private final EntityResolver schemaResolver;


	
	public DelegatingEntityResolver(@Nullable ClassLoader classLoader) {
		this.dtdResolver = new BeansDtdResolver();
		this.schemaResolver = new PluggableSchemaResolver(classLoader);
	}

	
	public DelegatingEntityResolver(EntityResolver dtdResolver, EntityResolver schemaResolver) {
		Assert.notNull(dtdResolver, &quot;'dtdResolver' is required&quot;);
		Assert.notNull(schemaResolver, &quot;'schemaResolver' is required&quot;);
		this.dtdResolver = dtdResolver;
		this.schemaResolver = schemaResolver;
	}


	@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId)
			throws SAXException, IOException {
		//é€šè¿‡åç¼€å»è·å–èµ„æºè·¯å¾„
		if (systemId != null) {
			// DTD æ¨¡å¼
			if (systemId.endsWith(DTD_SUFFIX)) {
				// é»˜è®¤ä¸º BeansDtdResolver
				return this.dtdResolver.resolveEntity(publicId, systemId);
			}
			// XSD æ¨¡å¼
			else if (systemId.endsWith(XSD_SUFFIX)) {
				// é»˜è®¤ä¸º PluggableSchemaResolver
				return this.schemaResolver.resolveEntity(publicId, systemId);
			}
		}

		// Fall back to the parser's default behavior.
		return null;
	}


	@Override
	public String toString() {
		return &quot;EntityResolver delegating &quot; + XSD_SUFFIX + &quot; to &quot; + this.schemaResolver +
				&quot; and &quot; + DTD_SUFFIX + &quot; to &quot; + this.dtdResolver;
	}

}

```

â€‹	`DelegatingEntityResolver`ä¸­çš„`resolveEntity`æ–¹æ³•å¹¶æ²¡æœ‰çœŸæ­£çš„è¿›è¡Œé€»è¾‘å¤„ç†,è€Œæ˜¯å§”æ‰˜`dtdResolver`å’Œ

`schemaResolver`è¿›è¡Œå¤„ç†,è¿™ä¸¤ä¸ªè§£æå™¨ä¸€ä¸ªè´Ÿè´£DTD,å¦å¤–ä¸€ä¸ªè´Ÿè´£XSD.

â€‹	`dtdResolver` é»˜è®¤ä¸º:`BeansDtdResolver`

â€‹	`schemaResolver`é»˜è®¤ä¸º:`PluggableSchemaResolver`



## 2.3 BeansDtdResolver

```java
public class BeansDtdResolver implements EntityResolver {
	// DTD åç¼€å¸¸é‡
	private static final String DTD_EXTENSION = &quot;.dtd&quot;;
	// DTD åç§°
	private static final String DTD_NAME = &quot;spring-beans&quot;;

	private static final Log logger = LogFactory.getLog(BeansDtdResolver.class);


	@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws IOException {
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Trying to resolve XML entity with public ID [&quot; + publicId +
					&quot;] and system ID [&quot; + systemId + &quot;]&quot;);
		}
		// åˆ¤æ–­åç¼€æ˜¯å¦æ˜¯ DTD,å¹¶ä¸”systemId ä¸èƒ½ä¸ºç©º
		if (systemId != null &amp;&amp; systemId.endsWith(DTD_EXTENSION)) {
      // åˆ†éš”ç¬¦
			int lastPathSeparator = systemId.lastIndexOf('/');
			int dtdNameStart = systemId.indexOf(DTD_NAME, lastPathSeparator);
			// systemId url ä¸­ å¿…é¡»åŒ…å« spring-beans
			if (dtdNameStart != -1) {
				// å¹¶ä¸”dtdæ–‡ä»¶å
				String dtdFile = DTD_NAME + DTD_EXTENSION;
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Trying to locate [&quot; + dtdFile + &quot;] in Spring jar on classpath&quot;);
				}
				try {
					// åŠ è½½classpathè·¯å¾„ä¸‹çš„spring-beans.dtdæ–‡ä»¶
					Resource resource = new ClassPathResource(dtdFile, getClass());
					InputSource source = new InputSource(resource.getInputStream());
					// è®¾ç½®publicId
					source.setPublicId(publicId);
					// è®¾ç½®systemId
					source.setSystemId(systemId);
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Found beans DTD [&quot; + systemId + &quot;] in classpath: &quot; + dtdFile);
					}
					return source;
				}
				catch (FileNotFoundException ex) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Could not resolve beans DTD [&quot; + systemId + &quot;]: not found in classpath&quot;, ex);
					}
				}
			}
		}

		// Fall back to the parser's default behavior.
		return null;
	}


	@Override
	public String toString() {
		return &quot;EntityResolver for spring-beans DTD&quot;;
	}

}

```

 `BeansDtdResolver` é€»è¾‘ä¸º,ä»classpathä¸‹åŠ è½½æ–‡ä»¶åä¸º`spring-beans.dtd`çš„dtdæ–‡ä»¶



## 2.4 PluggableSchemaResolver

```java
public class PluggableSchemaResolver implements EntityResolver {

	/**
	 * The location of the file that defines schema mappings.
	 * Can be present in multiple JAR files.
	 */
	public static final String DEFAULT_SCHEMA_MAPPINGS_LOCATION = &quot;META-INF/spring.schemas&quot;;


	private static final Log logger = LogFactory.getLog(PluggableSchemaResolver.class);

	@Nullable
	private final ClassLoader classLoader;

	private final String schemaMappingsLocation;

	/** Stores the mapping of schema URL -&gt; local schema path. */
	@Nullable
	private volatile Map&lt;String, String&gt; schemaMappings;


	
	public PluggableSchemaResolver(@Nullable ClassLoader classLoader) {
		this.classLoader = classLoader;
		this.schemaMappingsLocation = DEFAULT_SCHEMA_MAPPINGS_LOCATION;
	}

	public PluggableSchemaResolver(@Nullable ClassLoader classLoader, String schemaMappingsLocation) {
		Assert.hasText(schemaMappingsLocation, &quot;'schemaMappingsLocation' must not be empty&quot;);
		this.classLoader = classLoader;
		this.schemaMappingsLocation = schemaMappingsLocation;
	}

	/***
	 * å…ˆæŠŠxsdæ–‡ä»¶ä¸‹è½½åˆ°æœ¬åœ°,åœ¨è¿›è¡ŒåŠ è½½
	 * **/
	@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws IOException {
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Trying to resolve XML entity with public id [&quot; + publicId +
					&quot;] and system id [&quot; + systemId + &quot;]&quot;);
		}
		// systemId url ä¸èƒ½ä¸ºç©º
		if (systemId != null) {
			// ä»ç¼“å­˜ä¸­åŠ è½½xsdæ–‡ä»¶
			// åˆ¤æ–­ç¼“å­˜ä¸­æ˜¯å¦æœ‰xsdæ–‡ä»¶
			// ç¼“å­˜ä¸­çš„xsdæ–‡ä»¶éƒ½æ˜¯ä»ç½‘ç»œä¸­åŠ è½½
			String resourceLocation = getSchemaMappings().get(systemId);
			if (resourceLocation == null &amp;&amp; systemId.startsWith(&quot;https:&quot;)) {
				// Retrieve canonical http schema mapping even for https declaration
				// å¦‚æœhttps æœªæ‰¾åˆ°çº¦æŸæ–‡ä»¶ åˆ™å°è¯•ä»http è·å–ç¼“å­˜
				resourceLocation = getSchemaMappings().get(&quot;http:&quot; + systemId.substring(6));
			}
			//å¦‚æœç¼“å­˜å‘½ä¸­
			if (resourceLocation != null) {
				//ä»classpathè·¯å¾„ä¸­åŠ è½½xsdæ–‡ä»¶
				Resource resource = new ClassPathResource(resourceLocation, this.classLoader);
				try {
					InputSource source = new InputSource(resource.getInputStream());
					// è®¾ç½®publicId
					source.setPublicId(publicId);
					// è®¾ç½®systemId
					source.setSystemId(systemId);
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Found XML schema [&quot; + systemId + &quot;] in classpath: &quot; + resourceLocation);
					}
					return source;
				}
				catch (FileNotFoundException ex) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Could not find XML schema [&quot; + systemId + &quot;]: &quot; + resource, ex);
					}
				}
			}
		}

		// Fall back to the parser's default behavior.
		return null;
	}

	/**
	 * Load the specified schema mappings lazily.
	 */
	private Map&lt;String, String&gt; getSchemaMappings() {
		Map&lt;String, String&gt; schemaMappings = this.schemaMappings;
		if (schemaMappings == null) {
			// å•åˆ©æ¨¡å¼ åŒæ­¥
			synchronized (this) {
				schemaMappings = this.schemaMappings;
				// åŒé‡æ£€æŸ¥
				if (schemaMappings == null) {
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Loading schema mappings from [&quot; + this.schemaMappingsLocation + &quot;]&quot;);
					}
					try {
						// åŠ è½½clsspathè·¯å¾„ä¸‹çš„ META-INF/spring.schemas
						Properties mappings =
								PropertiesLoaderUtils.loadAllProperties(this.schemaMappingsLocation, this.classLoader);
						if (logger.isTraceEnabled()) {
							logger.trace(&quot;Loaded schema mappings: &quot; + mappings);
						}
						// åˆ›å»ºçº¿ç¨‹å®‰å…¨çš„çš„hashMap
						schemaMappings = new ConcurrentHashMap&lt;&gt;(mappings.size());
						// properties è½¬ hashMap
						CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings);
						// èµ‹å€¼
						this.schemaMappings = schemaMappings;
					}
					catch (IOException ex) {
						throw new IllegalStateException(
								&quot;Unable to load schema mappings from location [&quot; + this.schemaMappingsLocation + &quot;]&quot;, ex);
					}
				}
			}
		}
		return schemaMappings;
	}


	@Override
	public String toString() {
		return &quot;EntityResolver using schema mappings &quot; + getSchemaMappings();
	}

}

```

â€‹	`PluggableSchemaResolver`å¤§ä½“é€»è¾‘å¦‚ä¸‹:

	1. å…ˆæ ¹æ®classpathè·¯å¾„ä¸‹çš„` META-INF/spring.schemas`æ–‡ä»¶åˆ›å»ºä¸€ä¸ªç¼“å­˜`schemaMappings`
 	2. ä»`schemaMappings`è·å–æŒ‡å®š`systemId`çš„xsdæ–‡ä»¶è·¯å¾„,å¦‚æœæœªè·å–åˆ°è¿”å›null
 	3. æ ¹æ®xsdè·¯å¾„åŠ è½½xsdæ–‡ä»¶è¿”å› `InputSource` å¯¹è±¡



## 2.5 getValidationModeForResource()

```java
protected int getValidationModeForResource(Resource resource) {
		// è·å–éªŒè¯æ¨¡å¼,é»˜è®¤ä¸ºè‡ªåŠ¨
		int validationModeToUse = getValidationMode();
		// å¦‚æœæ‰‹åŠ¨æŒ‡å®šéªŒè¯æ¨¡å¼åˆ™ä½¿ç”¨æŒ‡å®šçš„éªŒè¯æ¨¡å¼
		if (validationModeToUse != VALIDATION_AUTO) {
			return validationModeToUse;
		}
		// éæ‰‹åŠ¨æŒ‡å®šéªŒè¯æ¨¡å¼,è‡ªåŠ¨æ£€æµ‹éªŒè¯æ¨¡å¼
		int detectedMode = detectValidationMode(resource);
		if (detectedMode != VALIDATION_AUTO) {
			return detectedMode;
		}
		// Hmm, we didn't get a clear indication... Let's assume XSD,
		// since apparently no DTD declaration has been found up until
		// detection stopped (before finding the document's root tag).
		// ä»¥ä¸Šéƒ½æœªè·å–éªŒè¯æ¨¡å¼,åˆ™ä½¿ç”¨xsdéªŒè¯æ¨¡å¼
		return VALIDATION_XSD;
	}
```



## 2.6 loadDocument()

```java
@Override
	public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
			ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {
		// è§£æxmlå¸¸ç”¨å¥—è·¯
		DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);
		}
		// è§£æxmlå¸¸ç”¨å¥—è·¯
		DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
		return builder.parse(inputSource);
	}

	/**
	 * Create the {@link DocumentBuilderFactory} instance.
	 * @param validationMode the type of validation: {@link XmlValidationModeDetector#VALIDATION_DTD DTD}
	 * or {@link XmlValidationModeDetector#VALIDATION_XSD XSD})
	 * @param namespaceAware whether the returned factory is to provide support for XML namespaces
	 * @return the JAXP DocumentBuilderFactory
	 * @throws ParserConfigurationException if we failed to build a proper DocumentBuilderFactory
	 */
	protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware)
			throws ParserConfigurationException {

		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		// è®¾ç½®å‘½åç©ºé—´æ”¯æŒ
		factory.setNamespaceAware(namespaceAware);
		// éç¦ç”¨éªŒè¯æ¨¡å¼
		if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) {
			// å¼€å¯æ ¡éªŒ
			factory.setValidating(true);
			// å¦‚æœä¸ºXSD
			if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {
				// Enforce namespace aware for XSD...
				// XSD æ¨¡å¼ä¸‹ï¼Œå¼ºåˆ¶è®¾ç½®å‘½åç©ºé—´æ”¯æŒ
				factory.setNamespaceAware(true);
				try {
					// è®¾ç½® SCHEMA_LANGUAGE_ATTRIBUTE
					factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);
				}
				catch (IllegalArgumentException ex) {
					ParserConfigurationException pcex = new ParserConfigurationException(
							&quot;Unable to validate using XSD: Your JAXP provider [&quot; + factory +
							&quot;] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? &quot; +
							&quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;);
					pcex.initCause(ex);
					throw pcex;
				}
			}
		}

		return factory;
	}

```



# ä¸‰ã€å°ç»“

â€‹	xml åŠ è½½å¹¶åˆ›å»ºä¸º `Document` å¯¹è±¡,æ¥ä¸‹æ¥å°±æ˜¯ è§£æå¹¶åˆ›å»ºä¸ºbean.</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">ä¸€ã€å‰è¨€ â€‹ å‰é¢èµ„æºæ–‡ä»¶åŠ è½½æå®šäº†,æ¥çœ‹çœ‹ spring æ˜¯å¦‚ä½•æŠŠ xml æ–‡ä»¶å˜æˆ bean çš„å§. äºŒã€åˆ†æ â€‹ è¿˜æ˜¯ä»4å¥ä»£ç çœ‹èµ·. @Test public void testSpringLoadXml(){ // åŠ è½½xml BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBean.xml&quot;)); // è·å–bean final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class); final String testStr = testBean.getTestStr(); System.out.println(testStr); } â€‹ ä»è§£æxml åˆ° è·å–beanéƒ½æ˜¯ä»XmlBeanFactoryä¸­æ“ä½œçš„,é‚£ä¹ˆå°±æ¥çœ‹çœ‹XmlBeanFactoryé‡Œé¢æœ‰å•¥. public class XmlBeanFactory extends DefaultListableBeanFactory { private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this); /** * æ„é€ å‡½æ•° */ public XmlBeanFactory(Resource resource) throws BeansException { this(resource, null); } /** * æ„é€ å‡½æ•° * æŒ‡å®š çˆ¶BeanFactory */ public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException { super(parentBeanFactory); // æ ¸å¿ƒä»£ç  A this.reader.loadBeanDefinitions(resource); } } â€‹ å¯ä»¥çœ‹åˆ°æ ¸å¿ƒä»£ç åœ¨Aå¤„,Aå¤„ç”¨XmlBeanDefinitionReaderè¿›è¡Œè¯»å–æ–‡ä»¶,ç»§ç»­è·Ÿä¸‹å». @Override public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException { // æŠŠclassPathsResourceè½¬æ¢ä¸ºEncodedResource,é»˜è®¤å­—ç¬¦ç¼–ç ä¸ºç©º return loadBeanDefinitions(new EncodedResource(resource)); } public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException { //åŠ è½½èµ„æº,èµ„æºä¸èƒ½ä¸ºç©º Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); if (logger.isTraceEnabled()) { logger.trace(&quot;Loading XML bean definitions from &quot; + encodedResource); } //åˆ¤æ–­å½“å‰çº¿ç¨‹æ˜¯å¦åŠ è½½è¿‡èµ„æº,å¦‚æœæ²¡æœ‰åˆ™åˆ›å»ºä¸€ä¸ªsetæ¥ä¿å­˜encodedResource Set&amp;lt;EncodedResource&amp;gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) { currentResources = new HashSet&amp;lt;&amp;gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); } //åˆ¤æ–­æ˜¯å¦æœ‰å·²è¿‘æ·»åŠ è¿‡ç›¸åŒçš„encodedResource if (!currentResources.add(encodedResource)) { throw new BeanDefinitionStoreException( &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;); } try { //è·å–xmlæ–‡ä»¶æµ InputStream inputStream = encodedResource.getResource().getInputStream(); try { InputSource inputSource = new InputSource(inputStream); //å¦‚æœç¼–ç ä¸ä¸ºç©º,åˆ™è®¾ç½®æ–‡ä»¶ç¼–ç  if (encodedResource.getEncoding() != null) { inputSource.setEncoding(encodedResource.getEncoding()); } //åŠ è½½bean // B return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); } finally { inputStream.close(); } } catch (IOException ex) { throw new BeanDefinitionStoreException( &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex); } finally { currentResources.remove(encodedResource); if (currentResources.isEmpty()) { this.resourcesCurrentlyBeingLoaded.remove(); } } } â€‹ ä»¥ä¸Šä»£ç åœ¨å‰é¢åˆ†æåŠ è½½æ–‡ä»¶çš„æ—¶å€™å·²ç»çœ‹è¿‡äº†,ä¸è¿‡è¿™æ¬¡çš„é‡ç‚¹æ˜¯åœ¨Bå¤„,ç»§ç»­è·Ÿä¸‹å». protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { // åŠ è½½xml // C Document doc = doLoadDocument(inputSource, resource); // æ³¨å†Œbean // D int count = registerBeanDefinitions(doc, resource); if (logger.isDebugEnabled()) { logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource); } return count; } catch (BeanDefinitionStoreException ex) { throw ex; } catch (SAXParseException ex) { throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex); } catch (SAXException ex) { throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex); } catch (ParserConfigurationException ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Parser configuration exception parsing XML from &quot; + resource, ex); } catch (IOException ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;IOException parsing XML document from &quot; + resource, ex); } catch (Throwable ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Unexpected exception parsing XML document from &quot; + resource, ex); } } â€‹ å¯ä»¥çœ‹åˆ°åŠ è½½xmlçš„åœ°æ–¹æ˜¯åœ¨Cå¤„,è·Ÿä¸‹å»çœ‹çœ‹spring æœ‰æ²¡æœ‰å¯¹åŠ è½½xmlæ–‡ä»¶åšä»€ä¹ˆç‰¹æ®Šå¤„ç†. protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception { return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware()); } â€‹ doLoadDocumentæ–¹æ³•å¹¶æœªå¯¹xmlè¿›è¡Œå¤„ç†,è€Œæ˜¯å§”æ‰˜DocumentLoaderè¿›è¡Œå¤„ç†,è€ŒDocumentLoaderåˆæ˜¯ä¸ªæ¥å£,è¿™é‡Œä½¿ç”¨çš„æ˜¯å®ƒçš„é»˜è®¤å®ç°DefaultDocumentLoader. â€‹ åœ¨DocumentLoaderæ¥å£ä¸­åªæœ‰ä¸€ä¸ªæ–¹æ³•. public interface DocumentLoader { /** * @param inputSource xml æ–‡ä»¶ * @param entityResolver å®ä½“è§£æå¯¹è±¡ * @param errorHandler é”™è¯¯å¤„ç†å™¨ * @param validationMode éªŒè¯æ¨¡å¼ * @param namespaceAware æ˜¯å¦è‡ªåŠ¨æ„ŸçŸ¥åç§°ç©ºé—´ */ Document loadDocument( InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception; } â€‹ å‚æ•°è¯´æ˜: InputSource è¿™ä¸ªæ˜¯æŒ‡xmlæ–‡ä»¶,è¿™ä¸ªæ²¡æœ‰ä»€ä¹ˆå¥½è¯´çš„ EntityResolver ç”¨äºåŠ è½½çº¦æŸæ–‡ä»¶,è¿™ä¸ªçº¦æŸæ–‡ä»¶å°±æ˜¯xmlçš„dtdå’Œxsd.dtdå’Œxsdæ˜¯ç”¨äºæ ¡éªŒxmlå†…å®¹ æ˜¯å¦åˆæ³•.è€Œè¿™ä¸ªè§£æå™¨è·Ÿå‰é¢ResourceLoaderä¸€æ ·,æœ€åéƒ½æ˜¯ç”¨æ¥æŸ¥æ‰¾æ–‡ä»¶,æ— è®ºæ˜¯ åœ¨æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿ,è¿˜æ˜¯åœ¨è¿œç¨‹ä¸»æœºä¸Š. ErrorHandler ç”¨äºå¤„ç†åŠ è½½xmlè¿‡ç¨‹ä¸­å‡ºç°çš„å¼‚å¸¸,ä¸€èˆ¬æ˜¯è®°å½•æ—¥å¿— validationMode ç”¨äºæŒ‡å®šéªŒè¯æ¨¡å¼,éªŒè¯æ¨¡å¼æœ‰å››ç§: VALIDATION_NONE ç¦ç”¨éªŒè¯ VALIDATION_AUTO è‡ªåŠ¨æ£€æµ‹éªŒè¯,é»˜è®¤å€¼ VALIDATION_DTD é‡‡ç”¨DTDéªŒè¯ VALIDATION_XSD é‡‡ç”¨XSDéªŒè¯ namespaceAware å‘½åç©ºé—´æ”¯æŒã€‚å¦‚æœè¦æä¾›å¯¹ XML åç§°ç©ºé—´çš„æ”¯æŒï¼Œåˆ™éœ€è¦å€¼ä¸ºtrue 2.1 EntityResolver â€‹ EntityResolver æ˜¯é€šè¿‡ getEntityResolveræ–¹æ³•è·å–çš„,EntityResolverä¹Ÿæ˜¯ä¸ªæ¥å£,ç”¨äºè§£ædtd,xsdæ–‡ä»¶. public interface EntityResolver { public abstract InputSource resolveEntity (String publicId, String systemId) throws SAXException, IOException; } â€‹ è‡³äºè¿™ä¸¤ä¸ªå‚æ•°,æ˜¯ä»€ä¹ˆæ„æ€,å¯ä»¥ç™¾åº¦ä¸€ä¸‹. 2.2 getEntityResolver() æ–¹æ³• protected EntityResolver getEntityResolver() { // å¦‚æœè§£æå™¨ä¸ºç©º if (this.entityResolver == null) { // Determine default EntityResolver to use. // è·å–èµ„æºåŠ è½½å™¨ ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader != null) { // å¦‚æœèµ„æºåŠ è½½å™¨ä¸ä¸ºç©º,åˆ™ä½¿ç”¨èµ„æºå®ä½“è§£æå™¨ this.entityResolver = new ResourceEntityResolver(resourceLoader); } else { // å¦‚æœä¸ºç©º,åˆ™å§”æ‰˜å…¶ä»–çš„è§£æå™¨ // é»˜è®¤çš„ä¸º BeansDtdResolver å’Œ PluggableSchemaResolver this.entityResolver = new DelegatingEntityResolver(getBeanClassLoader()); } } return this.entityResolver; } â€‹ ä»¥ä¸Šä»£ç é€šè¿‡å¤šæ¬¡åˆ¤æ–­,è¦ä¹ˆè¿”å›ResourceEntityResolverè¦ä¹ˆè¿”å›DelegatingEntityResolver.è¿™ä¸¤ä¸ªè§£æå™¨æ˜¯ä¸ªä»€ä¹ˆå…³ç³»? â€‹ â€‹ å¯ä»¥çœ‹åˆ° ResourceEntityResolveræ˜¯ç»§æ‰¿DelegatingEntityResolver,è€ŒDelegatingEntityResolverå®ç°äº†EntityResolveræ¥å£. public class ResourceEntityResolver extends DelegatingEntityResolver { private static final Log logger = LogFactory.getLog(ResourceEntityResolver.class); private final ResourceLoader resourceLoader; /** * Create a ResourceEntityResolver for the specified ResourceLoader * (usually, an ApplicationContext). * @param resourceLoader the ResourceLoader (or ApplicationContext) * to load XML entity includes with */ public ResourceEntityResolver(ResourceLoader resourceLoader) { super(resourceLoader.getClassLoader()); this.resourceLoader = resourceLoader; } @Override @Nullable public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws SAXException, IOException { // è°ƒç”¨çˆ¶ç±» DelegatingEntityResolver::resolveEntity è·å–xsdæˆ–è€…dtd,éƒ½æ˜¯ä»æœ¬åœ°çš„classpathè·¯å¾„ä¸‹åŠ è½½æ–‡ä»¶ InputSource source = super.resolveEntity(publicId, systemId); //å¦‚æœ DelegatingEntityResolver::resolveEntity æœ¬åœ°æœªèƒ½åŠ è½½åˆ°xsdæˆ–è€…dtdæ–‡ä»¶ if (source == null &amp;amp;&amp;amp; systemId != null) { String resourcePath = null; try { // ä½¿ç”¨UTF-8 è§£ç  String decodedSystemId = URLDecoder.decode(systemId, &quot;UTF-8&quot;); // è½¬ä¸ºURL String givenUrl = new URL(decodedSystemId).toString(); // è§£ææ–‡ä»¶èµ„æºçš„ç›¸å¯¹è·¯å¾„ï¼ˆç›¸å¯¹äºç³»ç»Ÿæ ¹è·¯å¾„ï¼‰ String systemRootUrl = new File(&quot;&quot;).toURI().toURL().toString(); // Try relative to resource base if currently in system root. if (givenUrl.startsWith(systemRootUrl)) { resourcePath = givenUrl.substring(systemRootUrl.length()); } } catch (Exception ex) { // Typically a MalformedURLException or AccessControlException. if (logger.isDebugEnabled()) { logger.debug(&quot;Could not resolve XML entity [&quot; + systemId + &quot;] against system root URL&quot;, ex); } // No URL (or no resolvable URL) -&amp;gt; try relative to resource base. resourcePath = systemId; } if (resourcePath != null) { if (logger.isTraceEnabled()) { logger.trace(&quot;Trying to locate XML entity [&quot; + systemId + &quot;] as resource [&quot; + resourcePath + &quot;]&quot;); } // å†æ¬¡å°è¯•ä»classpathè·¯å¾„ä¸‹åŠ è½½æ–‡ä»¶ Resource resource = this.resourceLoader.getResource(resourcePath); source = new InputSource(resource.getInputStream()); source.setPublicId(publicId); source.setSystemId(systemId); if (logger.isDebugEnabled()) { logger.debug(&quot;Found XML entity [&quot; + systemId + &quot;]: &quot; + resource); } }//å®åœ¨æ²¡æœ‰åŠæ³•äº†,ä»ç½‘ç»œä¸Šè¿›è¡ŒåŠ è½½ else if (systemId.endsWith(DTD_SUFFIX) || systemId.endsWith(XSD_SUFFIX)) { // External dtd/xsd lookup via https even for canonical http declaration String url = systemId; if (url.startsWith(&quot;http:&quot;)) { url = &quot;https:&quot; + url.substring(5); } try { //é€šè¿‡url httpåŠ è½½èµ„æº,ç½‘ç»œæƒ…å†µä¸å¥½çš„æƒ…å†µä¸‹å¾ˆå®¹æ˜“æŒ‚ source = new InputSource(new URL(url).openStream()); source.setPublicId(publicId); source.setSystemId(systemId); } catch (IOException ex) { if (logger.isDebugEnabled()) { logger.debug(&quot;Could not resolve XML entity [&quot; + systemId + &quot;] through URL [&quot; + url + &quot;]&quot;, ex); } // Fall back to the parser's default behavior. source = null; } } } return source; } } â€‹ å¤§è‡´é€»è¾‘å¦‚ä¸‹: è°ƒç”¨çˆ¶è§£æå™¨,è¿›è¡Œè§£æ.å¦‚æœèƒ½åŠ è½½åˆ°æ–‡ä»¶,åˆ™è¿”å›. 2. å°è¯•ä»classpathè·¯å¾„è¿›è¡ŒåŠ è½½ 3. å°è¯•ä»ç½‘ç»œä¸Šè¿›è¡ŒåŠ è½½ 4. åŠ è½½æˆåŠŸ è¿”å› InputSource å¯¹è±¡ å¦åˆ™ è¿”å› NULL é€»è¾‘å¹¶ä¸å¤æ‚,è¿™é‡Œæ¶‰åŠåˆ°çˆ¶è§£æå™¨DelegatingEntityResolver. /* * Copyright 2002-2019 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.springframework.beans.factory.xml; import java.io.IOException; import org.xml.sax.EntityResolver; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.springframework.lang.Nullable; import org.springframework.util.Assert; /** * {@link EntityResolver} implementation that delegates to a {@link BeansDtdResolver} * and a {@link PluggableSchemaResolver} for DTDs and XML schemas, respectively. * * @author Rob Harrop * @author Juergen Hoeller * @author Rick Evans * @since 2.0 * @see BeansDtdResolver * @see PluggableSchemaResolver */ public class DelegatingEntityResolver implements EntityResolver { /** Suffix for DTD files. */ // åç¼€å¸¸é‡ public static final String DTD_SUFFIX = &quot;.dtd&quot;; /** Suffix for schema definition files. */ // åç¼€å¸¸é‡ public static final String XSD_SUFFIX = &quot;.xsd&quot;; // dtd è§£æå™¨ private final EntityResolver dtdResolver; // xsd è§£æå™¨ private final EntityResolver schemaResolver; public DelegatingEntityResolver(@Nullable ClassLoader classLoader) { this.dtdResolver = new BeansDtdResolver(); this.schemaResolver = new PluggableSchemaResolver(classLoader); } public DelegatingEntityResolver(EntityResolver dtdResolver, EntityResolver schemaResolver) { Assert.notNull(dtdResolver, &quot;'dtdResolver' is required&quot;); Assert.notNull(schemaResolver, &quot;'schemaResolver' is required&quot;); this.dtdResolver = dtdResolver; this.schemaResolver = schemaResolver; } @Override @Nullable public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws SAXException, IOException { //é€šè¿‡åç¼€å»è·å–èµ„æºè·¯å¾„ if (systemId != null) { // DTD æ¨¡å¼ if (systemId.endsWith(DTD_SUFFIX)) { // é»˜è®¤ä¸º BeansDtdResolver return this.dtdResolver.resolveEntity(publicId, systemId); } // XSD æ¨¡å¼ else if (systemId.endsWith(XSD_SUFFIX)) { // é»˜è®¤ä¸º PluggableSchemaResolver return this.schemaResolver.resolveEntity(publicId, systemId); } } // Fall back to the parser's default behavior. return null; } @Override public String toString() { return &quot;EntityResolver delegating &quot; + XSD_SUFFIX + &quot; to &quot; + this.schemaResolver + &quot; and &quot; + DTD_SUFFIX + &quot; to &quot; + this.dtdResolver; } } â€‹ DelegatingEntityResolverä¸­çš„resolveEntityæ–¹æ³•å¹¶æ²¡æœ‰çœŸæ­£çš„è¿›è¡Œé€»è¾‘å¤„ç†,è€Œæ˜¯å§”æ‰˜dtdResolverå’Œ schemaResolverè¿›è¡Œå¤„ç†,è¿™ä¸¤ä¸ªè§£æå™¨ä¸€ä¸ªè´Ÿè´£DTD,å¦å¤–ä¸€ä¸ªè´Ÿè´£XSD. â€‹ dtdResolver é»˜è®¤ä¸º:BeansDtdResolver â€‹ schemaResolveré»˜è®¤ä¸º:PluggableSchemaResolver 2.3 BeansDtdResolver public class BeansDtdResolver implements EntityResolver { // DTD åç¼€å¸¸é‡ private static final String DTD_EXTENSION = &quot;.dtd&quot;; // DTD åç§° private static final String DTD_NAME = &quot;spring-beans&quot;; private static final Log logger = LogFactory.getLog(BeansDtdResolver.class); @Override @Nullable public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws IOException { if (logger.isTraceEnabled()) { logger.trace(&quot;Trying to resolve XML entity with public ID [&quot; + publicId + &quot;] and system ID [&quot; + systemId + &quot;]&quot;); } // åˆ¤æ–­åç¼€æ˜¯å¦æ˜¯ DTD,å¹¶ä¸”systemId ä¸èƒ½ä¸ºç©º if (systemId != null &amp;amp;&amp;amp; systemId.endsWith(DTD_EXTENSION)) { // åˆ†éš”ç¬¦ int lastPathSeparator = systemId.lastIndexOf('/'); int dtdNameStart = systemId.indexOf(DTD_NAME, lastPathSeparator); // systemId url ä¸­ å¿…é¡»åŒ…å« spring-beans if (dtdNameStart != -1) { // å¹¶ä¸”dtdæ–‡ä»¶å String dtdFile = DTD_NAME + DTD_EXTENSION; if (logger.isTraceEnabled()) { logger.trace(&quot;Trying to locate [&quot; + dtdFile + &quot;] in Spring jar on classpath&quot;); } try { // åŠ è½½classpathè·¯å¾„ä¸‹çš„spring-beans.dtdæ–‡ä»¶ Resource resource = new ClassPathResource(dtdFile, getClass()); InputSource source = new InputSource(resource.getInputStream()); // è®¾ç½®publicId source.setPublicId(publicId); // è®¾ç½®systemId source.setSystemId(systemId); if (logger.isTraceEnabled()) { logger.trace(&quot;Found beans DTD [&quot; + systemId + &quot;] in classpath: &quot; + dtdFile); } return source; } catch (FileNotFoundException ex) { if (logger.isDebugEnabled()) { logger.debug(&quot;Could not resolve beans DTD [&quot; + systemId + &quot;]: not found in classpath&quot;, ex); } } } } // Fall back to the parser's default behavior. return null; } @Override public String toString() { return &quot;EntityResolver for spring-beans DTD&quot;; } } BeansDtdResolver é€»è¾‘ä¸º,ä»classpathä¸‹åŠ è½½æ–‡ä»¶åä¸ºspring-beans.dtdçš„dtdæ–‡ä»¶ 2.4 PluggableSchemaResolver public class PluggableSchemaResolver implements EntityResolver { /** * The location of the file that defines schema mappings. * Can be present in multiple JAR files. */ public static final String DEFAULT_SCHEMA_MAPPINGS_LOCATION = &quot;META-INF/spring.schemas&quot;; private static final Log logger = LogFactory.getLog(PluggableSchemaResolver.class); @Nullable private final ClassLoader classLoader; private final String schemaMappingsLocation; /** Stores the mapping of schema URL -&amp;gt; local schema path. */ @Nullable private volatile Map&amp;lt;String, String&amp;gt; schemaMappings; public PluggableSchemaResolver(@Nullable ClassLoader classLoader) { this.classLoader = classLoader; this.schemaMappingsLocation = DEFAULT_SCHEMA_MAPPINGS_LOCATION; } public PluggableSchemaResolver(@Nullable ClassLoader classLoader, String schemaMappingsLocation) { Assert.hasText(schemaMappingsLocation, &quot;'schemaMappingsLocation' must not be empty&quot;); this.classLoader = classLoader; this.schemaMappingsLocation = schemaMappingsLocation; } /*** * å…ˆæŠŠxsdæ–‡ä»¶ä¸‹è½½åˆ°æœ¬åœ°,åœ¨è¿›è¡ŒåŠ è½½ * **/ @Override @Nullable public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws IOException { if (logger.isTraceEnabled()) { logger.trace(&quot;Trying to resolve XML entity with public id [&quot; + publicId + &quot;] and system id [&quot; + systemId + &quot;]&quot;); } // systemId url ä¸èƒ½ä¸ºç©º if (systemId != null) { // ä»ç¼“å­˜ä¸­åŠ è½½xsdæ–‡ä»¶ // åˆ¤æ–­ç¼“å­˜ä¸­æ˜¯å¦æœ‰xsdæ–‡ä»¶ // ç¼“å­˜ä¸­çš„xsdæ–‡ä»¶éƒ½æ˜¯ä»ç½‘ç»œä¸­åŠ è½½ String resourceLocation = getSchemaMappings().get(systemId); if (resourceLocation == null &amp;amp;&amp;amp; systemId.startsWith(&quot;https:&quot;)) { // Retrieve canonical http schema mapping even for https declaration // å¦‚æœhttps æœªæ‰¾åˆ°çº¦æŸæ–‡ä»¶ åˆ™å°è¯•ä»http è·å–ç¼“å­˜ resourceLocation = getSchemaMappings().get(&quot;http:&quot; + systemId.substring(6)); } //å¦‚æœç¼“å­˜å‘½ä¸­ if (resourceLocation != null) { //ä»classpathè·¯å¾„ä¸­åŠ è½½xsdæ–‡ä»¶ Resource resource = new ClassPathResource(resourceLocation, this.classLoader); try { InputSource source = new InputSource(resource.getInputStream()); // è®¾ç½®publicId source.setPublicId(publicId); // è®¾ç½®systemId source.setSystemId(systemId); if (logger.isTraceEnabled()) { logger.trace(&quot;Found XML schema [&quot; + systemId + &quot;] in classpath: &quot; + resourceLocation); } return source; } catch (FileNotFoundException ex) { if (logger.isDebugEnabled()) { logger.debug(&quot;Could not find XML schema [&quot; + systemId + &quot;]: &quot; + resource, ex); } } } } // Fall back to the parser's default behavior. return null; } /** * Load the specified schema mappings lazily. */ private Map&amp;lt;String, String&amp;gt; getSchemaMappings() { Map&amp;lt;String, String&amp;gt; schemaMappings = this.schemaMappings; if (schemaMappings == null) { // å•åˆ©æ¨¡å¼ åŒæ­¥ synchronized (this) { schemaMappings = this.schemaMappings; // åŒé‡æ£€æŸ¥ if (schemaMappings == null) { if (logger.isTraceEnabled()) { logger.trace(&quot;Loading schema mappings from [&quot; + this.schemaMappingsLocation + &quot;]&quot;); } try { // åŠ è½½clsspathè·¯å¾„ä¸‹çš„ META-INF/spring.schemas Properties mappings = PropertiesLoaderUtils.loadAllProperties(this.schemaMappingsLocation, this.classLoader); if (logger.isTraceEnabled()) { logger.trace(&quot;Loaded schema mappings: &quot; + mappings); } // åˆ›å»ºçº¿ç¨‹å®‰å…¨çš„çš„hashMap schemaMappings = new ConcurrentHashMap&amp;lt;&amp;gt;(mappings.size()); // properties è½¬ hashMap CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings); // èµ‹å€¼ this.schemaMappings = schemaMappings; } catch (IOException ex) { throw new IllegalStateException( &quot;Unable to load schema mappings from location [&quot; + this.schemaMappingsLocation + &quot;]&quot;, ex); } } } } return schemaMappings; } @Override public String toString() { return &quot;EntityResolver using schema mappings &quot; + getSchemaMappings(); } } â€‹ PluggableSchemaResolverå¤§ä½“é€»è¾‘å¦‚ä¸‹: 1. å…ˆæ ¹æ®classpathè·¯å¾„ä¸‹çš„` META-INF/spring.schemas`æ–‡ä»¶åˆ›å»ºä¸€ä¸ªç¼“å­˜`schemaMappings` 2. ä»`schemaMappings`è·å–æŒ‡å®š`systemId`çš„xsdæ–‡ä»¶è·¯å¾„,å¦‚æœæœªè·å–åˆ°è¿”å›null 3. æ ¹æ®xsdè·¯å¾„åŠ è½½xsdæ–‡ä»¶è¿”å› `InputSource` å¯¹è±¡ 2.5 getValidationModeForResource() protected int getValidationModeForResource(Resource resource) { // è·å–éªŒè¯æ¨¡å¼,é»˜è®¤ä¸ºè‡ªåŠ¨ int validationModeToUse = getValidationMode(); // å¦‚æœæ‰‹åŠ¨æŒ‡å®šéªŒè¯æ¨¡å¼åˆ™ä½¿ç”¨æŒ‡å®šçš„éªŒè¯æ¨¡å¼ if (validationModeToUse != VALIDATION_AUTO) { return validationModeToUse; } // éæ‰‹åŠ¨æŒ‡å®šéªŒè¯æ¨¡å¼,è‡ªåŠ¨æ£€æµ‹éªŒè¯æ¨¡å¼ int detectedMode = detectValidationMode(resource); if (detectedMode != VALIDATION_AUTO) { return detectedMode; } // Hmm, we didn't get a clear indication... Let's assume XSD, // since apparently no DTD declaration has been found up until // detection stopped (before finding the document's root tag). // ä»¥ä¸Šéƒ½æœªè·å–éªŒè¯æ¨¡å¼,åˆ™ä½¿ç”¨xsdéªŒè¯æ¨¡å¼ return VALIDATION_XSD; } 2.6 loadDocument() @Override public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception { // è§£æxmlå¸¸ç”¨å¥—è·¯ DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware); if (logger.isTraceEnabled()) { logger.trace(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;); } // è§£æxmlå¸¸ç”¨å¥—è·¯ DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler); return builder.parse(inputSource); } /** * Create the {@link DocumentBuilderFactory} instance. * @param validationMode the type of validation: {@link XmlValidationModeDetector#VALIDATION_DTD DTD} * or {@link XmlValidationModeDetector#VALIDATION_XSD XSD}) * @param namespaceAware whether the returned factory is to provide support for XML namespaces * @return the JAXP DocumentBuilderFactory * @throws ParserConfigurationException if we failed to build a proper DocumentBuilderFactory */ protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware) throws ParserConfigurationException { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // è®¾ç½®å‘½åç©ºé—´æ”¯æŒ factory.setNamespaceAware(namespaceAware); // éç¦ç”¨éªŒè¯æ¨¡å¼ if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) { // å¼€å¯æ ¡éªŒ factory.setValidating(true); // å¦‚æœä¸ºXSD if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) { // Enforce namespace aware for XSD... // XSD æ¨¡å¼ä¸‹ï¼Œå¼ºåˆ¶è®¾ç½®å‘½åç©ºé—´æ”¯æŒ factory.setNamespaceAware(true); try { // è®¾ç½® SCHEMA_LANGUAGE_ATTRIBUTE factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE); } catch (IllegalArgumentException ex) { ParserConfigurationException pcex = new ParserConfigurationException( &quot;Unable to validate using XSD: Your JAXP provider [&quot; + factory + &quot;] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? &quot; + &quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;); pcex.initCause(ex); throw pcex; } } } return factory; } ä¸‰ã€å°ç»“ â€‹ xml åŠ è½½å¹¶åˆ›å»ºä¸º Document å¯¹è±¡,æ¥ä¸‹æ¥å°±æ˜¯ è§£æå¹¶åˆ›å»ºä¸ºbean.</summary></entry><entry><title type="html">[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-èµ„æºåŠ è½½ResourceLoader(äºŒ)</title><link href="https://onew.me/spring/2020/02/04/debug-spring-2.html" rel="alternate" type="text/html" title="[æ–­ç‚¹åˆ†æä¹‹spring-ioc]-èµ„æºåŠ è½½ResourceLoader(äºŒ)" /><published>2020-02-04T09:20:25+08:00</published><updated>2020-02-04T09:20:25+08:00</updated><id>https://onew.me/spring/2020/02/04/debug-spring-2</id><content type="html" xml:base="https://onew.me/spring/2020/02/04/debug-spring-2.html"># ä¸€ã€å‰è¨€

â€‹	èµ„æºç»Ÿä¸€æŠ½è±¡ä¸º`Resource`å¯¹è±¡.å¯æ›¾è®°å¾—åœ¨ spring é…ç½®æ–‡ä»¶ä¸­çš„è¿™ç§å†™æ³•:`classpath:com/sjr/test/bean/MyTestBean.xml`,é‚£ä¹ˆè¿™ç§å†™æ³•çš„æ„æ€æ˜¯ä»classpathè·¯å¾„ä¸‹åŠ è½½xml,é‚£ä¹ˆspringæ˜¯å¦‚ä½•å®šä½åˆ°æ–‡ä»¶çš„?

â€‹	ä¸Šé¢è¿™ç§å†™æ³•ç›¸å½“äºæ˜¯ä¸ªåè®®,åœ¨springä¸­é»˜è®¤æ”¯æŒ9ç§æ–‡ä»¶åè®®.

- URL_PROTOCOL_FILE

  ä»æ–‡ä»¶ç³»ç»Ÿä¸­åŠ è½½æ–‡ä»¶

- URL_PROTOCOL_JAR

  ä»jaråŒ…ä¸­åŠ è½½æ–‡ä»¶

- URL_PROTOCOL_WAR

  ä»waråŒ…ä¸­åŠ è½½æ–‡ä»¶

- URL_PROTOCOL_ZIP

  ä»zipä¸­åŠ è½½æ–‡ä»¶

- URL_PROTOCOL_WSJAR

  ä»wsjarä¸­åŠ è½½æ–‡ä»¶

- URL_PROTOCOL_VFSZIP

  ä»vfszipä¸­åŠ è½½æ–‡ä»¶

- URL_PROTOCOL_VFSFILE

  ä»vfsfileä¸­åŠ è½½æ–‡ä»¶

- URL_PROTOCOL_VFS

  ä»vfsä¸­åŠ è½½æ–‡ä»¶



# äºŒã€åˆ†æ

â€‹	è¿™ä¸ªæ•…äº‹è¦ä»ä¸€æ®µä»£ç å¼€å§‹

```java
@Test
	public void testSpringResourceLoader(){
		DefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader(this.getClass().getClassLoader());
		BeanFactory factory = new XmlBeanFactory(defaultResourceLoader.getResource(&quot;classpath:com/sjr/test/bean/MyTestBean.xml&quot;));
		final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);
		final String testStr = testBean.getTestStr();
		System.out.println(testStr);
	}
```

â€‹	ä¹‹å‰çš„ä»£ç ,æˆ‘ä»¬æ˜¯ç›´æ¥ä½¿ç”¨çš„`ClassPathResource`æ¥åŠ è½½æ–‡ä»¶,è¿™é‡Œä½¿ç”¨çš„`DefaultResourceLoader`å¯¹è±¡æ¥åŠ è½½æ–‡ä»¶.é‚£`DefaultResourceLoader`æœ‰ä»€ä¹ˆç”¨å¤„å‘¢?

1. è‡ªåŠ¨æ£€æµ‹æ–‡ä»¶è¯¥å¦‚ä½•åŠ è½½

 	2. ç®€åŒ–æ–‡ä»¶åŠ è½½æ“ä½œæµç¨‹

## 2.1 DefaultResourceLoader 

â€‹	`DefaultResourceLoader` æ˜¯`ResourceLoader`çš„é»˜è®¤å®ç°.

![images](https://gitee.com/oneww/onew_image/raw/master/DefaultResourceLoader.png)

ä¸Šå›¾å¯ä»¥çœ‹åˆ° `DefaultResourceLoader` è¿˜æœ‰3ä¸ªå­ç±»è¿›è¡Œäº†åŠŸèƒ½çš„æ‰©å±•.å…ˆçœ‹çœ‹`ResourceLoader`è¿™ä¸ªæ¥å£.



## 2.2 ResourceLoader

```java

public interface ResourceLoader {

	/**
	 *  classpath: å‰ç¼€å¸¸é‡
	 * */
	String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;


	/**
	 * é€šè¿‡ è·¯å¾„ è·å– Resource å¯¹è±¡
	 */
	Resource getResource(String location);

	/**
	 * è·å–ç±»åŠ è½½å™¨
	 */
	@Nullable
	ClassLoader getClassLoader();

}

```

â€‹	ä»ä»£ç å¯ä»¥çœ‹å‡º,è¯¥æ¥å£åªæœ‰2ä¸ªæ–¹æ³•,ä¸€ä¸ªæ˜¯é€šè¿‡è·¯å¾„è·å– `Resource` å¯¹è±¡,å¦å¤–ä¸€ä¸ªæ˜¯è·å–ç±»åŠ è½½å™¨.é‚£ä¹ˆåœ¨æ¥çœ‹çœ‹ `DefaultResourceLoader` çš„é»˜è®¤å®ç°ä»£ç å§.

## 2.3 DefaultResourceLoader å…·ä½“å®ç°

```java

public class DefaultResourceLoader implements ResourceLoader {

	@Nullable
	private ClassLoader classLoader;
	// åè®®è§£æå™¨ set
	private final Set&lt;ProtocolResolver&gt; protocolResolvers = new LinkedHashSet&lt;&gt;(4);
	// ç¼“å­˜
	private final Map&lt;Class&lt;?&gt;, Map&lt;Resource, ?&gt;&gt; resourceCaches = new ConcurrentHashMap&lt;&gt;(4);


	/**
	 * ä½¿ç”¨é»˜è®¤æ„é€ å™¨,é»˜è®¤æ„é€ å™¨ä¸­ä½¿ç”¨é»˜è®¤çš„ç±»åŠ è½½å™¨
	 */
	public DefaultResourceLoader() {
		this.classLoader = ClassUtils.getDefaultClassLoader();
	}

	/**
	 * ä½¿ç”¨æŒ‡å®šçš„ç±»åŠ è½½å™¨
	 */
	public DefaultResourceLoader(@Nullable ClassLoader classLoader) {
		this.classLoader = classLoader;
	}


	/**
	 * è®¾ç½®ç±»åŠ è½½å™¨
	 */
	public void setClassLoader(@Nullable ClassLoader classLoader) {
		this.classLoader = classLoader;
	}

	/**
	 * è·å–ç±»åŠ è½½å™¨
	 */
	@Override
	@Nullable
	public ClassLoader getClassLoader() {
		return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());
	}

	/**
	 * æ·»åŠ åè®®è§£æå™¨
	 */
	public void addProtocolResolver(ProtocolResolver resolver) {
		Assert.notNull(resolver, &quot;ProtocolResolver must not be null&quot;);
		this.protocolResolvers.add(resolver);
	}

	/**
	 * è·å–åè®®è§£æå™¨é›†åˆ
	 */
	public Collection&lt;ProtocolResolver&gt; getProtocolResolvers() {
		return this.protocolResolvers;
	}

	/**
	 * è·å–èµ„æºç¼“å­˜
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T&gt; Map&lt;Resource, T&gt; getResourceCache(Class&lt;T&gt; valueType) {
		return (Map&lt;Resource, T&gt;) this.resourceCaches.computeIfAbsent(valueType, key -&gt; new ConcurrentHashMap&lt;&gt;());
	}

	/**
	 * æ¸…é™¤æ‰€æœ‰èµ„æºç¼“å­˜
	 */
	public void clearResourceCaches() {
		this.resourceCaches.clear();
	}

	/**
	 * è·å–èµ„æº
	 * **/
	@Override
	public Resource getResource(String location) {
		Assert.notNull(location, &quot;Location must not be null&quot;);
		// éå†æ‰€æœ‰åè®®è§£æå™¨
		for (ProtocolResolver protocolResolver : getProtocolResolvers()) {
			// è§£æèµ„æº
			Resource resource = protocolResolver.resolve(location, this);
			// å¦‚æœèµ„æºè§£æåˆ°åˆ™è¿”å› resource å¯¹è±¡
			if (resource != null) {
				return resource;
			}
		}
		// åˆ¤æ–­æ˜¯å¦æ˜¯/å¼€å¤´
		if (location.startsWith(&quot;/&quot;)) {
			// è·å–classpathä¸Šä¸‹æ–‡ä¸­çš„èµ„æº
			return getResourceByPath(location);
		}
		// åˆ¤æ–­æ˜¯å¦æ˜¯classpath:å¼€å¤´è·¯å¾„,å¦‚æœæ˜¯åˆ™ä»classpathä¸­è·å–èµ„æº
		else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
			return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
		}
		else {
			try {
				// å°è¯•æŠŠè·¯å¾„è½¬åŒ–ä¸ºurl
				// Try to parse the location as a URL...
				URL url = new URL(location);
				// åˆ¤æ–­æ˜¯æ–‡ä»¶èµ„æº è¿˜æ˜¯urlèµ„æº
				return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));
			}
			catch (MalformedURLException ex) {
				// No URL -&gt; resolve as resource path.
				// éurl å°è¯•ä» classpath ä¸Šä¸‹æ–‡ä¸­è·å–èµ„æº
				return getResourceByPath(location);
			}
		}
	}

	/**
	 * é€šè¿‡è·¯å¾„è·å– Resource å¯¹è±¡
	 * ä» classPath ä¸­åŠ è½½æ–‡ä»¶
	 */
	protected Resource getResourceByPath(String path) {
		return new ClassPathContextResource(path, getClassLoader());
	}


	protected static class ClassPathContextResource extends ClassPathResource implements ContextResource {

		public ClassPathContextResource(String path, @Nullable ClassLoader classLoader) {
			super(path, classLoader);
		}

		@Override
		public String getPathWithinContext() {
			return getPath();
		}
		
    /**
    * åˆ›å»ºç›¸å¯¹è·¯å¾„çš„ Resource å¯¹è±¡
    */
		@Override
		public Resource createRelative(String relativePath) {
			String pathToUse = StringUtils.applyRelativePath(getPath(), relativePath);
			return new ClassPathContextResource(pathToUse, getClassLoader());
		}
	}

}

```

â€‹	ä»¥ä¸Šä»£ç çš„é€»è¾‘æ¯”è¾ƒç®€å•æ˜äº†,æ ¸å¿ƒé€»è¾‘åœ¨ `getResource` è¿™ä¸ªæ–¹æ³•ä¸­.

```java
	public Resource getResource(String location) {
		Assert.notNull(location, &quot;Location must not be null&quot;);
		// éå†æ‰€æœ‰åè®®è§£æå™¨
		for (ProtocolResolver protocolResolver : getProtocolResolvers()) {
			// è§£æèµ„æº
			Resource resource = protocolResolver.resolve(location, this);
			// å¦‚æœèµ„æºè§£æåˆ°åˆ™è¿”å› resource å¯¹è±¡
			if (resource != null) {
				return resource;
			}
		}
		// åˆ¤æ–­æ˜¯å¦æ˜¯/å¼€å¤´
		if (location.startsWith(&quot;/&quot;)) {
			// è·å–classpathä¸Šä¸‹æ–‡ä¸­çš„èµ„æº
			return getResourceByPath(location);
		}
		// åˆ¤æ–­æ˜¯å¦æ˜¯classpath:å¼€å¤´è·¯å¾„,å¦‚æœæ˜¯åˆ™ä»classpathä¸­è·å–èµ„æº
		else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
			return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
		}
		else {
			try {
				// å°è¯•æŠŠè·¯å¾„è½¬åŒ–ä¸ºurl
				// Try to parse the location as a URL...
				URL url = new URL(location);
				// åˆ¤æ–­æ˜¯æ–‡ä»¶èµ„æº è¿˜æ˜¯urlèµ„æº
				return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));
			}
			catch (MalformedURLException ex) {
				// No URL -&gt; resolve as resource path.
				// éurl å°è¯•ä» classpath ä¸Šä¸‹æ–‡ä¸­è·å–èµ„æº
				return getResourceByPath(location);
			}
		}
	}
```

â€‹	é€»è¾‘æµç¨‹ä¸ºä»¥ä¸‹å‡ æ­¥:

  1. åˆ¤æ–­æ˜¯å¦è®¾ç½®äº† åè®®è§£æå™¨,å¦‚æœè®¾ç½®äº†,åˆ™éå†æ‰€æœ‰çš„åè®®è§£æ,

     å¹¶è§£ææ–‡ä»¶,å¦‚æœè§£ææˆåŠŸåˆ™è¿”å› Resource å¯¹è±¡å¦åˆ™æ‰§è¡Œç¬¬äºŒæ­¥.

		2. åˆ¤æ–­è·¯å¾„æ˜¯å¦æ˜¯ `/ ` å¼€å¤´,è‹¥æ˜¯åˆ™ä»classPath åŠ è½½æ–‡ä»¶,è°ƒç”¨ 

     `getResourceByPath`æ–¹æ³•,è¿”å› `Resource` å¯¹è±¡

		3. åˆ¤æ–­æ˜¯å¦æ˜¯ `classpath:` å¼€å¤´,è‹¥æ˜¯åˆ™ä» classPath åŠ è½½æ–‡ä»¶
		
		4. è‹¥æ˜¯ä»¥ä¸Šå‡ æ­¥éƒ½å¤±è´¥,åˆ™å°è¯•æŠŠè·¯å¾„è½¬ä¸ºURL,å¦‚æœæˆåŠŸåˆ™è¿”å›

     `FileUrlResource` æˆ– `UrlResource` å¯¹è±¡

		5. æœ€åæŒ£æ‰ä»¥ä¸‹,ä»classPath åŠ è½½æ–‡ä»¶



## 2.4 FileUrlResource

â€‹	å¼€ç¯‡è¯´é“ spring é»˜è®¤æ”¯æŒ 9ä¸­åè®®(å¦‚æœæŠŠ classPath ä¹Ÿç®—ä¸Šçš„è¯),é‚£ä¹ˆé™¤äº† å¸¸ç”¨çš„ classPath ä»¥å¤–,å…¶ä»–çš„æ€ä¹ˆä½¿ç”¨å‘¢?å…¶ä»–çš„ç¬”è€…æœ¬äººéƒ½æ²¡ç”¨è¿‡å¤šå°‘,å°±æ¥çœ‹çœ‹ file åè®®å§.

```java

	@Test
	public void testSpringResourceLoaderForFileProtocol(){
		DefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader(this.getClass().getClassLoader());
		BeanFactory factory = new XmlBeanFactory(defaultResourceLoader.getResource(&quot;file:///src/test/resources/com/sjr/test/bean/MyTestBean.xml&quot;));
		final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);
		final String testStr = testBean.getTestStr();
		System.out.println(testStr);
	}
```

â€‹	ç›¸å½“äºæ˜¯ä¸ªç»å¯¹è·¯å¾„äº†.å…¶ä»–åè®®å¯ä»¥æŸ¥æŸ¥èµ„æ–™.



# ä¸‰ã€è‡ªå®šä¹‰æ–‡ä»¶åè®®è§£æå™¨

â€‹	åœ¨`DefaultResourceLoader` ä¸­çš„æ ¸å¿ƒä»£ç ä¸­æœ‰æ®µéå†è§£æå™¨çš„ä»£ç ,æ¥ç§ç§.

```java
		// éå†æ‰€æœ‰åè®®è§£æå™¨
		for (ProtocolResolver protocolResolver : getProtocolResolvers()) {
			// è§£æèµ„æº
			Resource resource = protocolResolver.resolve(location, this);
			// å¦‚æœèµ„æºè§£æåˆ°åˆ™è¿”å› resource å¯¹è±¡
			if (resource != null) {
				return resource;
			}
		}
```

â€‹	é€šè¿‡è¿™æ®µä»£ç ,å¯ä»¥å®ç°è‡ªå®šä¹‰æ–‡ä»¶åè®®è§£æå™¨çš„é€»è¾‘,æ–¹ä¾¿æ‰©å±•.`ProtocolResolver`æ˜¯ä¸ªæ¥å£,é‡Œé¢å°±ä¸€ä¸ªæ–¹æ³•,éå¸¸ç®€å•.

```java
@FunctionalInterface
public interface ProtocolResolver {

	/**
	 * è§£æ
	 */
	@Nullable
	Resource resolve(String location, ResourceLoader resourceLoader);

}

```

â€‹	è¯¥æ¥å£ä¹Ÿæ˜¯ä¸ªå‡½æ•°æ¥å£(å¯ä»¥ä½¿ç”¨Lambdaè¡¨è¾¾å¼).æ¥å®ç°ä¸€ä¸ªåè®®è¯•ä¸€è¯•.

```java
// å®ç°ProtocolResolver æ¥å£ è‡ªå®šä¹‰è§£æé€»è¾‘
public class SjrProtocolResolver implements ProtocolResolver {

	@Override
	public Resource resolve(String location, ResourceLoader resourceLoader) {
		if(resourceLoader == null){
			return null;
		}
		if(location == null || !location.startsWith(&quot;sjr&quot;)){
			return null;
		}
		final int index = location.indexOf(&quot;sjr:&quot;);
		return resourceLoader.getResource(location.substring(index + 4));
	}
}
```

```java
@Test
	public void testSpringProtocolResolverOfAdv(){
		DefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader(this.getClass().getClassLoader());
		defaultResourceLoader.addProtocolResolver(new SjrProtocolResolver());
		BeanFactory factory = new XmlBeanFactory(defaultResourceLoader.getResource(&quot;sjr:com/sjr/test/bean/MyTestBean.xml&quot;));
		final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);
		final String testStr = testBean.getTestStr();
		System.out.println(testStr);
	}
```

â€‹	è¿™æ ·å°±å®Œæˆäº†è‡ªå®šä¹‰åè®®çš„è§£æ.

â€‹	`DefaultResourceLoader` è¿˜æœ‰ä¸‰ä¸ªå­ç±»:

- ServletContextResourceLoader

  è¿”å›`ServletContextResource`,ä»`ServletContext`è·å–èµ„æº.

- FileSystemResourceLoader

  è¿”å›`FileSystemContextResource` ,ä»æ–‡ä»¶ç³»ç»Ÿä¸­è·å–èµ„æº,

   å…¶æœ¬è´¨ä¸Šæ˜¯`FileSystemResource`,å®ç°äº†`ContextResource`æ¥å£

- ClassRelativeResourceLoader

  è¿”å›`ClassRelativeContextResource` ,ä»classPathè·å–èµ„æº,

  å…¶æœ¬è´¨ä¸Šæ˜¯`ClassPathResource`,å®ç°äº†`ContextResource`æ¥å£

  è¿™ä¸‰ä¸ªå­ç±»,éƒ½æ˜¯åšçš„ç®€å•æ‰©å±•,é€»è¾‘ç®€å•,æœ‰å…´è¶£å¯ä»¥å»çœ‹çœ‹.



# å››ã€å°ç»“

â€‹	æ–‡ä»¶æ˜¯åŠ è½½åˆ°,é‚£ä¹ˆspring æ˜¯æ€ä¹ˆè§£æxmlæ–‡ä»¶çš„å‘¢?</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">ä¸€ã€å‰è¨€ â€‹ èµ„æºç»Ÿä¸€æŠ½è±¡ä¸ºResourceå¯¹è±¡.å¯æ›¾è®°å¾—åœ¨ spring é…ç½®æ–‡ä»¶ä¸­çš„è¿™ç§å†™æ³•:classpath:com/sjr/test/bean/MyTestBean.xml,é‚£ä¹ˆè¿™ç§å†™æ³•çš„æ„æ€æ˜¯ä»classpathè·¯å¾„ä¸‹åŠ è½½xml,é‚£ä¹ˆspringæ˜¯å¦‚ä½•å®šä½åˆ°æ–‡ä»¶çš„? â€‹ ä¸Šé¢è¿™ç§å†™æ³•ç›¸å½“äºæ˜¯ä¸ªåè®®,åœ¨springä¸­é»˜è®¤æ”¯æŒ9ç§æ–‡ä»¶åè®®. URL_PROTOCOL_FILE ä»æ–‡ä»¶ç³»ç»Ÿä¸­åŠ è½½æ–‡ä»¶ URL_PROTOCOL_JAR ä»jaråŒ…ä¸­åŠ è½½æ–‡ä»¶ URL_PROTOCOL_WAR ä»waråŒ…ä¸­åŠ è½½æ–‡ä»¶ URL_PROTOCOL_ZIP ä»zipä¸­åŠ è½½æ–‡ä»¶ URL_PROTOCOL_WSJAR ä»wsjarä¸­åŠ è½½æ–‡ä»¶ URL_PROTOCOL_VFSZIP ä»vfszipä¸­åŠ è½½æ–‡ä»¶ URL_PROTOCOL_VFSFILE ä»vfsfileä¸­åŠ è½½æ–‡ä»¶ URL_PROTOCOL_VFS ä»vfsä¸­åŠ è½½æ–‡ä»¶ äºŒã€åˆ†æ â€‹ è¿™ä¸ªæ•…äº‹è¦ä»ä¸€æ®µä»£ç å¼€å§‹ @Test public void testSpringResourceLoader(){ DefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader(this.getClass().getClassLoader()); BeanFactory factory = new XmlBeanFactory(defaultResourceLoader.getResource(&quot;classpath:com/sjr/test/bean/MyTestBean.xml&quot;)); final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class); final String testStr = testBean.getTestStr(); System.out.println(testStr); } â€‹ ä¹‹å‰çš„ä»£ç ,æˆ‘ä»¬æ˜¯ç›´æ¥ä½¿ç”¨çš„ClassPathResourceæ¥åŠ è½½æ–‡ä»¶,è¿™é‡Œä½¿ç”¨çš„DefaultResourceLoaderå¯¹è±¡æ¥åŠ è½½æ–‡ä»¶.é‚£DefaultResourceLoaderæœ‰ä»€ä¹ˆç”¨å¤„å‘¢? è‡ªåŠ¨æ£€æµ‹æ–‡ä»¶è¯¥å¦‚ä½•åŠ è½½ 2. ç®€åŒ–æ–‡ä»¶åŠ è½½æ“ä½œæµç¨‹ 2.1 DefaultResourceLoader â€‹ DefaultResourceLoader æ˜¯ResourceLoaderçš„é»˜è®¤å®ç°. ä¸Šå›¾å¯ä»¥çœ‹åˆ° DefaultResourceLoader è¿˜æœ‰3ä¸ªå­ç±»è¿›è¡Œäº†åŠŸèƒ½çš„æ‰©å±•.å…ˆçœ‹çœ‹ResourceLoaderè¿™ä¸ªæ¥å£. 2.2 ResourceLoader public interface ResourceLoader { /** * classpath: å‰ç¼€å¸¸é‡ * */ String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX; /** * é€šè¿‡ è·¯å¾„ è·å– Resource å¯¹è±¡ */ Resource getResource(String location); /** * è·å–ç±»åŠ è½½å™¨ */ @Nullable ClassLoader getClassLoader(); } â€‹ ä»ä»£ç å¯ä»¥çœ‹å‡º,è¯¥æ¥å£åªæœ‰2ä¸ªæ–¹æ³•,ä¸€ä¸ªæ˜¯é€šè¿‡è·¯å¾„è·å– Resource å¯¹è±¡,å¦å¤–ä¸€ä¸ªæ˜¯è·å–ç±»åŠ è½½å™¨.é‚£ä¹ˆåœ¨æ¥çœ‹çœ‹ DefaultResourceLoader çš„é»˜è®¤å®ç°ä»£ç å§. 2.3 DefaultResourceLoader å…·ä½“å®ç° public class DefaultResourceLoader implements ResourceLoader { @Nullable private ClassLoader classLoader; // åè®®è§£æå™¨ set private final Set&amp;lt;ProtocolResolver&amp;gt; protocolResolvers = new LinkedHashSet&amp;lt;&amp;gt;(4); // ç¼“å­˜ private final Map&amp;lt;Class&amp;lt;?&amp;gt;, Map&amp;lt;Resource, ?&amp;gt;&amp;gt; resourceCaches = new ConcurrentHashMap&amp;lt;&amp;gt;(4); /** * ä½¿ç”¨é»˜è®¤æ„é€ å™¨,é»˜è®¤æ„é€ å™¨ä¸­ä½¿ç”¨é»˜è®¤çš„ç±»åŠ è½½å™¨ */ public DefaultResourceLoader() { this.classLoader = ClassUtils.getDefaultClassLoader(); } /** * ä½¿ç”¨æŒ‡å®šçš„ç±»åŠ è½½å™¨ */ public DefaultResourceLoader(@Nullable ClassLoader classLoader) { this.classLoader = classLoader; } /** * è®¾ç½®ç±»åŠ è½½å™¨ */ public void setClassLoader(@Nullable ClassLoader classLoader) { this.classLoader = classLoader; } /** * è·å–ç±»åŠ è½½å™¨ */ @Override @Nullable public ClassLoader getClassLoader() { return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader()); } /** * æ·»åŠ åè®®è§£æå™¨ */ public void addProtocolResolver(ProtocolResolver resolver) { Assert.notNull(resolver, &quot;ProtocolResolver must not be null&quot;); this.protocolResolvers.add(resolver); } /** * è·å–åè®®è§£æå™¨é›†åˆ */ public Collection&amp;lt;ProtocolResolver&amp;gt; getProtocolResolvers() { return this.protocolResolvers; } /** * è·å–èµ„æºç¼“å­˜ */ @SuppressWarnings(&quot;unchecked&quot;) public &amp;lt;T&amp;gt; Map&amp;lt;Resource, T&amp;gt; getResourceCache(Class&amp;lt;T&amp;gt; valueType) { return (Map&amp;lt;Resource, T&amp;gt;) this.resourceCaches.computeIfAbsent(valueType, key -&amp;gt; new ConcurrentHashMap&amp;lt;&amp;gt;()); } /** * æ¸…é™¤æ‰€æœ‰èµ„æºç¼“å­˜ */ public void clearResourceCaches() { this.resourceCaches.clear(); } /** * è·å–èµ„æº * **/ @Override public Resource getResource(String location) { Assert.notNull(location, &quot;Location must not be null&quot;); // éå†æ‰€æœ‰åè®®è§£æå™¨ for (ProtocolResolver protocolResolver : getProtocolResolvers()) { // è§£æèµ„æº Resource resource = protocolResolver.resolve(location, this); // å¦‚æœèµ„æºè§£æåˆ°åˆ™è¿”å› resource å¯¹è±¡ if (resource != null) { return resource; } } // åˆ¤æ–­æ˜¯å¦æ˜¯/å¼€å¤´ if (location.startsWith(&quot;/&quot;)) { // è·å–classpathä¸Šä¸‹æ–‡ä¸­çš„èµ„æº return getResourceByPath(location); } // åˆ¤æ–­æ˜¯å¦æ˜¯classpath:å¼€å¤´è·¯å¾„,å¦‚æœæ˜¯åˆ™ä»classpathä¸­è·å–èµ„æº else if (location.startsWith(CLASSPATH_URL_PREFIX)) { return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); } else { try { // å°è¯•æŠŠè·¯å¾„è½¬åŒ–ä¸ºurl // Try to parse the location as a URL... URL url = new URL(location); // åˆ¤æ–­æ˜¯æ–‡ä»¶èµ„æº è¿˜æ˜¯urlèµ„æº return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url)); } catch (MalformedURLException ex) { // No URL -&amp;gt; resolve as resource path. // éurl å°è¯•ä» classpath ä¸Šä¸‹æ–‡ä¸­è·å–èµ„æº return getResourceByPath(location); } } } /** * é€šè¿‡è·¯å¾„è·å– Resource å¯¹è±¡ * ä» classPath ä¸­åŠ è½½æ–‡ä»¶ */ protected Resource getResourceByPath(String path) { return new ClassPathContextResource(path, getClassLoader()); } protected static class ClassPathContextResource extends ClassPathResource implements ContextResource { public ClassPathContextResource(String path, @Nullable ClassLoader classLoader) { super(path, classLoader); } @Override public String getPathWithinContext() { return getPath(); } /** * åˆ›å»ºç›¸å¯¹è·¯å¾„çš„ Resource å¯¹è±¡ */ @Override public Resource createRelative(String relativePath) { String pathToUse = StringUtils.applyRelativePath(getPath(), relativePath); return new ClassPathContextResource(pathToUse, getClassLoader()); } } } â€‹ ä»¥ä¸Šä»£ç çš„é€»è¾‘æ¯”è¾ƒç®€å•æ˜äº†,æ ¸å¿ƒé€»è¾‘åœ¨ getResource è¿™ä¸ªæ–¹æ³•ä¸­. public Resource getResource(String location) { Assert.notNull(location, &quot;Location must not be null&quot;); // éå†æ‰€æœ‰åè®®è§£æå™¨ for (ProtocolResolver protocolResolver : getProtocolResolvers()) { // è§£æèµ„æº Resource resource = protocolResolver.resolve(location, this); // å¦‚æœèµ„æºè§£æåˆ°åˆ™è¿”å› resource å¯¹è±¡ if (resource != null) { return resource; } } // åˆ¤æ–­æ˜¯å¦æ˜¯/å¼€å¤´ if (location.startsWith(&quot;/&quot;)) { // è·å–classpathä¸Šä¸‹æ–‡ä¸­çš„èµ„æº return getResourceByPath(location); } // åˆ¤æ–­æ˜¯å¦æ˜¯classpath:å¼€å¤´è·¯å¾„,å¦‚æœæ˜¯åˆ™ä»classpathä¸­è·å–èµ„æº else if (location.startsWith(CLASSPATH_URL_PREFIX)) { return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); } else { try { // å°è¯•æŠŠè·¯å¾„è½¬åŒ–ä¸ºurl // Try to parse the location as a URL... URL url = new URL(location); // åˆ¤æ–­æ˜¯æ–‡ä»¶èµ„æº è¿˜æ˜¯urlèµ„æº return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url)); } catch (MalformedURLException ex) { // No URL -&amp;gt; resolve as resource path. // éurl å°è¯•ä» classpath ä¸Šä¸‹æ–‡ä¸­è·å–èµ„æº return getResourceByPath(location); } } } â€‹ é€»è¾‘æµç¨‹ä¸ºä»¥ä¸‹å‡ æ­¥: åˆ¤æ–­æ˜¯å¦è®¾ç½®äº† åè®®è§£æå™¨,å¦‚æœè®¾ç½®äº†,åˆ™éå†æ‰€æœ‰çš„åè®®è§£æ, å¹¶è§£ææ–‡ä»¶,å¦‚æœè§£ææˆåŠŸåˆ™è¿”å› Resource å¯¹è±¡å¦åˆ™æ‰§è¡Œç¬¬äºŒæ­¥. åˆ¤æ–­è·¯å¾„æ˜¯å¦æ˜¯ / å¼€å¤´,è‹¥æ˜¯åˆ™ä»classPath åŠ è½½æ–‡ä»¶,è°ƒç”¨ getResourceByPathæ–¹æ³•,è¿”å› Resource å¯¹è±¡ åˆ¤æ–­æ˜¯å¦æ˜¯ classpath: å¼€å¤´,è‹¥æ˜¯åˆ™ä» classPath åŠ è½½æ–‡ä»¶ è‹¥æ˜¯ä»¥ä¸Šå‡ æ­¥éƒ½å¤±è´¥,åˆ™å°è¯•æŠŠè·¯å¾„è½¬ä¸ºURL,å¦‚æœæˆåŠŸåˆ™è¿”å› FileUrlResource æˆ– UrlResource å¯¹è±¡ æœ€åæŒ£æ‰ä»¥ä¸‹,ä»classPath åŠ è½½æ–‡ä»¶ 2.4 FileUrlResource â€‹ å¼€ç¯‡è¯´é“ spring é»˜è®¤æ”¯æŒ 9ä¸­åè®®(å¦‚æœæŠŠ classPath ä¹Ÿç®—ä¸Šçš„è¯),é‚£ä¹ˆé™¤äº† å¸¸ç”¨çš„ classPath ä»¥å¤–,å…¶ä»–çš„æ€ä¹ˆä½¿ç”¨å‘¢?å…¶ä»–çš„ç¬”è€…æœ¬äººéƒ½æ²¡ç”¨è¿‡å¤šå°‘,å°±æ¥çœ‹çœ‹ file åè®®å§. @Test public void testSpringResourceLoaderForFileProtocol(){ DefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader(this.getClass().getClassLoader()); BeanFactory factory = new XmlBeanFactory(defaultResourceLoader.getResource(&quot;file:///src/test/resources/com/sjr/test/bean/MyTestBean.xml&quot;)); final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class); final String testStr = testBean.getTestStr(); System.out.println(testStr); } â€‹ ç›¸å½“äºæ˜¯ä¸ªç»å¯¹è·¯å¾„äº†.å…¶ä»–åè®®å¯ä»¥æŸ¥æŸ¥èµ„æ–™. ä¸‰ã€è‡ªå®šä¹‰æ–‡ä»¶åè®®è§£æå™¨ â€‹ åœ¨DefaultResourceLoader ä¸­çš„æ ¸å¿ƒä»£ç ä¸­æœ‰æ®µéå†è§£æå™¨çš„ä»£ç ,æ¥ç§ç§. // éå†æ‰€æœ‰åè®®è§£æå™¨ for (ProtocolResolver protocolResolver : getProtocolResolvers()) { // è§£æèµ„æº Resource resource = protocolResolver.resolve(location, this); // å¦‚æœèµ„æºè§£æåˆ°åˆ™è¿”å› resource å¯¹è±¡ if (resource != null) { return resource; } } â€‹ é€šè¿‡è¿™æ®µä»£ç ,å¯ä»¥å®ç°è‡ªå®šä¹‰æ–‡ä»¶åè®®è§£æå™¨çš„é€»è¾‘,æ–¹ä¾¿æ‰©å±•.ProtocolResolveræ˜¯ä¸ªæ¥å£,é‡Œé¢å°±ä¸€ä¸ªæ–¹æ³•,éå¸¸ç®€å•. @FunctionalInterface public interface ProtocolResolver { /** * è§£æ */ @Nullable Resource resolve(String location, ResourceLoader resourceLoader); } â€‹ è¯¥æ¥å£ä¹Ÿæ˜¯ä¸ªå‡½æ•°æ¥å£(å¯ä»¥ä½¿ç”¨Lambdaè¡¨è¾¾å¼).æ¥å®ç°ä¸€ä¸ªåè®®è¯•ä¸€è¯•. // å®ç°ProtocolResolver æ¥å£ è‡ªå®šä¹‰è§£æé€»è¾‘ public class SjrProtocolResolver implements ProtocolResolver { @Override public Resource resolve(String location, ResourceLoader resourceLoader) { if(resourceLoader == null){ return null; } if(location == null || !location.startsWith(&quot;sjr&quot;)){ return null; } final int index = location.indexOf(&quot;sjr:&quot;); return resourceLoader.getResource(location.substring(index + 4)); } } @Test public void testSpringProtocolResolverOfAdv(){ DefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader(this.getClass().getClassLoader()); defaultResourceLoader.addProtocolResolver(new SjrProtocolResolver()); BeanFactory factory = new XmlBeanFactory(defaultResourceLoader.getResource(&quot;sjr:com/sjr/test/bean/MyTestBean.xml&quot;)); final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class); final String testStr = testBean.getTestStr(); System.out.println(testStr); } â€‹ è¿™æ ·å°±å®Œæˆäº†è‡ªå®šä¹‰åè®®çš„è§£æ. â€‹ DefaultResourceLoader è¿˜æœ‰ä¸‰ä¸ªå­ç±»: ServletContextResourceLoader è¿”å›ServletContextResource,ä»ServletContextè·å–èµ„æº. FileSystemResourceLoader è¿”å›FileSystemContextResource ,ä»æ–‡ä»¶ç³»ç»Ÿä¸­è·å–èµ„æº, å…¶æœ¬è´¨ä¸Šæ˜¯FileSystemResource,å®ç°äº†ContextResourceæ¥å£ ClassRelativeResourceLoader è¿”å›ClassRelativeContextResource ,ä»classPathè·å–èµ„æº, å…¶æœ¬è´¨ä¸Šæ˜¯ClassPathResource,å®ç°äº†ContextResourceæ¥å£ è¿™ä¸‰ä¸ªå­ç±»,éƒ½æ˜¯åšçš„ç®€å•æ‰©å±•,é€»è¾‘ç®€å•,æœ‰å…´è¶£å¯ä»¥å»çœ‹çœ‹. å››ã€å°ç»“ â€‹ æ–‡ä»¶æ˜¯åŠ è½½åˆ°,é‚£ä¹ˆspring æ˜¯æ€ä¹ˆè§£æxmlæ–‡ä»¶çš„å‘¢?</summary></entry></feed>