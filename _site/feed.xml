<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://onew.me/feed.xml" rel="self" type="application/atom+xml" /><link href="https://onew.me/" rel="alternate" type="text/html" hreflang="zh" /><updated>2021-01-19T22:30:22+08:00</updated><id>https://onew.me/feed.xml</id><title type="html">一水开发笔记</title><subtitle>java,多线程,jvm,redis,redisdesktopmanager,postgresql
</subtitle><author><name>onew</name><email>admin@onew.me</email></author><entry><title type="html">WebLogic Metaspace OOM 解决案例</title><link href="https://onew.me/java/2021/01/19/Weblogic-Metaspace-OOM.html" rel="alternate" type="text/html" title="WebLogic Metaspace OOM 解决案例" /><published>2021-01-19T22:01:25+08:00</published><updated>2021-01-19T22:01:25+08:00</updated><id>https://onew.me/java/2021/01/19/Weblogic-Metaspace-OOM</id><content type="html" xml:base="https://onew.me/java/2021/01/19/Weblogic-Metaspace-OOM.html">&lt;h1 id=&quot;weblogic-metaspace-oom-解决案例&quot;&gt;WebLogic Metaspace OOM 解决案例&lt;/h1&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;​	估计也只有我这么惨了，都0202年了还在用weblogic这种上古神器。故事要从前段时间说起,至于是多久时间，我也忘记了。&lt;/p&gt;

&lt;p&gt;​	某日，线上发布版本,在weblogic控制台更新的时候,直接卡死无响应。一打开日志一瞧，好家伙，OOM了，还是个metaspace的OOM。&lt;/p&gt;

&lt;p&gt;​	这玩意儿就有点奇怪了，metaspace按道理是存放的类信息，字面量（Literal）、类静态变量（Class Static）、符号引用（Symbols Reference）等相关信息。类相关信息在metaspace里面又分为2块区域,&lt;strong&gt;Klass MetaSpace&lt;/strong&gt;和&lt;strong&gt;NoKlass MetaSpace&lt;/strong&gt;。这就不细讲了，不然扯不完。&lt;/p&gt;

&lt;p&gt;​	也就说一般情况下这玩意儿是不会OOM掉的（除开metaspace大小设置不合理的情况）&lt;/p&gt;

&lt;h2 id=&quot;二分析&quot;&gt;二、分析&lt;/h2&gt;

&lt;p&gt;​	结合实际情况Metaspace OOM 可能的情况是，以下2种情况：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 大量使用反射，由于JVM的优化机制，会定义一些类出来，导致类加载数量增多。
- JAXB BUG 导致，网上有很多文章在分析
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;21-情况一&quot;&gt;2.1 情况一：&lt;/h3&gt;

&lt;p&gt;​	的确项目里面存在大量的反射，再说了使用了spring 框架，反射是避免不了的，这个没办法。但是这种情况说不通，就算类大量的增长，但从未见过有卸载类的情况。排除～！&lt;/p&gt;

&lt;h3 id=&quot;22-情况二&quot;&gt;2.2 情况二：&lt;/h3&gt;

&lt;p&gt;​	JAXB 这个情况的确可能存在，毕竟是老项目，但这个没有实际的证据，需要进一步的进行分析。&lt;/p&gt;

&lt;h3 id=&quot;23-什么时候卸载类&quot;&gt;2.3 什么时候卸载类？&lt;/h3&gt;

&lt;p&gt;​	卸载类要满足3个条件，GC才会对其进行卸载，并回收空间：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 该类所有的实例已经被回收
- 加载该类的CLassLoader已经被回收
- 该类对应的CLass对象没有任何引用
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;看得出，卸载一个类条件比较苛刻，那就按照上述3个条件进行问题排查。&lt;/p&gt;

&lt;h2 id=&quot;三排查&quot;&gt;三、排查&lt;/h2&gt;

&lt;h3 id=&quot;31-复现&quot;&gt;3.1 复现&lt;/h3&gt;

&lt;p&gt;​	解决问题的前提是能够复现问题，好在这次问题比较容易复现出来。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;环境：
	- weblogic 12c
    &lt;ul&gt;
      &lt;li&gt;jdk 1.8&lt;/li&gt;
      &lt;li&gt;metaspace 512M maxMetaspace1024M&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;步骤：
    &lt;ul&gt;
      &lt;li&gt;在控制台中使用更新功能，重复部署多次&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;观察：
    &lt;ul&gt;
      &lt;li&gt;使用jdk自带&lt;em&gt;Java VisualVM&lt;/em&gt;，观察metaspace内存的增长，以及一个class的加载数量和卸载数量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;现象：
    &lt;ul&gt;
      &lt;li&gt;class一直在增长，没有出现过大幅度的下跌&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/6I8w1m7fhSo9Grx.png&quot; alt=&quot;6I8w1m7fhSo9Grx&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;总共更新了2次载入了7W+的类，卸载却不到3K，这个结果就离谱。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;32-内存分析&quot;&gt;3.2 内存分析&lt;/h3&gt;

&lt;p&gt;​	把heap dump下来，看看。到底是啥导致没有卸载。前文说了，卸载一个类要满足3个条件。那就按照3个条件进行分析。&lt;/p&gt;

&lt;p&gt;​	但加载类是在太多，不可能一个一个的去分析。从3个条件来看，分析classloader是最靠谱的，毕竟所有类的加载都是由classloader进行加载的，而且classloader数量相对较少。&lt;/p&gt;

&lt;p&gt;​	通过mat分析，检测出有3个问题,2个都是ChangeAwareCloader：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/Mwg4flXxK9pU5HL.png&quot; alt=&quot;Mwg4flXxK9pU5HL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看来方向没错，去weblogic官方看了一下，上图中的classloader是负责更新class的。点开详情看一下，发现是nacos的线程hold住了classloader导致，嘿嘿破案了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/wOGNxqotD6rgu18.png&quot; alt=&quot;wOGNxqotD6rgu18&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;33-这该死的线程&quot;&gt;3.3 这该死的线程&lt;/h3&gt;

&lt;p&gt;​	通过上面的分析，发现是nacos在spring停止的时候并没有停止相关线程，导致该线程一直在后台活跃。由于线程没有退出，那么相应的classloader就不能被回收。&lt;/p&gt;

&lt;p&gt;​	我TM反手一个&lt;a href=&quot;https://github.com/alibaba/spring-cloud-alibaba/pull/1892&quot;&gt;pr&lt;/a&gt;到nacos。&lt;/p&gt;

&lt;h3 id=&quot;34-验证&quot;&gt;3.4 验证&lt;/h3&gt;

&lt;p&gt;​	问题原因找到了，就替换掉原由项目的nacos，换上一个停止spring的时候销毁nacos线程版本，验证一下是否解决。&lt;/p&gt;

&lt;p&gt;​	由于是线程引起的，所以在验证的过程中，要格外注意，nacos线程是否被正常关闭。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/7Csbdgv84VhxZwt.jpg&quot; alt=&quot;7Csbdgv84VhxZwt&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图为weblogic一个线程截图。可以看到nacos相关的线程有6个。此时停止应用，nacos线程已经被正常的销毁了。&lt;/p&gt;

&lt;p&gt;​	线程已经被正常销毁，再来验证是否能够正常卸载class。重复部署2次，再进行观察。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/8WXGmiIpM2fdDaK.png&quot; alt=&quot;8WXGmiIpM2fdDaK&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​	还是离谱，依旧没有被卸载，看来问题没有被根本解决。会不会是还有啥线程没有被关闭呢。再去找找看看。先停止应用，看看哪些线程还在后台运行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/V1Za2sfGzMFmyx7.jpg&quot; alt=&quot;V1Za2sfGzMFmyx7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;扒了一下，还有一个线程没有正常销毁。改改代码再试一下吧0.0.&lt;/p&gt;

&lt;h3 id=&quot;35-还是这该死的线程&quot;&gt;3.5 还是这该死的线程&lt;/h3&gt;

&lt;p&gt;​	虽然把nacos的线程给销毁了，但还有业务线程还在跑，再测试一把，看看能不能正常的回收class。经过测试没有出现可以的线程了。感觉自己又行了。&lt;/p&gt;

&lt;p&gt;​	继续测试，重复部署，验证是否能够正常卸载class。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/EhGkgSMz71sbZeC.png&quot; alt=&quot;EhGkgSMz71sbZeC&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还是离谱，加载了7W多的类，卸载才4K多点，这还是不正常。果然，这个工程的问题很多呀。&lt;/p&gt;

&lt;h3 id=&quot;36-重新分析内存讨厌的监控&quot;&gt;3.6 重新分析内存,讨厌的监控&lt;/h3&gt;

&lt;p&gt;​	线程的问题解决了，但问题依旧，只能再dump一份内存看看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/u6wdjzoRpvADNYT.png&quot; alt=&quot;u6wdjzoRpvADNYT&quot; /&gt;&lt;/p&gt;

&lt;p&gt;问题还是在classLoader上，去详情看看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/YPCexIzNHrbq3Ud.png&quot; alt=&quot;YPCexIzNHrbq3Ud&quot; /&gt;&lt;/p&gt;

&lt;p&gt;classloader被Logger给hold住了，这有点奇怪了。由上图可以看出，changeAwareClassLoader加载了LoggingHandler，在Logger中引用了LoggingHandler，这个Logger是系统类，&lt;/p&gt;

&lt;p&gt;​	由于Logger是系统类，由jvm的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bootstrap ClassLoader&lt;/code&gt;加载，这个classloader的生命周期就很长了，只有jvm进程退出，才会被销毁掉。&lt;/p&gt;

&lt;p&gt;​	只能翻一下LoggingHandler的代码，看下为啥要去跟Logger扯上关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/DNiQLXeBqAIna6K.png&quot; alt=&quot;DNiQLXeBqAIna6K&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个玩意儿在启动的时候回去注册一下，获取的是系统的Logger，怪不得会扯上关系。不知道为啥没有被取消注册，取消注册的方法倒是有个。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/Erv2pmXdNyPRlGq.png&quot; alt=&quot;Erv2pmXdNyPRlGq&quot; /&gt;&lt;/p&gt;

&lt;p&gt;猜测是jar包版本冲突导致出现了异常，就没有把取消注册流程给走完。问了一下同事，说这个LoggingHandler是属于一个监控，这个监控比较老，可以直接下掉。那就不去纠结为啥没有取消注册了，直接下掉看疗效。&lt;/p&gt;

&lt;h3 id=&quot;37-重新验证&quot;&gt;3.7 重新验证&lt;/h3&gt;

&lt;p&gt;​	把监控的jar包下掉，看看能不能达到预期的效果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/ZhkNoL9AjsxR5dn.png&quot; alt=&quot;ZhkNoL9AjsxR5dn&quot; /&gt;&lt;/p&gt;

&lt;p&gt;weblogic初始状态，一片祥和。&lt;/p&gt;

&lt;p&gt;重复部署3次：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/seum7EkIF83Qb1i.png&quot; alt=&quot;seum7EkIF83Qb1i&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还是没卸载，离谱，看来要翻车了。不急陪他耍耍，等他个10分钟，看他自己投降。是不是觉得是玄学😂。对，还真不是玄学，有些东西没有及时释放，是因为在finalize队列中排队呢，等一下就好。&lt;/p&gt;

&lt;p&gt;10分钟之后，不对应该是出去吃饭过后：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/19/5ybVJMqUr3I1WjR.png&quot; alt=&quot;5ybVJMqUr3I1WjR&quot; /&gt;&lt;/p&gt;

&lt;p&gt;metaspace的占用水平已回归到正常的水平，类卸载从4000到了28000。&lt;/p&gt;

&lt;p&gt;反复部署后，metaspace内存也稳定到600M。ok，完美解决。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="java" /><category term="java" /><category term="Weblogic" /><category term="metaspace oom" /><summary type="html">WebLogic Metaspace OOM 解决案例 一、前言 ​ 估计也只有我这么惨了，都0202年了还在用weblogic这种上古神器。故事要从前段时间说起,至于是多久时间，我也忘记了。 ​ 某日，线上发布版本,在weblogic控制台更新的时候,直接卡死无响应。一打开日志一瞧，好家伙，OOM了，还是个metaspace的OOM。 ​ 这玩意儿就有点奇怪了，metaspace按道理是存放的类信息，字面量（Literal）、类静态变量（Class Static）、符号引用（Symbols Reference）等相关信息。类相关信息在metaspace里面又分为2块区域,Klass MetaSpace和NoKlass MetaSpace。这就不细讲了，不然扯不完。 ​ 也就说一般情况下这玩意儿是不会OOM掉的（除开metaspace大小设置不合理的情况） 二、分析 ​ 结合实际情况Metaspace OOM 可能的情况是，以下2种情况： - 大量使用反射，由于JVM的优化机制，会定义一些类出来，导致类加载数量增多。 - JAXB BUG 导致，网上有很多文章在分析 2.1 情况一： ​ 的确项目里面存在大量的反射，再说了使用了spring 框架，反射是避免不了的，这个没办法。但是这种情况说不通，就算类大量的增长，但从未见过有卸载类的情况。排除～！ 2.2 情况二： ​ JAXB 这个情况的确可能存在，毕竟是老项目，但这个没有实际的证据，需要进一步的进行分析。 2.3 什么时候卸载类？ ​ 卸载类要满足3个条件，GC才会对其进行卸载，并回收空间： - 该类所有的实例已经被回收 - 加载该类的CLassLoader已经被回收 - 该类对应的CLass对象没有任何引用 看得出，卸载一个类条件比较苛刻，那就按照上述3个条件进行问题排查。 三、排查 3.1 复现 ​ 解决问题的前提是能够复现问题，好在这次问题比较容易复现出来。 环境： - weblogic 12c jdk 1.8 metaspace 512M maxMetaspace1024M 步骤： 在控制台中使用更新功能，重复部署多次 观察： 使用jdk自带Java VisualVM，观察metaspace内存的增长，以及一个class的加载数量和卸载数量 现象： class一直在增长，没有出现过大幅度的下跌 总共更新了2次载入了7W+的类，卸载却不到3K，这个结果就离谱。 3.2 内存分析 ​ 把heap dump下来，看看。到底是啥导致没有卸载。前文说了，卸载一个类要满足3个条件。那就按照3个条件进行分析。 ​ 但加载类是在太多，不可能一个一个的去分析。从3个条件来看，分析classloader是最靠谱的，毕竟所有类的加载都是由classloader进行加载的，而且classloader数量相对较少。 ​ 通过mat分析，检测出有3个问题,2个都是ChangeAwareCloader： 看来方向没错，去weblogic官方看了一下，上图中的classloader是负责更新class的。点开详情看一下，发现是nacos的线程hold住了classloader导致，嘿嘿破案了。 3.3 这该死的线程 ​ 通过上面的分析，发现是nacos在spring停止的时候并没有停止相关线程，导致该线程一直在后台活跃。由于线程没有退出，那么相应的classloader就不能被回收。 ​ 我TM反手一个pr到nacos。 3.4 验证 ​ 问题原因找到了，就替换掉原由项目的nacos，换上一个停止spring的时候销毁nacos线程版本，验证一下是否解决。 ​ 由于是线程引起的，所以在验证的过程中，要格外注意，nacos线程是否被正常关闭。 上图为weblogic一个线程截图。可以看到nacos相关的线程有6个。此时停止应用，nacos线程已经被正常的销毁了。 ​ 线程已经被正常销毁，再来验证是否能够正常卸载class。重复部署2次，再进行观察。 ​ 还是离谱，依旧没有被卸载，看来问题没有被根本解决。会不会是还有啥线程没有被关闭呢。再去找找看看。先停止应用，看看哪些线程还在后台运行。 扒了一下，还有一个线程没有正常销毁。改改代码再试一下吧0.0. 3.5 还是这该死的线程 ​ 虽然把nacos的线程给销毁了，但还有业务线程还在跑，再测试一把，看看能不能正常的回收class。经过测试没有出现可以的线程了。感觉自己又行了。 ​ 继续测试，重复部署，验证是否能够正常卸载class。 还是离谱，加载了7W多的类，卸载才4K多点，这还是不正常。果然，这个工程的问题很多呀。 3.6 重新分析内存,讨厌的监控 ​ 线程的问题解决了，但问题依旧，只能再dump一份内存看看。 问题还是在classLoader上，去详情看看。 classloader被Logger给hold住了，这有点奇怪了。由上图可以看出，changeAwareClassLoader加载了LoggingHandler，在Logger中引用了LoggingHandler，这个Logger是系统类， ​ 由于Logger是系统类，由jvm的Bootstrap ClassLoader加载，这个classloader的生命周期就很长了，只有jvm进程退出，才会被销毁掉。 ​ 只能翻一下LoggingHandler的代码，看下为啥要去跟Logger扯上关系。 这个玩意儿在启动的时候回去注册一下，获取的是系统的Logger，怪不得会扯上关系。不知道为啥没有被取消注册，取消注册的方法倒是有个。 猜测是jar包版本冲突导致出现了异常，就没有把取消注册流程给走完。问了一下同事，说这个LoggingHandler是属于一个监控，这个监控比较老，可以直接下掉。那就不去纠结为啥没有取消注册了，直接下掉看疗效。 3.7 重新验证 ​ 把监控的jar包下掉，看看能不能达到预期的效果。 weblogic初始状态，一片祥和。 重复部署3次： 还是没卸载，离谱，看来要翻车了。不急陪他耍耍，等他个10分钟，看他自己投降。是不是觉得是玄学😂。对，还真不是玄学，有些东西没有及时释放，是因为在finalize队列中排队呢，等一下就好。 10分钟之后，不对应该是出去吃饭过后： metaspace的占用水平已回归到正常的水平，类卸载从4000到了28000。 反复部署后，metaspace内存也稳定到600M。ok，完美解决。 ​</summary></entry><entry><title type="html">spring-boot2 idea jsp 404 问题探究(tomcat启动流程探究)</title><link href="https://onew.me/spring/2020/03/14/debug-spring-boot2-jsp.html" rel="alternate" type="text/html" title="spring-boot2 idea jsp 404 问题探究(tomcat启动流程探究)" /><published>2020-03-14T09:20:25+08:00</published><updated>2020-03-14T09:20:25+08:00</updated><id>https://onew.me/spring/2020/03/14/debug-spring-boot2-jsp</id><content type="html" xml:base="https://onew.me/spring/2020/03/14/debug-spring-boot2-jsp.html"># 一、前言

​	最近有小朋友在学习spring boot的时候遇到了一个问题,按照教程上操作始终是404.于是就百事不得其解.问我的时候,我也一脸蒙B,毕竟jsp这玩意儿好久都没碰到过了,之前碰jsp的时候还是在ssh的时候.

​	既然遇到问题就来分析一下呗,趁着最近在看spring的源码.



# 二、案发现场

ymal:

```yml
server:
  port: 9090
spring:
  mvc:
    view:
      prefix: /WEB-INF/jsp/
      suffix: .jsp
```

pom:

```xml
 &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
            &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;

    &lt;/build&gt;
```

代码:

```java
@Controller
@EnableAutoConfiguration
public class App {

    public static void main(String[] args) {
        SpringApplication.run(App.class,args);
    }

    @RequestMapping(&quot;/test&quot;)
    public String test(){
        return &quot;index&quot;;
    }

}
```

​	按照以上代码,应该是没有什么问题的,毕竟人家的教程也是这么做的,只不过别人是用eclipse,他是用的idea罢了.我也懒得去分析为啥eclipse没得问题了,直接来看看为啥会有这个问题.



# 三、分析

​	众所周知,spring boot只是在spring上面包了一层皮,里面还是利用了spring的一些机制来完成,当然加载自动化配置,开箱即用,感觉很智能.

​	springboot为我们开发者省去了很多配置上的麻烦,大部分都默认配置好了,但是虽然便利了开发者,但也带来了一些麻烦,就如这个问题,整个日子输出窗口都没有日志显示为啥会是404,文件明明在那,为啥会找不到呢?

​	要解决这个问题,就要从springBoot的自动配置上入手.按照上面的配置,用的是嵌入式的tomcat,那么就从tomcat的配置开始.



## 3.1 ServletWebServerFactoryConfiguration

​	当使用springboot的wen功能的时候,有个关键的配置就避免不了了,代码如下:

```java
@Configuration(proxyBeanMethods = false)
class ServletWebServerFactoryConfiguration {
  
		// 判断classpath是否存在 Servlet,Tomcat,UpgradeProtocol类
   // 如果存在就启用此配置
   // 当然还要 ServletWebServerFactory 期子类没有 在容器中
   @Configuration(proxyBeanMethods = false)
   @ConditionalOnClass({ Servlet.class, Tomcat.class, UpgradeProtocol.class })
   @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
   static class EmbeddedTomcat {

      @Bean
      TomcatServletWebServerFactory tomcatServletWebServerFactory(
            ObjectProvider&lt;TomcatConnectorCustomizer&gt; connectorCustomizers,
            ObjectProvider&lt;TomcatContextCustomizer&gt; contextCustomizers,
            ObjectProvider&lt;TomcatProtocolHandlerCustomizer&lt;?&gt;&gt; protocolHandlerCustomizers) {
         // 创建tomcat 工厂
         TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
         factory.getTomcatConnectorCustomizers()
               .addAll(connectorCustomizers.orderedStream().collect(Collectors.toList()));
         factory.getTomcatContextCustomizers()
               .addAll(contextCustomizers.orderedStream().collect(Collectors.toList()));
         factory.getTomcatProtocolHandlerCustomizers()
               .addAll(protocolHandlerCustomizers.orderedStream().collect(Collectors.toList()));
         return factory;
      }

   }

   /**
    * Nested configuration if Jetty is being used.
    * 同tomcat的逻辑
    */
   @Configuration(proxyBeanMethods = false)
   @ConditionalOnClass({ Servlet.class, Server.class, Loader.class, WebAppContext.class })
   @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
   static class EmbeddedJetty {

      @Bean
      JettyServletWebServerFactory JettyServletWebServerFactory(
            ObjectProvider&lt;JettyServerCustomizer&gt; serverCustomizers) {
         JettyServletWebServerFactory factory = new JettyServletWebServerFactory();
         factory.getServerCustomizers().addAll(serverCustomizers.orderedStream().collect(Collectors.toList()));
         return factory;
      }

   }

   /**
    * Nested configuration if Undertow is being used.
    * 同tomcat的逻辑
    */
   @Configuration(proxyBeanMethods = false)
   @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class })
   @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
   static class EmbeddedUndertow {

      @Bean
      UndertowServletWebServerFactory undertowServletWebServerFactory(
            ObjectProvider&lt;UndertowDeploymentInfoCustomizer&gt; deploymentInfoCustomizers,
            ObjectProvider&lt;UndertowBuilderCustomizer&gt; builderCustomizers) {
         UndertowServletWebServerFactory factory = new UndertowServletWebServerFactory();
         factory.getDeploymentInfoCustomizers()
               .addAll(deploymentInfoCustomizers.orderedStream().collect(Collectors.toList()));
         factory.getBuilderCustomizers().addAll(builderCustomizers.orderedStream().collect(Collectors.toList()));
         return factory;
      }

   }

}
```

​	这里可以看到,配置类按照classpath中的类创建了不同的`ServletWebServerFactory`,本文这里加入了tomcat,所以这里将会创建`TomcatServletWebServerFactory`.

​	当然光看这个还是不行的,要明白为啥会这么创建,那么这一切要从springboot的启动流程开始分析才能解释整个情况.



# 四、SpringBoot启动流程分析

​	太阳底下无新鲜事,来揭开名为方便的面纱.当然这只是初步的探讨.

```java
@EnableAutoConfiguration
public class Main {

    public static void main(String[] args) {
        SpringApplication.run(Main.class,args);
    }
}

```

​	熟悉springBoot的人看到这样的写法是否是感到平淡无奇?那么这短短的一行代码后面到底发生了啥??

## 4.1 SpringApplication.run

```java
public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) {
		return run(new Class&lt;?&gt;[] { primarySource }, args);
	}

	public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) {
		return new SpringApplication(primarySources).run(args);
	}
```

​	创建了个`SpringApplication`对象在run？看看构造函数是否有啥逻辑.

```java
public SpringApplication(Class&lt;?&gt;... primarySources) {
		this(null, primarySources);
	}
public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {
		this.resourceLoader = resourceLoader;
		Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);
		this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));
		// 判断 web 应用的类型
		// 判断依据为 是否存在指定 DispatcherServlet,DispatcherHandler,ServletContainer,WebApplicationContext,ReactiveWebApplicationContext等类
		// 使用 class.forName 进行查找
  	// 判断spring程序的类型
		this.webApplicationType = WebApplicationType.deduceFromClasspath();
		// 加载 META-INF/spring.factories 配置文件,并把 ApplicationContextInitializer 相关的类全部实例化
		setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
		// 加载 META-INF/spring.factories 配置文件,并把 ApplicationListener 相关的类 全部实例化
		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
		// 检查 main 方法所在的类
		this.mainApplicationClass = deduceMainApplicationClass();
	}
```

​	在构造的时候还是做了不少的逻辑,这里就不得不提一下spring的黑魔法了,那就是`SpringFactoriesLoader`,这个东西有点像java中的spi机制,与之不同是spring是读取的是`META-INF/spring.factories`文件.至于为啥不用spi要自己单搞个,emmmmmm.

​	构造的逻辑很简单,不是很复杂,就是检测一下要启动什么类型的spring,具体操作是在`WebApplicationType.deduceFromClasspath();`,这个类型判断还是很重要的,后面创建spring上下文的时候会用得上.

## 4.2 springApplication.run

​	对象创建好了,又要继续run了.

```java
public ConfigurableApplicationContext run(String... args) {
		// 创建一个用于记录 启动-关闭 时间的 StopWatch
		StopWatch stopWatch = new StopWatch();
		stopWatch.start();
		ConfigurableApplicationContext context = null;
		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();
		// 设置环境变量
		configureHeadlessProperty();
		// 创建 EventPublishingRunListener
		// 相当于是个组合模式,所有listener 都集中在 SpringApplicationRunListeners 中
		SpringApplicationRunListeners listeners = getRunListeners(args);
		// 启动容器,发送时间
		listeners.starting();
		try {
			// 把 args 封装为对象,映射到环境中
			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
			// 初始化环境
			ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
			// 设置环境变量 spring.beaninfo.ignore
			configureIgnoreBeanInfo(environment);
			// 获取 需要打印的 Banner 并把 banner 打印到控制台
			Banner printedBanner = printBanner(environment);
      
      
			// 根据不同的类型 创建不同的上下文
			context = createApplicationContext();
      
      
			// 获取 所有 SpringBootExceptionReporter 相关的类
			exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
					new Class[] { ConfigurableApplicationContext.class }, context);
			// 准备上下文
			prepareContext(context, environment, listeners, applicationArguments, printedBanner);
      
      
      
			// 刷新上下文,发送事件
			refreshContext(context);
      
      
			// 模板方法
			afterRefresh(context, applicationArguments);
			// 停止
			stopWatch.stop();
			if (this.logStartupInfo) {
				new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
			}
			// 通知监听器,已经启动
			listeners.started(context);
			// 调用 runner的 run 方法
			callRunners(context, applicationArguments);
		}
		catch (Throwable ex) {
			// 处理运行时的错误
			handleRunFailure(context, ex, exceptionReporters, listeners);
			throw new IllegalStateException(ex);
		}

		try {
			// 通知监听器,正在运行
			listeners.running(context);
		}
		catch (Throwable ex) {
			// 处理运行时的错误
			handleRunFailure(context, ex, exceptionReporters, null);
			throw new IllegalStateException(ex);
		}
		// 返回上下文
		return context;
	}
```

​	由于本文不是分析代码的文章,所以关注点放在创建spring上下文和上下文的操作上.分别是`createApplicationContext`和`refreshContext`



## 4.3 createApplicationContext

```java
protected ConfigurableApplicationContext createApplicationContext() {
		Class&lt;?&gt; contextClass = this.applicationContextClass;
		if (contextClass == null) {
			try {
				switch (this.webApplicationType) {
				case SERVLET:
					contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);
					break;
				case REACTIVE:
					contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);
					break;
				default:
					contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);
				}
			}
			catch (ClassNotFoundException ex) {
				throw new IllegalStateException(
						&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, ex);
			}
		}
		return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
	}
```

​	这里的类型,是按照之前构造方法中的类型进行创建的,如果不清楚的可以往上翻一哈.

1. 如果类型为: SERVLET 就创建 AnnotationConfigServletWebServerApplicationContext
2. 如果类型为: REACTIVE 就创建 AnnotationConfigReactiveWebServerApplicationContext
3. 默认创建 : AnnotationConfigApplicationContext



​	很显然这里的类型是 SERVLET 所以创建了 AnnotationConfigServletWebServerApplicationContext,继承关系如下.

![images](https://gitee.com/oneww/onew_image/raw/master/AnnotationConfigServletWebServerApplicationContext.png)

​	熟悉spring的同学是不是感觉与`ClassPathXmlApplicationContext`差不多？我觉得是差不多的,只是干事的方式有点区别.

​	这里把对象创建完了,然后进行一顿骚操作,设置值,环境等等.不再这里进行分析.要看的关键点是`refreshContext`.

## 4.5 refreshContext

​	刷新上下文,这里刷新会有什么骚操作呢?来瞧瞧就知道了.

```java
private void refreshContext(ConfigurableApplicationContext context) {
		refresh((ApplicationContext) context);
		if (this.registerShutdownHook) {
			try {
				// 添加关闭钩子,关闭程序时,关闭上下文 释放资源
				context.registerShutdownHook();
			}
			catch (AccessControlException ex) {
				// Not allowed in some environments.
			}
		}
	}
```

​	添加钩子这个可以不用管,不影响逻辑.

```java
@Deprecated
	protected void refresh(ApplicationContext applicationContext) {
		Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext);
		refresh((ConfigurableApplicationContext) applicationContext);
	}
```

​	虽然这个方法过时,但spring还是没有直接删除,真够良心的,不像某Final,直接删,真TMSB.

```java
protected void refresh(ConfigurableApplicationContext applicationContext) {
		applicationContext.refresh();
	}
```

​	注意这里的context 实际上是`AnnotationConfigServletWebServerApplicationContext`,而`AnnotationConfigServletWebServerApplicationContext`没有重写这个方法,是继承的它父类`ServletWebServerApplicationContext`.

```java
// ServletWebServerApplicationContext
@Override
	public final void refresh() throws BeansException, IllegalStateException {
		try {
			super.refresh();
		}
		catch (RuntimeException ex) {
			stopAndReleaseWebServer();
			throw ex;
		}
	}
```

​	`ServletWebServerApplicationContext`的父类是`AbstractApplicationContext`

```java
// AbstractApplicationContext
public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			// 准备刷新上下文环境
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			// 初始化beanFactory,进行xml预读取
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			// 对beanFactory进行填充
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				// 子类覆盖方法做额外的处理
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				// 激活各种beanFactoryProcessors
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				//注册拦截bean创建的bean处理器
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				// 初始化上下文的消息源
				initMessageSource();

				// Initialize event multicaster for this context.
				// 初始化上下文的消息广播
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				// 留给子类来初始化其他的bean
				onRefresh();

				// Check for listener beans and register them.
				// 注册所有bean的监听器
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				// 初始化延迟加载的bean
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				// 最后一步,发布消息
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn(&quot;Exception encountered during context initialization - &quot; +
							&quot;cancelling refresh attempt: &quot; + ex);
				}
				//发生异常,销毁所有bean
				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				// 重置flag
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				// 重置缓存
				resetCommonCaches();
			}
		}
	}
```

​	这里的重点是`onRefresh`,这里`onRefresh`是由子类`ServletWebServerApplicationContext`进行实现的.



## 4.6 onRefresh

```java
	// ServletWebServerApplicationContext
	@Override
	protected void onRefresh() {
		super.onRefresh();
		try {
		// 创建server
			createWebServer();
		}
		catch (Throwable ex) {
			throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);
		}
	}

```

​	终于绕到了创建 server 这里了,不知少侠是否还记得那个配置类??`ServletWebServerFactoryConfiguration`.那么现在才真正的开始了.

```java
private void createWebServer() {
		WebServer webServer = this.webServer;
  	// 获取servlet 上下文
		ServletContext servletContext = getServletContext();
    // 如果 server 为空 或者 servlet上下文为空,就创建server
		if (webServer == null &amp;&amp; servletContext == null) {
			ServletWebServerFactory factory = getWebServerFactory();
			this.webServer = factory.getWebServer(getSelfInitializer());
		}
		else if (servletContext != null) {
			try {
				getSelfInitializer().onStartup(servletContext);
			}
			catch (ServletException ex) {
				throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex);
			}
		}
		initPropertySources();
	}
```

1. 判断server是否创建
2. 未创建就创建
3. 初始化
4. 初始化资源



​	这里的 `getWebServerFactory()` 方法从容器中获取的,容器里面的是之前配置类中创建的.

```java
// 从容器中获取 ServletWebServerFactory
protected ServletWebServerFactory getWebServerFactory() {
		// Use bean names so that we don't consider the hierarchy
		String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);
		if (beanNames.length == 0) {
			throw new ApplicationContextException(&quot;Unable to start ServletWebServerApplicationContext due to missing &quot;
					+ &quot;ServletWebServerFactory bean.&quot;);
		}
		if (beanNames.length &gt; 1) {
			throw new ApplicationContextException(&quot;Unable to start ServletWebServerApplicationContext due to multiple &quot;
					+ &quot;ServletWebServerFactory beans : &quot; + StringUtils.arrayToCommaDelimitedString(beanNames));
		}
		return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class);
	}
```



#  五、tomcat的创建

​	前面千辛万苦的获取到了 tomcatServer的工厂,接下来就看看是怎么创建的吧.

```java
// TomcatServletWebServerFactory
@Override
	public WebServer getWebServer(ServletContextInitializer... initializers) {
		// .. 省略
    // 初始化
		prepareContext(tomcat.getHost(), initializers);
		return getTomcatWebServer(tomcat);
	}
```

​	这里`ServletContextInitializer`是不是和`ServletContainerInitializer`有点神似?别说不仔细看还是会看错,至于这两个是啥关系,这里就不琢磨了,毕竟这个不是重点.



## 5.1 初始化

```java
// TomcatServletWebServerFactory
protected void prepareContext(Host host, ServletContextInitializer[] initializers) {
		//... 省略
  	// 添加监听器
		context.addLifecycleListener(new StaticResourceConfigurer(context));
		ServletContextInitializer[] initializersToUse = mergeInitializers(initializers);
		host.addChild(context);
		configureContext(context, initializersToUse);
		postProcessContext(context);
	}
```

​	在初始化过程中添加了一个名字为静态资源配置的监听器,名字都很怪怪的好吧.去看看这个监听器是干嘛的.

```java
private final class StaticResourceConfigurer implements LifecycleListener {

		private final Context context;

		private StaticResourceConfigurer(Context context) {
			this.context = context;
		}

		@Override
		public void lifecycleEvent(LifecycleEvent event) {
      // 判断时机
			if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {
				addResourceJars(getUrlsOfJarsWithMetaInfResources());
			}
		}

		private void addResourceJars(List&lt;URL&gt; resourceJarUrls) {
			for (URL url : resourceJarUrls) {
				String path = url.getPath();
				if (path.endsWith(&quot;.jar&quot;) || path.endsWith(&quot;.jar!/&quot;)) {
					String jar = url.toString();
					if (!jar.startsWith(&quot;jar:&quot;)) {
						// A jar file in the file system. Convert to Jar URL.
						jar = &quot;jar:&quot; + jar + &quot;!/&quot;;
					}
					addResourceSet(jar);
				}
				else {
					addResourceSet(url.toString());
				}
			}
		}

		private void addResourceSet(String resource) {
			try {
				if (isInsideNestedJar(resource)) {
					// It's a nested jar but we now don't want the suffix because Tomcat
					// is going to try and locate it as a root URL (not the resource
					// inside it)
					resource = resource.substring(0, resource.length() - 2);
				}
				URL url = new URL(resource);
				String path = &quot;/META-INF/resources&quot;;
				this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, &quot;/&quot;, url, path);
			}
			catch (Exception ex) {
				// Ignore (probably not a directory)
			}
		}

		private boolean isInsideNestedJar(String dir) {
			return dir.indexOf(&quot;!/&quot;) &lt; dir.lastIndexOf(&quot;!/&quot;);
		}

	}
```

​	从这个监听器的代码逻辑上看 是往`context.getResources`丢东西呀.貌似是路径啥的,这会不会与开头的404问题有关呢？

​	`createWebResourceSet`这个方法嫌疑很大,去看看.

```java
// StandardRoot 
public void createWebResourceSet(ResourceSetType type, String webAppMount,
            String base, String archivePath, String internalPath) {
        List&lt;WebResourceSet&gt; resourceList;
        WebResourceSet resourceSet;

        switch (type) {
            case PRE:
                resourceList = preResources;
                break;
            case CLASSES_JAR:
                resourceList = classResources;
                break;
            case RESOURCE_JAR:
                resourceList = jarResources;
                break;
            case POST:
                resourceList = postResources;
                break;
            default:
                throw new IllegalArgumentException(
                        sm.getString(&quot;standardRoot.createUnknownType&quot;, type));
        }
					// ..... 省略
        resourceList.add(resourceSet);
    }
```

​	以上逻辑为根据不同的类型,往不同的list中添加路径.好吧还是看不出来这个到底有什么用,404的问题也没找到,不如果跟踪一下请求看看.



# 六、请求的跟踪

​	springMVC对请求的处理逻辑一般为 DispatcherServlet接管请求-&gt;查找handler-&gt;查找handlerDapter-&gt;视图解析器-&gt;解析视图-&gt;渲染视图.

​	虽然这个逻辑不不完善,可能还是错的,但差不多,笔者认为哈.

​	那么问题来了,在springMVC中的视图解析器是啥呢？看看ViewResolver的子类就知道是InternalResourceViewResolver了.但这个没啥用呀,因为具体的渲染逻辑是在视图对象里,解析器在这里没啥太大的用处.所以来看看jsp的视图`JstlView`中的操作吧.

```java
public class JstlView extends InternalResourceView {

	@Nullable
	private MessageSource messageSource;


	/**
	 * Constructor for use as a bean.
	 * @see #setUrl
	 */
	public JstlView() {
	}

	/**
	 * Create a new JstlView with the given URL.
	 * @param url the URL to forward to
	 */
	public JstlView(String url) {
		super(url);
	}

	/**
	 * Create a new JstlView with the given URL.
	 * @param url the URL to forward to
	 * @param messageSource the MessageSource to expose to JSTL tags
	 * (will be wrapped with a JSTL-aware MessageSource that is aware of JSTL's
	 * {@code javax.servlet.jsp.jstl.fmt.localizationContext} context-param)
	 * @see JstlUtils#getJstlAwareMessageSource
	 */
	public JstlView(String url, MessageSource messageSource) {
		this(url);
		this.messageSource = messageSource;
	}


	/**
	 * Wraps the MessageSource with a JSTL-aware MessageSource that is aware
	 * of JSTL's {@code javax.servlet.jsp.jstl.fmt.localizationContext}
	 * context-param.
	 * @see JstlUtils#getJstlAwareMessageSource
	 */
	@Override
	protected void initServletContext(ServletContext servletContext) {
		if (this.messageSource != null) {
			this.messageSource = JstlUtils.getJstlAwareMessageSource(servletContext, this.messageSource);
		}
		super.initServletContext(servletContext);
	}

	/**
	 * Exposes a JSTL LocalizationContext for Spring's locale and MessageSource.
	 * @see JstlUtils#exposeLocalizationContext
	 */
	@Override
	protected void exposeHelpers(HttpServletRequest request) throws Exception {
		if (this.messageSource != null) {
			JstlUtils.exposeLocalizationContext(request, this.messageSource);
		}
		else {
			JstlUtils.exposeLocalizationContext(new RequestContext(request, getServletContext()));
		}
	}

}
```

​	在jstlView中并没有看到jsp的处理逻辑,去父类看看.

```java
public class InternalResourceView extends AbstractUrlBasedView {
// 省略...

	/**
	 * Render the internal resource given the specified model.
	 * This includes setting the model as request attributes.
	 */
	@Override
	protected void renderMergedOutputModel(
			Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception {

		// Expose the model object as request attributes.
		exposeModelAsRequestAttributes(model, request);

		// Expose helpers as request attributes, if any.
		exposeHelpers(request);

		// Determine the path for the request dispatcher.
		String dispatcherPath = prepareForRendering(request, response);

		// Obtain a RequestDispatcher for the target resource (typically a JSP).
		RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);
		if (rd == null) {
			throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +
					&quot;]: Check that the corresponding file exists within your web application archive!&quot;);
		}

		// If already included or response already committed, perform include, else forward.
		if (useInclude(request, response)) {
			response.setContentType(getContentType());
			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Including [&quot; + getUrl() + &quot;]&quot;);
			}
			rd.include(request, response);
		}

		else {
			// Note: The forwarded resource is supposed to determine the content type itself.
			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Forwarding to [&quot; + getUrl() + &quot;]&quot;);
			}
			rd.forward(request, response);
		}
	}
  
  // 省略....

}
```

​	核心处理逻辑在`renderMergedOutputModel`,经过`renderMergedOutputModel`方法一顿骚操作以后,最后发现请求被`RequestDispatcher`接管了.emmm,线索又断了,那么最后是被谁接管的呢?在j2ee的世界里,能被啥接管?不就是个servlet或者filter嘛.

​	那么接下来要搞清楚是谁接管了请求,并渲染了jsp,虽然答案很显然了,但还是要走一下流程.



## 6.1 猜测是servlet接管了请求

​	springMVC 里 servlet?那不就是DispatcherServlet嘛?但总觉得不可能,不可能请求从DispatcherServlet来又回去吧?那就看看在创建tomcat的时候有没有注册其他的servelt.

```java
// TomcatServletWebServerFactory
protected void prepareContext(Host host, ServletContextInitializer[] initializers) {
		// 省略 ..
		if (isRegisterDefaultServlet()) {
			addDefaultServlet(context);
		}
  
		if (shouldRegisterJspServlet()) {
			addJspServlet(context);
			addJasperInitializer(context);
		}
		// 省略	...
	}

```

​	可以看到在初始化的时候,注册了两个servlet,一个默认的servlet一个是jsp的servlet

```java
// TomcatServletWebServerFactory
private void addDefaultServlet(Context context) {
		Wrapper defaultServlet = context.createWrapper();
		// 名称
		defaultServlet.setName(&quot;default&quot;);
		defaultServlet.setServletClass(&quot;org.apache.catalina.servlets.DefaultServlet&quot;);
		defaultServlet.addInitParameter(&quot;debug&quot;, &quot;0&quot;);
		defaultServlet.addInitParameter(&quot;listings&quot;, &quot;false&quot;);
		defaultServlet.setLoadOnStartup(1);
		// Otherwise the default location of a Spring DispatcherServlet cannot be set
  	// 是否运行覆盖,这是为了dispatcherServlet做准备
  	// 方便在后免把这个默认的servlet给覆盖掉
		defaultServlet.setOverridable(true);
		context.addChild(defaultServlet);
		context.addServletMappingDecoded(&quot;/&quot;, &quot;default&quot;);
	}

	private void addJspServlet(Context context) {
		Wrapper jspServlet = context.createWrapper();
		jspServlet.setName(&quot;jsp&quot;);
		jspServlet.setServletClass(getJsp().getClassName());
		jspServlet.addInitParameter(&quot;fork&quot;, &quot;false&quot;);
		getJsp().getInitParameters().forEach(jspServlet::addInitParameter);
		jspServlet.setLoadOnStartup(3);
		context.addChild(jspServlet);
    // 拦截 *.jsp 后缀的请求
		context.addServletMappingDecoded(&quot;*.jsp&quot;, &quot;jsp&quot;);
		context.addServletMappingDecoded(&quot;*.jspx&quot;, &quot;jsp&quot;);
	}

```

两个servlet,一个默认的,一个jsp的.看到这儿会不会有点奇怪,为啥不注册dispatcherServlet?emmm不是很明白昂,但是这个核心的servlet是不会落下的.

```java
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration(proxyBeanMethods = false)
/**
 * 匹配容器为 servlet
 * **/
@ConditionalOnWebApplication(type = Type.SERVLET)
/**
 * 判断 class path 路径下有 DispatcherServlet.class
 * **/
@ConditionalOnClass(DispatcherServlet.class)
/***
 * 在 ServletWebServerFactoryAutoConfiguration 之后生效
 * */
@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)
public class DispatcherServletAutoConfiguration {

	/*
	 * The bean name for a DispatcherServlet that will be mapped to the root URL &quot;/&quot;
	 */
	public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = &quot;dispatcherServlet&quot;;

	/*
	 * The bean name for a ServletRegistrationBean for the DispatcherServlet &quot;/&quot;
	 */
	public static final String DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME = &quot;dispatcherServletRegistration&quot;;

	@Configuration(proxyBeanMethods = false)
	@Conditional(DefaultDispatcherServletCondition.class)
	@ConditionalOnClass(ServletRegistration.class)
	// 启用配置 WebMvcProperties
	@EnableConfigurationProperties(WebMvcProperties.class)
	protected static class DispatcherServletConfiguration {

		@Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
		public DispatcherServlet dispatcherServlet(WebMvcProperties webMvcProperties) {
			DispatcherServlet dispatcherServlet = new DispatcherServlet();
			dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());
			dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest());
			dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound());
			dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents());
			dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails());
			return dispatcherServlet;
		}

		@Bean
		@ConditionalOnBean(MultipartResolver.class)
		@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)
		public MultipartResolver multipartResolver(MultipartResolver resolver) {
			// Detect if the user has created a MultipartResolver but named it incorrectly
			return resolver;
		}

	}

	@Configuration(proxyBeanMethods = false)
	@Conditional(DispatcherServletRegistrationCondition.class)
	@ConditionalOnClass(ServletRegistration.class)
	@EnableConfigurationProperties(WebMvcProperties.class)
	@Import(DispatcherServletConfiguration.class)
	protected static class DispatcherServletRegistrationConfiguration {

		@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
		@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
		public DispatcherServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet,
				WebMvcProperties webMvcProperties, ObjectProvider&lt;MultipartConfigElement&gt; multipartConfig) {
			DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(dispatcherServlet,
					webMvcProperties.getServlet().getPath());
      // 名称
			registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
      // 启动顺序
			registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());
			multipartConfig.ifAvailable(registration::setMultipartConfig);
			return registration;
		}

	}
  // 省略....

}
```

​	在自动配置的这个类里面生成了一个`DispatcherServletRegistrationBean`对象,这个对象就是用于组测dispatcherServlet的.`DispatcherServletRegistrationBean`是`ServletContextInitializer`的子类,用于初始化,注册等操作等.

​	那么这个对象是在什么时候注册的呢?又要回到tomcat创建的时候了.

```java
// TomcatServletWebServerFactory
@Override
	public WebServer getWebServer(ServletContextInitializer... initializers) {
    // 省略..
		prepareContext(tomcat.getHost(), initializers);
		return getTomcatWebServer(tomcat);
	}

```

​	在调用初始化上下文的时候把这个玩意儿给传进去了.

```java
// TomcatServletWebServerFactory
protected void prepareContext(Host host, ServletContextInitializer[] initializers) {
  // 省略...
		ServletContextInitializer[] initializersToUse = mergeInitializers(initializers);
		host.addChild(context);
		configureContext(context, initializersToUse);
		postProcessContext(context);
	}
```

​	这里合并了所有的`ServletContextInitializer`对象,传入到了`configureContext`方法中.

```java
// TomcatServletWebServerFactory
protected void configureContext(Context context, ServletContextInitializer[] initializers) {
		TomcatStarter starter = new TomcatStarter(initializers);
		context.addServletContainerInitializer(starter, NO_CLASSES);

	}
```

​	这里把`ServletContextInitializer`转成了一个`TomcatStarter`对象,并把这个对象添加到了上下文中去.这个

`TomcatStarter`就厉害了.

```java
class TomcatStarter implements ServletContainerInitializer {

	private static final Log logger = LogFactory.getLog(TomcatStarter.class);

	private final ServletContextInitializer[] initializers;

	private volatile Exception startUpException;

	TomcatStarter(ServletContextInitializer[] initializers) {
		this.initializers = initializers;
	}

	@Override
	public void onStartup(Set&lt;Class&lt;?&gt;&gt; classes, ServletContext servletContext) throws ServletException {
		try {
			// 初始化所有需要 初始化的类
			for (ServletContextInitializer initializer : this.initializers) {
				initializer.onStartup(servletContext);
			}
		}
		catch (Exception ex) {
			this.startUpException = ex;
			// Prevent Tomcat from logging and re-throwing when we know we can
			// deal with it in the main thread, but log for information here.
			if (logger.isErrorEnabled()) {
				logger.error(&quot;Error starting Tomcat context. Exception: &quot; + ex.getClass().getName() + &quot;. Message: &quot;
						+ ex.getMessage());
			}
		}
	}

	Exception getStartUpException() {
		return this.startUpException;
	}

}
```

​	`TomcatStarter`实现了`ServletContainerInitializer`接口,这个接口就厉害了,在servlet的生命中期中,会调用实现这个接口的`onStartup`方法,至于什么是servlet的生命周期,就不引出了,估计一时半会也说不完.

​	嗯,知道这个东西的厉害,说了这么多,也没说`ServletContextInitializer`这个东西哪来的.不是方法传进来的嘛?不行就回去看看.

```java
@Override
	public WebServer getWebServer(ServletContextInitializer... initializers) {
		// 省略...
		return getTomcatWebServer(tomcat);
	}

```

​	嗯,是传进来的,怎么传进来的？当然是创建的时候传的了0.0

```java
// ServletWebServerApplicationContext
private void createWebServer() {
		WebServer webServer = this.webServer;
		ServletContext servletContext = getServletContext();
		if (webServer == null &amp;&amp; servletContext == null) {
			ServletWebServerFactory factory = getWebServerFactory();
			this.webServer = factory.getWebServer(getSelfInitializer());
		}
		else if (servletContext != null) {
			try {
				getSelfInitializer().onStartup(servletContext);
			}
			catch (ServletException ex) {
				throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex);
			}
		}
		initPropertySources();
	}
```



## 6.2 ServletContextInitializer 怎么来的

```java
// 	ServletWebServerApplicationContext
private org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() {
		return this::selfInitialize;
	}

	private void selfInitialize(ServletContext servletContext) throws ServletException {
		prepareWebApplicationContext(servletContext);
		registerApplicationScope(servletContext);
		WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext);
		for (ServletContextInitializer beans : getServletContextInitializerBeans()) {
			beans.onStartup(servletContext);
		}
	}
```

​	这就是了,那配置类`DispatcherServletAutoConfiguration`里面的`DispatcherServletRegistrationBean`哪去了?这里的确没有,不过在`getServletContextInitializerBeans()`方法返回的集合里面.

```java
// ServletWebServerApplicationContext
protected Collection&lt;ServletContextInitializer&gt; getServletContextInitializerBeans() {
		return new ServletContextInitializerBeans(getBeanFactory());
	}
```

​	`ServletContextInitializerBeans`是一个继承了`AbstractCollection`的集合对象.

```java
// ServletContextInitializerBeans
public ServletContextInitializerBeans(ListableBeanFactory beanFactory,
			Class&lt;? extends ServletContextInitializer&gt;... initializerTypes) {
		this.initializers = new LinkedMultiValueMap&lt;&gt;();
		this.initializerTypes = (initializerTypes.length != 0) ? Arrays.asList(initializerTypes)
				: Collections.singletonList(ServletContextInitializer.class);
		addServletContextInitializerBeans(beanFactory);
		addAdaptableBeans(beanFactory);
		List&lt;ServletContextInitializer&gt; sortedInitializers = this.initializers.values().stream()
				.flatMap((value) -&gt; value.stream().sorted(AnnotationAwareOrderComparator.INSTANCE))
				.collect(Collectors.toList());
		this.sortedList = Collections.unmodifiableList(sortedInitializers);
		logMappings(this.initializers);
	}
```

​	核心逻辑就在构造方法中的`addServletContextInitializerBeans`方法中.

```java
// ServletContextInitializerBeans
private void addServletContextInitializerBeans(ListableBeanFactory beanFactory) {
		for (Class&lt;? extends ServletContextInitializer&gt; initializerType : this.initializerTypes) {
			for (Entry&lt;String, ? extends ServletContextInitializer&gt; initializerBean : getOrderedBeansOfType(beanFactory,
					initializerType)) {
				addServletContextInitializerBean(initializerBean.getKey(), initializerBean.getValue(), beanFactory);
			}
		}
	}
	
	private &lt;T&gt; List&lt;Entry&lt;String, T&gt;&gt; getOrderedBeansOfType(ListableBeanFactory beanFactory, Class&lt;T&gt; type) {
		return getOrderedBeansOfType(beanFactory, type, Collections.emptySet());
	}
	private &lt;T&gt; List&lt;Entry&lt;String, T&gt;&gt; getOrderedBeansOfType(ListableBeanFactory beanFactory, Class&lt;T&gt; type,
			Set&lt;?&gt; excludes) {
		String[] names = beanFactory.getBeanNamesForType(type, true, false);
		Map&lt;String, T&gt; map = new LinkedHashMap&lt;&gt;();
		for (String name : names) {
			if (!excludes.contains(name) &amp;&amp; !ScopedProxyUtils.isScopedTarget(name)) {
				T bean = beanFactory.getBean(name, type);
				if (!excludes.contains(bean)) {
					map.put(name, bean);
				}
			}
		}
		List&lt;Entry&lt;String, T&gt;&gt; beans = new ArrayList&lt;&gt;(map.entrySet());
		beans.sort((o1, o2) -&gt; AnnotationAwareOrderComparator.INSTANCE.compare(o1.getValue(), o2.getValue()));
		return beans;
	}
```

​	从ioc中获取所有`ServletContextInitialize`的子类,而这个bean就刚好是之前配置类中的bean,`DispatcherServletRegistrationBean`.

​	至于注册的逻辑就不阐述了,很简单,顺着`DispatcherServletRegistrationBean`的父类`RegistrationBean`看下去就好.



# 七、整理线索

​	前面说了那么多跟404完全没有关系呀,其实前面是在做铺垫而已,看官别着急.由前文的逻辑可以知道在tomcat里面至少注册了2个servetl,一个是spring的(后面覆盖的),一个是jsp的.那么完全由理由猜测,最后由JstlView转发的请求到了jspServlet里面.来看看jspSerlvet里面干了啥?

```java
 // JspServlet
 public void service (HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

       	// 省略....

        try {
            serviceJspFile(request, response, jspUri, precompile);
        } catch (RuntimeException e) {
            throw e;
        } catch (ServletException e) {
            throw e;
        } catch (IOException e) {
            throw e;
        } catch (Throwable e) {
            ExceptionUtils.handleThrowable(e);
            throw new ServletException(e);
        }

    }
```

​	别问我为啥只贴了service这个方法.先看看第一个方法`serviceJspFile`.

```java
// JspServlet 
private void serviceJspFile(HttpServletRequest request,
                                HttpServletResponse response, String jspUri,
                                boolean precompile)
        throws ServletException, IOException {

        JspServletWrapper wrapper = rctxt.getWrapper(jspUri);
        if (wrapper == null) {
            synchronized(this) {
                wrapper = rctxt.getWrapper(jspUri);
                if (wrapper == null) {
                    // Check if the requested JSP page exists, to avoid
                    // creating unnecessary directories and files.
                  	// 判断 jsp 文件是否存在
                    if (null == context.getResource(jspUri)) {
                        handleMissingResource(request, response, jspUri);
                        return;
                    }
                    wrapper = new JspServletWrapper(config, options, jspUri,
                                                    rctxt);
                    rctxt.addWrapper(jspUri,wrapper);
                }
            }
        }

        try {
            wrapper.service(request, response, precompile);
        } catch (FileNotFoundException fnfe) {
            handleMissingResource(request, response, jspUri);
        }

    }
```

​	诺,核心代码被抓了.这个SerlvetContext,既然在tomcat里面那么它的实现类肯定是`ApplicationContext`,不用怀疑,不信你跟跟流程看看.

​	既然是`ApplicationContext`中获取资源,那来看看是怎么拿的文件吧.

```java
//  ApplicationContext
public URL getResource(String path) throws MalformedURLException {

      	// 省略... 
        WebResourceRoot resources = context.getResources();
        if (resources != null) {
          	// 获取资源
            return resources.getResource(validatedPath).getURL();
        }

        return null;
    }

```

​	转战到 `WebResourceRoot`里去,`WebResourceRoot`是个接口,在本案例中的唯一子类是`StandardRoot`.

```java
// StandardRoot
@Override
    public WebResource getResource(String path) {
        return getResource(path, true, false);
    }

    protected WebResource getResource(String path, boolean validate,
            boolean useClassLoaderResources) {
        if (validate) {
            path = validate(path);
        }
				// 判断是否允许缓存,这个默认值是true
        if (isCachingAllowed()) {
            return cache.getResource(path, useClassLoaderResources);
        } else {
            return getResourceInternal(path, useClassLoaderResources);
        }
    }
```

​	这里分两种情况,一个是从换成里面获取,另外则从非缓存中获取,缓存里面的世界很精彩的.



## 7.1 从缓存里面获取

```java
// Cache
protected WebResource getResource(String path, boolean useClassLoaderResources) {

  	// 省略....
		// 判断是否获取到缓存
    if (cacheEntry == null) {
        // Local copy to ensure consistency
        int objectMaxSizeBytes = getObjectMaxSizeBytes();
      	// 创建缓存对象
        CachedResource newCacheEntry = new CachedResource(this, root, path, getTtl(),
                objectMaxSizeBytes, useClassLoaderResources);

        // Concurrent callers will end up with the same CachedResource
        // instance
      	// 放入缓存中
        cacheEntry = resourceCache.putIfAbsent(path, newCacheEntry);
				// 二次判断
        if (cacheEntry == null) {
            // newCacheEntry was inserted into the cache - validate it
            cacheEntry = newCacheEntry;
          	// 验证资源的合法性(这里就石锤了)
            cacheEntry.validateResource(useClassLoaderResources);
		// 省略....

    return cacheEntry;
}
```

​	还差2步

```java
// CachedResource
protected boolean validateResource(boolean useClassLoaderResources) {
       // 省略..
  			// 非空检查
        if (webResource == null) {
          	// 加锁
            synchronized (this) {
              	// 双重检查
                if (webResource == null) {
                    webResource = root.getResourceInternal(
                            webAppPath, useClassLoaderResources);
                    getLastModified();
                    getContentLength();
                    nextCheck = ttl + now;
                    // exists() is a relatively expensive check for a file so
                    // use the fact that we know if it exists at this point
                    if (webResource instanceof EmptyResource) {
                        cachedExists = Boolean.FALSE;
                    } else {
                        cachedExists = Boolean.TRUE;
                    }
                    return true;
                }
            }
        }
}
```

​	程序初次允许的时候,webResource肯定是为空的,别说缓存了.这里的root是`StandardRoot`,又调用回去了.

```java
// StandardRoot

 private final List&lt;List&lt;WebResourceSet&gt;&gt; allResources =
            new ArrayList&lt;&gt;();
    {
        allResources.add(preResources);
        allResources.add(mainResources);
        allResources.add(classResources);
        allResources.add(jarResources);
        allResources.add(postResources);
    }

protected final WebResource getResourceInternal(String path,
            boolean useClassLoaderResources) {
        WebResource result = null;
        WebResource virtual = null;
        WebResource mainEmpty = null;
        for (List&lt;WebResourceSet&gt; list : allResources) {
            for (WebResourceSet webResourceSet : list) {
                if (!useClassLoaderResources &amp;&amp;  !webResourceSet.getClassLoaderOnly() ||
                        useClassLoaderResources &amp;&amp; !webResourceSet.getStaticOnly()) {
                    result = webResourceSet.getResource(path);
                    if (result.exists()) {
                        return result;
                    }
                    if (virtual == null) {
                        if (result.isVirtual()) {
                            virtual = result;
                        } else if (main.equals(webResourceSet)) {
                            mainEmpty = result;
                        }
                    }
                }
            }
        }
				// 省略...
        // Default is empty resource in main resources
        return mainEmpty;
    }
```

​	这里遍历不同资源类别,来判断文件是否存在,如果存在就返回,然后放入缓存中.至于从非缓存中获取的逻辑就上面`getResourceInternal`的逻辑,就不罗嗦了.

​	嗯,这个有啥用呢?还是未解决404的问题呀,别急快了.



# 八、被遗忘的静态资源监听器(StaticResourceConfigurer)

​	少侠是否记得在创建tomcat的时候在servletContext中添加了个这个监听器呢?

```java
// TomcatServletWebServerFactory
protected void prepareContext(Host host, ServletContextInitializer[] initializers) {
		// 省略...
		context.addLifecycleListener(new StaticResourceConfigurer(context));
		// 省略...
	}
```

​	再来看看这个监听器的逻辑吧.

```java
// TomcatServletWebServerFactory$StaticResourceConfigurer
private final class StaticResourceConfigurer implements LifecycleListener {

		private final Context context;

		private StaticResourceConfigurer(Context context) {
			this.context = context;
		}

		@Override
		public void lifecycleEvent(LifecycleEvent event) {
			if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {
				addResourceJars(getUrlsOfJarsWithMetaInfResources());
			}
		}

		private void addResourceJars(List&lt;URL&gt; resourceJarUrls) {
			for (URL url : resourceJarUrls) {
				String path = url.getPath();
				if (path.endsWith(&quot;.jar&quot;) || path.endsWith(&quot;.jar!/&quot;)) {
					String jar = url.toString();
					if (!jar.startsWith(&quot;jar:&quot;)) {
						// A jar file in the file system. Convert to Jar URL.
						jar = &quot;jar:&quot; + jar + &quot;!/&quot;;
					}
					addResourceSet(jar);
				}
				else {
					addResourceSet(url.toString());
				}
			}
		}

		private void addResourceSet(String resource) {
			try {
				if (isInsideNestedJar(resource)) {
					// It's a nested jar but we now don't want the suffix because Tomcat
					// is going to try and locate it as a root URL (not the resource
					// inside it)
					resource = resource.substring(0, resource.length() - 2);
				}
				URL url = new URL(resource);
				String path = &quot;/META-INF/resources&quot;;
				this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, &quot;/&quot;, url, path);
			}
			catch (Exception ex) {
				// Ignore (probably not a directory)
			}
		}

		private boolean isInsideNestedJar(String dir) {
			return dir.indexOf(&quot;!/&quot;) &lt; dir.lastIndexOf(&quot;!/&quot;);
		}

	}

```

​	无论逻辑怎么变化,最后监听器的代码都会走到`this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, &quot;/&quot;, url, path);`这句话来.

​	看到`ResourceSetType.RESOURCE_JAR`这个常量是否有点感觉呢?没感觉就脱掉衣服再看看.

```java
// StandardRoot 
public void createWebResourceSet(ResourceSetType type, String webAppMount,
            URL url, String internalPath) {
        BaseLocation baseLocation = new BaseLocation(url);
        createWebResourceSet(type, webAppMount, baseLocation.getBasePath(),
                baseLocation.getArchivePath(), internalPath);
    }

    @Override
    public void createWebResourceSet(ResourceSetType type, String webAppMount,
            String base, String archivePath, String internalPath) {
        List&lt;WebResourceSet&gt; resourceList;
        WebResourceSet resourceSet;

        switch (type) {
            case PRE:
                resourceList = preResources;
                break;
            case CLASSES_JAR:
                resourceList = classResources;
                break;
            case RESOURCE_JAR:
                resourceList = jarResources;
                break;
            case POST:
                resourceList = postResources;
                break;
            default:
                throw new IllegalArgumentException(
                        sm.getString(&quot;standardRoot.createUnknownType&quot;, type));
        }
      	// 省略
        resourceList.add(resourceSet);
    }
```

​	是不是这一切都园回去了？是不是感觉疑惑都没了?如果还是不解在去看看资源解析的那块儿.



# 九、真相

​	为甚么是404呢?那是因为在StandardRoot里面的resourceList中不存在指定的根路径,所以是404.又要有小伙伴要杠了,说MATE-INFO目录下面的都没问题.

​	是,没问题.因为springBoot把这个路径加进去了.不信你看.

```java
// StaticResourceConfigurer
private final class StaticResourceConfigurer implements LifecycleListener {

		private final Context context;

		private StaticResourceConfigurer(Context context) {
			this.context = context;
		}

		@Override
		public void lifecycleEvent(LifecycleEvent event) {
			if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {
				addResourceJars(getUrlsOfJarsWithMetaInfResources());
			}
		}

		private void addResourceJars(List&lt;URL&gt; resourceJarUrls) {
			// 省略
		}

		private void addResourceSet(String resource) {
			// 省略
		}

		private boolean isInsideNestedJar(String dir) {
			return dir.indexOf(&quot;!/&quot;) &lt; dir.lastIndexOf(&quot;!/&quot;);
		}

	}
```

​	在`getUrlsOfJarsWithMetaInfResources`方法里面就有这个路径.逻辑简单就不贴出来了.



## 9.1 如何解决404

​	根据以上的分析,可以和spring一样弄个监听器,在resourceList添加指定的路径.最简单暴力的方法如下:

```java
@Controller
@EnableAutoConfiguration
@Configuration
public class Main {

    public static void main(String[] args) {
        SpringApplication.run(Main.class,args);
    }

    @RequestMapping(&quot;/test-static&quot;)
    public String testStatic(){
        return &quot;index-static&quot;;
    }

    @RequestMapping(&quot;/test-public&quot;)
    public String testPublic(){
        return &quot;index-public&quot;;
    }

    @RequestMapping(&quot;/test-resources&quot;)
    public String testResources(){
        return &quot;index-resources&quot;;
    }

    @RequestMapping(&quot;/test-meta&quot;)
    public String testMeta(){
        return &quot;index-meta&quot;;
    }

    @Bean
    public TomcatServletWebServerFactory getTomcatServletWebServerFactory(){
        return new AdvTomcatServletWebServerFactory();
    }

}

```

自定义工厂:

```java
public class AdvTomcatServletWebServerFactory extends TomcatServletWebServerFactory {

    private Context context;

    public AdvTomcatServletWebServerFactory(){
        getContextLifecycleListeners().add(new AdvResourceListener());
    }
		// 这个方法是 spring留下的模板方法
  	// 可以通过这个方法进行扩展
    @Override
    protected void postProcessContext(Context context) {
        this.context = context;
    }

    private  class AdvResourceListener implements LifecycleListener{

        @Override
        public void lifecycleEvent(LifecycleEvent event) {
            if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {
                final URL resource = AdvTomcatServletWebServerFactory.class.getClassLoader().getResource(&quot;.&quot;);
                final WebResourceRoot resources = AdvTomcatServletWebServerFactory.this.context.getResources();
                resources.createWebResourceSet(WebResourceRoot.ResourceSetType.RESOURCE_JAR, &quot;/&quot;, resource, &quot;/static&quot;);
                resources.createWebResourceSet(WebResourceRoot.ResourceSetType.RESOURCE_JAR, &quot;/&quot;, resource, &quot;/public&quot;);
                resources.createWebResourceSet(WebResourceRoot.ResourceSetType.RESOURCE_JAR, &quot;/&quot;, resource, &quot;/resources&quot;);
            }

        }
    }
}
```

​	通过自己的工厂替换掉spring的工厂,实现注册自己的监听器,当然方法还有很多,如果你熟悉tomcat的启动流程的话.

# 十、小结

​	在springBoot的懒人套餐下,出现问题往往会让人防不胜防呀,比如这个404,根本没有任何信息说哪里有问题(除非是开了debug日志).

​	本来就想谢谢解决方案的,结果写了这么多,吃饭了.</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">一、前言 ​ 最近有小朋友在学习spring boot的时候遇到了一个问题,按照教程上操作始终是404.于是就百事不得其解.问我的时候,我也一脸蒙B,毕竟jsp这玩意儿好久都没碰到过了,之前碰jsp的时候还是在ssh的时候. ​ 既然遇到问题就来分析一下呗,趁着最近在看spring的源码. 二、案发现场 ymal: server: port: 9090 spring: mvc: view: prefix: /WEB-INF/jsp/ suffix: .jsp pom: &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;tomcat-embed-jasper&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; 代码: @Controller @EnableAutoConfiguration public class App { public static void main(String[] args) { SpringApplication.run(App.class,args); } @RequestMapping(&quot;/test&quot;) public String test(){ return &quot;index&quot;; } } ​ 按照以上代码,应该是没有什么问题的,毕竟人家的教程也是这么做的,只不过别人是用eclipse,他是用的idea罢了.我也懒得去分析为啥eclipse没得问题了,直接来看看为啥会有这个问题. 三、分析 ​ 众所周知,spring boot只是在spring上面包了一层皮,里面还是利用了spring的一些机制来完成,当然加载自动化配置,开箱即用,感觉很智能. ​ springboot为我们开发者省去了很多配置上的麻烦,大部分都默认配置好了,但是虽然便利了开发者,但也带来了一些麻烦,就如这个问题,整个日子输出窗口都没有日志显示为啥会是404,文件明明在那,为啥会找不到呢? ​ 要解决这个问题,就要从springBoot的自动配置上入手.按照上面的配置,用的是嵌入式的tomcat,那么就从tomcat的配置开始. 3.1 ServletWebServerFactoryConfiguration ​ 当使用springboot的wen功能的时候,有个关键的配置就避免不了了,代码如下: @Configuration(proxyBeanMethods = false) class ServletWebServerFactoryConfiguration { // 判断classpath是否存在 Servlet,Tomcat,UpgradeProtocol类 // 如果存在就启用此配置 // 当然还要 ServletWebServerFactory 期子类没有 在容器中 @Configuration(proxyBeanMethods = false) @ConditionalOnClass({ Servlet.class, Tomcat.class, UpgradeProtocol.class }) @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT) static class EmbeddedTomcat { @Bean TomcatServletWebServerFactory tomcatServletWebServerFactory( ObjectProvider&amp;lt;TomcatConnectorCustomizer&amp;gt; connectorCustomizers, ObjectProvider&amp;lt;TomcatContextCustomizer&amp;gt; contextCustomizers, ObjectProvider&amp;lt;TomcatProtocolHandlerCustomizer&amp;lt;?&amp;gt;&amp;gt; protocolHandlerCustomizers) { // 创建tomcat 工厂 TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(); factory.getTomcatConnectorCustomizers() .addAll(connectorCustomizers.orderedStream().collect(Collectors.toList())); factory.getTomcatContextCustomizers() .addAll(contextCustomizers.orderedStream().collect(Collectors.toList())); factory.getTomcatProtocolHandlerCustomizers() .addAll(protocolHandlerCustomizers.orderedStream().collect(Collectors.toList())); return factory; } } /** * Nested configuration if Jetty is being used. * 同tomcat的逻辑 */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass({ Servlet.class, Server.class, Loader.class, WebAppContext.class }) @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT) static class EmbeddedJetty { @Bean JettyServletWebServerFactory JettyServletWebServerFactory( ObjectProvider&amp;lt;JettyServerCustomizer&amp;gt; serverCustomizers) { JettyServletWebServerFactory factory = new JettyServletWebServerFactory(); factory.getServerCustomizers().addAll(serverCustomizers.orderedStream().collect(Collectors.toList())); return factory; } } /** * Nested configuration if Undertow is being used. * 同tomcat的逻辑 */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class }) @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT) static class EmbeddedUndertow { @Bean UndertowServletWebServerFactory undertowServletWebServerFactory( ObjectProvider&amp;lt;UndertowDeploymentInfoCustomizer&amp;gt; deploymentInfoCustomizers, ObjectProvider&amp;lt;UndertowBuilderCustomizer&amp;gt; builderCustomizers) { UndertowServletWebServerFactory factory = new UndertowServletWebServerFactory(); factory.getDeploymentInfoCustomizers() .addAll(deploymentInfoCustomizers.orderedStream().collect(Collectors.toList())); factory.getBuilderCustomizers().addAll(builderCustomizers.orderedStream().collect(Collectors.toList())); return factory; } } } ​ 这里可以看到,配置类按照classpath中的类创建了不同的ServletWebServerFactory,本文这里加入了tomcat,所以这里将会创建TomcatServletWebServerFactory. ​ 当然光看这个还是不行的,要明白为啥会这么创建,那么这一切要从springboot的启动流程开始分析才能解释整个情况. 四、SpringBoot启动流程分析 ​ 太阳底下无新鲜事,来揭开名为方便的面纱.当然这只是初步的探讨. @EnableAutoConfiguration public class Main { public static void main(String[] args) { SpringApplication.run(Main.class,args); } } ​ 熟悉springBoot的人看到这样的写法是否是感到平淡无奇?那么这短短的一行代码后面到底发生了啥?? 4.1 SpringApplication.run public static ConfigurableApplicationContext run(Class&amp;lt;?&amp;gt; primarySource, String... args) { return run(new Class&amp;lt;?&amp;gt;[] { primarySource }, args); } public static ConfigurableApplicationContext run(Class&amp;lt;?&amp;gt;[] primarySources, String[] args) { return new SpringApplication(primarySources).run(args); } ​ 创建了个SpringApplication对象在run？看看构造函数是否有啥逻辑. public SpringApplication(Class&amp;lt;?&amp;gt;... primarySources) { this(null, primarySources); } public SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;... primarySources) { this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&amp;lt;&amp;gt;(Arrays.asList(primarySources)); // 判断 web 应用的类型 // 判断依据为 是否存在指定 DispatcherServlet,DispatcherHandler,ServletContainer,WebApplicationContext,ReactiveWebApplicationContext等类 // 使用 class.forName 进行查找 // 判断spring程序的类型 this.webApplicationType = WebApplicationType.deduceFromClasspath(); // 加载 META-INF/spring.factories 配置文件,并把 ApplicationContextInitializer 相关的类全部实例化 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // 加载 META-INF/spring.factories 配置文件,并把 ApplicationListener 相关的类 全部实例化 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 检查 main 方法所在的类 this.mainApplicationClass = deduceMainApplicationClass(); } ​ 在构造的时候还是做了不少的逻辑,这里就不得不提一下spring的黑魔法了,那就是SpringFactoriesLoader,这个东西有点像java中的spi机制,与之不同是spring是读取的是META-INF/spring.factories文件.至于为啥不用spi要自己单搞个,emmmmmm. ​ 构造的逻辑很简单,不是很复杂,就是检测一下要启动什么类型的spring,具体操作是在WebApplicationType.deduceFromClasspath();,这个类型判断还是很重要的,后面创建spring上下文的时候会用得上. 4.2 springApplication.run ​ 对象创建好了,又要继续run了. public ConfigurableApplicationContext run(String... args) { // 创建一个用于记录 启动-关闭 时间的 StopWatch StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&amp;lt;SpringBootExceptionReporter&amp;gt; exceptionReporters = new ArrayList&amp;lt;&amp;gt;(); // 设置环境变量 configureHeadlessProperty(); // 创建 EventPublishingRunListener // 相当于是个组合模式,所有listener 都集中在 SpringApplicationRunListeners 中 SpringApplicationRunListeners listeners = getRunListeners(args); // 启动容器,发送时间 listeners.starting(); try { // 把 args 封装为对象,映射到环境中 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 初始化环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 设置环境变量 spring.beaninfo.ignore configureIgnoreBeanInfo(environment); // 获取 需要打印的 Banner 并把 banner 打印到控制台 Banner printedBanner = printBanner(environment); // 根据不同的类型 创建不同的上下文 context = createApplicationContext(); // 获取 所有 SpringBootExceptionReporter 相关的类 exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); // 准备上下文 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 刷新上下文,发送事件 refreshContext(context); // 模板方法 afterRefresh(context, applicationArguments); // 停止 stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); } // 通知监听器,已经启动 listeners.started(context); // 调用 runner的 run 方法 callRunners(context, applicationArguments); } catch (Throwable ex) { // 处理运行时的错误 handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); } try { // 通知监听器,正在运行 listeners.running(context); } catch (Throwable ex) { // 处理运行时的错误 handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); } // 返回上下文 return context; } ​ 由于本文不是分析代码的文章,所以关注点放在创建spring上下文和上下文的操作上.分别是createApplicationContext和refreshContext 4.3 createApplicationContext protected ConfigurableApplicationContext createApplicationContext() { Class&amp;lt;?&amp;gt; contextClass = this.applicationContextClass; if (contextClass == null) { try { switch (this.webApplicationType) { case SERVLET: contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS); break; case REACTIVE: contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); } } catch (ClassNotFoundException ex) { throw new IllegalStateException( &quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, ex); } } return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass); } ​ 这里的类型,是按照之前构造方法中的类型进行创建的,如果不清楚的可以往上翻一哈. 如果类型为: SERVLET 就创建 AnnotationConfigServletWebServerApplicationContext 如果类型为: REACTIVE 就创建 AnnotationConfigReactiveWebServerApplicationContext 默认创建 : AnnotationConfigApplicationContext ​ 很显然这里的类型是 SERVLET 所以创建了 AnnotationConfigServletWebServerApplicationContext,继承关系如下. ​ 熟悉spring的同学是不是感觉与ClassPathXmlApplicationContext差不多？我觉得是差不多的,只是干事的方式有点区别. ​ 这里把对象创建完了,然后进行一顿骚操作,设置值,环境等等.不再这里进行分析.要看的关键点是refreshContext. 4.5 refreshContext ​ 刷新上下文,这里刷新会有什么骚操作呢?来瞧瞧就知道了. private void refreshContext(ConfigurableApplicationContext context) { refresh((ApplicationContext) context); if (this.registerShutdownHook) { try { // 添加关闭钩子,关闭程序时,关闭上下文 释放资源 context.registerShutdownHook(); } catch (AccessControlException ex) { // Not allowed in some environments. } } } ​ 添加钩子这个可以不用管,不影响逻辑. @Deprecated protected void refresh(ApplicationContext applicationContext) { Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext); refresh((ConfigurableApplicationContext) applicationContext); } ​ 虽然这个方法过时,但spring还是没有直接删除,真够良心的,不像某Final,直接删,真TMSB. protected void refresh(ConfigurableApplicationContext applicationContext) { applicationContext.refresh(); } ​ 注意这里的context 实际上是AnnotationConfigServletWebServerApplicationContext,而AnnotationConfigServletWebServerApplicationContext没有重写这个方法,是继承的它父类ServletWebServerApplicationContext. // ServletWebServerApplicationContext @Override public final void refresh() throws BeansException, IllegalStateException { try { super.refresh(); } catch (RuntimeException ex) { stopAndReleaseWebServer(); throw ex; } } ​ ServletWebServerApplicationContext的父类是AbstractApplicationContext // AbstractApplicationContext public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. // 准备刷新上下文环境 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. // 初始化beanFactory,进行xml预读取 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. // 对beanFactory进行填充 prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. // 子类覆盖方法做额外的处理 postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. // 激活各种beanFactoryProcessors invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. //注册拦截bean创建的bean处理器 registerBeanPostProcessors(beanFactory); // Initialize message source for this context. // 初始化上下文的消息源 initMessageSource(); // Initialize event multicaster for this context. // 初始化上下文的消息广播 initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. // 留给子类来初始化其他的bean onRefresh(); // Check for listener beans and register them. // 注册所有bean的监听器 registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 初始化延迟加载的bean finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. // 最后一步,发布消息 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } //发生异常,销毁所有bean // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. // 重置flag cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... // 重置缓存 resetCommonCaches(); } } } ​ 这里的重点是onRefresh,这里onRefresh是由子类ServletWebServerApplicationContext进行实现的. 4.6 onRefresh // ServletWebServerApplicationContext @Override protected void onRefresh() { super.onRefresh(); try { // 创建server createWebServer(); } catch (Throwable ex) { throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex); } } ​ 终于绕到了创建 server 这里了,不知少侠是否还记得那个配置类??ServletWebServerFactoryConfiguration.那么现在才真正的开始了. private void createWebServer() { WebServer webServer = this.webServer; // 获取servlet 上下文 ServletContext servletContext = getServletContext(); // 如果 server 为空 或者 servlet上下文为空,就创建server if (webServer == null &amp;amp;&amp;amp; servletContext == null) { ServletWebServerFactory factory = getWebServerFactory(); this.webServer = factory.getWebServer(getSelfInitializer()); } else if (servletContext != null) { try { getSelfInitializer().onStartup(servletContext); } catch (ServletException ex) { throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex); } } initPropertySources(); } 判断server是否创建 未创建就创建 初始化 初始化资源 ​ 这里的 getWebServerFactory() 方法从容器中获取的,容器里面的是之前配置类中创建的. // 从容器中获取 ServletWebServerFactory protected ServletWebServerFactory getWebServerFactory() { // Use bean names so that we don't consider the hierarchy String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class); if (beanNames.length == 0) { throw new ApplicationContextException(&quot;Unable to start ServletWebServerApplicationContext due to missing &quot; + &quot;ServletWebServerFactory bean.&quot;); } if (beanNames.length &amp;gt; 1) { throw new ApplicationContextException(&quot;Unable to start ServletWebServerApplicationContext due to multiple &quot; + &quot;ServletWebServerFactory beans : &quot; + StringUtils.arrayToCommaDelimitedString(beanNames)); } return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class); } 五、tomcat的创建 ​ 前面千辛万苦的获取到了 tomcatServer的工厂,接下来就看看是怎么创建的吧. // TomcatServletWebServerFactory @Override public WebServer getWebServer(ServletContextInitializer... initializers) { // .. 省略 // 初始化 prepareContext(tomcat.getHost(), initializers); return getTomcatWebServer(tomcat); } ​ 这里ServletContextInitializer是不是和ServletContainerInitializer有点神似?别说不仔细看还是会看错,至于这两个是啥关系,这里就不琢磨了,毕竟这个不是重点. 5.1 初始化 // TomcatServletWebServerFactory protected void prepareContext(Host host, ServletContextInitializer[] initializers) { //... 省略 // 添加监听器 context.addLifecycleListener(new StaticResourceConfigurer(context)); ServletContextInitializer[] initializersToUse = mergeInitializers(initializers); host.addChild(context); configureContext(context, initializersToUse); postProcessContext(context); } ​ 在初始化过程中添加了一个名字为静态资源配置的监听器,名字都很怪怪的好吧.去看看这个监听器是干嘛的. private final class StaticResourceConfigurer implements LifecycleListener { private final Context context; private StaticResourceConfigurer(Context context) { this.context = context; } @Override public void lifecycleEvent(LifecycleEvent event) { // 判断时机 if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) { addResourceJars(getUrlsOfJarsWithMetaInfResources()); } } private void addResourceJars(List&amp;lt;URL&amp;gt; resourceJarUrls) { for (URL url : resourceJarUrls) { String path = url.getPath(); if (path.endsWith(&quot;.jar&quot;) || path.endsWith(&quot;.jar!/&quot;)) { String jar = url.toString(); if (!jar.startsWith(&quot;jar:&quot;)) { // A jar file in the file system. Convert to Jar URL. jar = &quot;jar:&quot; + jar + &quot;!/&quot;; } addResourceSet(jar); } else { addResourceSet(url.toString()); } } } private void addResourceSet(String resource) { try { if (isInsideNestedJar(resource)) { // It's a nested jar but we now don't want the suffix because Tomcat // is going to try and locate it as a root URL (not the resource // inside it) resource = resource.substring(0, resource.length() - 2); } URL url = new URL(resource); String path = &quot;/META-INF/resources&quot;; this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, &quot;/&quot;, url, path); } catch (Exception ex) { // Ignore (probably not a directory) } } private boolean isInsideNestedJar(String dir) { return dir.indexOf(&quot;!/&quot;) &amp;lt; dir.lastIndexOf(&quot;!/&quot;); } } ​ 从这个监听器的代码逻辑上看 是往context.getResources丢东西呀.貌似是路径啥的,这会不会与开头的404问题有关呢？ ​ createWebResourceSet这个方法嫌疑很大,去看看. // StandardRoot public void createWebResourceSet(ResourceSetType type, String webAppMount, String base, String archivePath, String internalPath) { List&amp;lt;WebResourceSet&amp;gt; resourceList; WebResourceSet resourceSet; switch (type) { case PRE: resourceList = preResources; break; case CLASSES_JAR: resourceList = classResources; break; case RESOURCE_JAR: resourceList = jarResources; break; case POST: resourceList = postResources; break; default: throw new IllegalArgumentException( sm.getString(&quot;standardRoot.createUnknownType&quot;, type)); } // ..... 省略 resourceList.add(resourceSet); } ​ 以上逻辑为根据不同的类型,往不同的list中添加路径.好吧还是看不出来这个到底有什么用,404的问题也没找到,不如果跟踪一下请求看看. 六、请求的跟踪 ​ springMVC对请求的处理逻辑一般为 DispatcherServlet接管请求-&amp;gt;查找handler-&amp;gt;查找handlerDapter-&amp;gt;视图解析器-&amp;gt;解析视图-&amp;gt;渲染视图. ​ 虽然这个逻辑不不完善,可能还是错的,但差不多,笔者认为哈. ​ 那么问题来了,在springMVC中的视图解析器是啥呢？看看ViewResolver的子类就知道是InternalResourceViewResolver了.但这个没啥用呀,因为具体的渲染逻辑是在视图对象里,解析器在这里没啥太大的用处.所以来看看jsp的视图JstlView中的操作吧. public class JstlView extends InternalResourceView { @Nullable private MessageSource messageSource; /** * Constructor for use as a bean. * @see #setUrl */ public JstlView() { } /** * Create a new JstlView with the given URL. * @param url the URL to forward to */ public JstlView(String url) { super(url); } /** * Create a new JstlView with the given URL. * @param url the URL to forward to * @param messageSource the MessageSource to expose to JSTL tags * (will be wrapped with a JSTL-aware MessageSource that is aware of JSTL's * {@code javax.servlet.jsp.jstl.fmt.localizationContext} context-param) * @see JstlUtils#getJstlAwareMessageSource */ public JstlView(String url, MessageSource messageSource) { this(url); this.messageSource = messageSource; } /** * Wraps the MessageSource with a JSTL-aware MessageSource that is aware * of JSTL's {@code javax.servlet.jsp.jstl.fmt.localizationContext} * context-param. * @see JstlUtils#getJstlAwareMessageSource */ @Override protected void initServletContext(ServletContext servletContext) { if (this.messageSource != null) { this.messageSource = JstlUtils.getJstlAwareMessageSource(servletContext, this.messageSource); } super.initServletContext(servletContext); } /** * Exposes a JSTL LocalizationContext for Spring's locale and MessageSource. * @see JstlUtils#exposeLocalizationContext */ @Override protected void exposeHelpers(HttpServletRequest request) throws Exception { if (this.messageSource != null) { JstlUtils.exposeLocalizationContext(request, this.messageSource); } else { JstlUtils.exposeLocalizationContext(new RequestContext(request, getServletContext())); } } } ​ 在jstlView中并没有看到jsp的处理逻辑,去父类看看. public class InternalResourceView extends AbstractUrlBasedView { // 省略... /** * Render the internal resource given the specified model. * This includes setting the model as request attributes. */ @Override protected void renderMergedOutputModel( Map&amp;lt;String, Object&amp;gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception { // Expose the model object as request attributes. exposeModelAsRequestAttributes(model, request); // Expose helpers as request attributes, if any. exposeHelpers(request); // Determine the path for the request dispatcher. String dispatcherPath = prepareForRendering(request, response); // Obtain a RequestDispatcher for the target resource (typically a JSP). RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath); if (rd == null) { throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() + &quot;]: Check that the corresponding file exists within your web application archive!&quot;); } // If already included or response already committed, perform include, else forward. if (useInclude(request, response)) { response.setContentType(getContentType()); if (logger.isDebugEnabled()) { logger.debug(&quot;Including [&quot; + getUrl() + &quot;]&quot;); } rd.include(request, response); } else { // Note: The forwarded resource is supposed to determine the content type itself. if (logger.isDebugEnabled()) { logger.debug(&quot;Forwarding to [&quot; + getUrl() + &quot;]&quot;); } rd.forward(request, response); } } // 省略.... } ​ 核心处理逻辑在renderMergedOutputModel,经过renderMergedOutputModel方法一顿骚操作以后,最后发现请求被RequestDispatcher接管了.emmm,线索又断了,那么最后是被谁接管的呢?在j2ee的世界里,能被啥接管?不就是个servlet或者filter嘛. ​ 那么接下来要搞清楚是谁接管了请求,并渲染了jsp,虽然答案很显然了,但还是要走一下流程. 6.1 猜测是servlet接管了请求 ​ springMVC 里 servlet?那不就是DispatcherServlet嘛?但总觉得不可能,不可能请求从DispatcherServlet来又回去吧?那就看看在创建tomcat的时候有没有注册其他的servelt. // TomcatServletWebServerFactory protected void prepareContext(Host host, ServletContextInitializer[] initializers) { // 省略 .. if (isRegisterDefaultServlet()) { addDefaultServlet(context); } if (shouldRegisterJspServlet()) { addJspServlet(context); addJasperInitializer(context); } // 省略 ... } ​ 可以看到在初始化的时候,注册了两个servlet,一个默认的servlet一个是jsp的servlet // TomcatServletWebServerFactory private void addDefaultServlet(Context context) { Wrapper defaultServlet = context.createWrapper(); // 名称 defaultServlet.setName(&quot;default&quot;); defaultServlet.setServletClass(&quot;org.apache.catalina.servlets.DefaultServlet&quot;); defaultServlet.addInitParameter(&quot;debug&quot;, &quot;0&quot;); defaultServlet.addInitParameter(&quot;listings&quot;, &quot;false&quot;); defaultServlet.setLoadOnStartup(1); // Otherwise the default location of a Spring DispatcherServlet cannot be set // 是否运行覆盖,这是为了dispatcherServlet做准备 // 方便在后免把这个默认的servlet给覆盖掉 defaultServlet.setOverridable(true); context.addChild(defaultServlet); context.addServletMappingDecoded(&quot;/&quot;, &quot;default&quot;); } private void addJspServlet(Context context) { Wrapper jspServlet = context.createWrapper(); jspServlet.setName(&quot;jsp&quot;); jspServlet.setServletClass(getJsp().getClassName()); jspServlet.addInitParameter(&quot;fork&quot;, &quot;false&quot;); getJsp().getInitParameters().forEach(jspServlet::addInitParameter); jspServlet.setLoadOnStartup(3); context.addChild(jspServlet); // 拦截 *.jsp 后缀的请求 context.addServletMappingDecoded(&quot;*.jsp&quot;, &quot;jsp&quot;); context.addServletMappingDecoded(&quot;*.jspx&quot;, &quot;jsp&quot;); } 两个servlet,一个默认的,一个jsp的.看到这儿会不会有点奇怪,为啥不注册dispatcherServlet?emmm不是很明白昂,但是这个核心的servlet是不会落下的. @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) @Configuration(proxyBeanMethods = false) /** * 匹配容器为 servlet * **/ @ConditionalOnWebApplication(type = Type.SERVLET) /** * 判断 class path 路径下有 DispatcherServlet.class * **/ @ConditionalOnClass(DispatcherServlet.class) /*** * 在 ServletWebServerFactoryAutoConfiguration 之后生效 * */ @AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class) public class DispatcherServletAutoConfiguration { /* * The bean name for a DispatcherServlet that will be mapped to the root URL &quot;/&quot; */ public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = &quot;dispatcherServlet&quot;; /* * The bean name for a ServletRegistrationBean for the DispatcherServlet &quot;/&quot; */ public static final String DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME = &quot;dispatcherServletRegistration&quot;; @Configuration(proxyBeanMethods = false) @Conditional(DefaultDispatcherServletCondition.class) @ConditionalOnClass(ServletRegistration.class) // 启用配置 WebMvcProperties @EnableConfigurationProperties(WebMvcProperties.class) protected static class DispatcherServletConfiguration { @Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME) public DispatcherServlet dispatcherServlet(WebMvcProperties webMvcProperties) { DispatcherServlet dispatcherServlet = new DispatcherServlet(); dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest()); dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest()); dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound()); dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents()); dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails()); return dispatcherServlet; } @Bean @ConditionalOnBean(MultipartResolver.class) @ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) public MultipartResolver multipartResolver(MultipartResolver resolver) { // Detect if the user has created a MultipartResolver but named it incorrectly return resolver; } } @Configuration(proxyBeanMethods = false) @Conditional(DispatcherServletRegistrationCondition.class) @ConditionalOnClass(ServletRegistration.class) @EnableConfigurationProperties(WebMvcProperties.class) @Import(DispatcherServletConfiguration.class) protected static class DispatcherServletRegistrationConfiguration { @Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME) @ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME) public DispatcherServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet, WebMvcProperties webMvcProperties, ObjectProvider&amp;lt;MultipartConfigElement&amp;gt; multipartConfig) { DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(dispatcherServlet, webMvcProperties.getServlet().getPath()); // 名称 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); // 启动顺序 registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup()); multipartConfig.ifAvailable(registration::setMultipartConfig); return registration; } } // 省略.... } ​ 在自动配置的这个类里面生成了一个DispatcherServletRegistrationBean对象,这个对象就是用于组测dispatcherServlet的.DispatcherServletRegistrationBean是ServletContextInitializer的子类,用于初始化,注册等操作等. ​ 那么这个对象是在什么时候注册的呢?又要回到tomcat创建的时候了. // TomcatServletWebServerFactory @Override public WebServer getWebServer(ServletContextInitializer... initializers) { // 省略.. prepareContext(tomcat.getHost(), initializers); return getTomcatWebServer(tomcat); } ​ 在调用初始化上下文的时候把这个玩意儿给传进去了. // TomcatServletWebServerFactory protected void prepareContext(Host host, ServletContextInitializer[] initializers) { // 省略... ServletContextInitializer[] initializersToUse = mergeInitializers(initializers); host.addChild(context); configureContext(context, initializersToUse); postProcessContext(context); } ​ 这里合并了所有的ServletContextInitializer对象,传入到了configureContext方法中. // TomcatServletWebServerFactory protected void configureContext(Context context, ServletContextInitializer[] initializers) { TomcatStarter starter = new TomcatStarter(initializers); context.addServletContainerInitializer(starter, NO_CLASSES); } ​ 这里把ServletContextInitializer转成了一个TomcatStarter对象,并把这个对象添加到了上下文中去.这个 TomcatStarter就厉害了. class TomcatStarter implements ServletContainerInitializer { private static final Log logger = LogFactory.getLog(TomcatStarter.class); private final ServletContextInitializer[] initializers; private volatile Exception startUpException; TomcatStarter(ServletContextInitializer[] initializers) { this.initializers = initializers; } @Override public void onStartup(Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; classes, ServletContext servletContext) throws ServletException { try { // 初始化所有需要 初始化的类 for (ServletContextInitializer initializer : this.initializers) { initializer.onStartup(servletContext); } } catch (Exception ex) { this.startUpException = ex; // Prevent Tomcat from logging and re-throwing when we know we can // deal with it in the main thread, but log for information here. if (logger.isErrorEnabled()) { logger.error(&quot;Error starting Tomcat context. Exception: &quot; + ex.getClass().getName() + &quot;. Message: &quot; + ex.getMessage()); } } } Exception getStartUpException() { return this.startUpException; } } ​ TomcatStarter实现了ServletContainerInitializer接口,这个接口就厉害了,在servlet的生命中期中,会调用实现这个接口的onStartup方法,至于什么是servlet的生命周期,就不引出了,估计一时半会也说不完. ​ 嗯,知道这个东西的厉害,说了这么多,也没说ServletContextInitializer这个东西哪来的.不是方法传进来的嘛?不行就回去看看. @Override public WebServer getWebServer(ServletContextInitializer... initializers) { // 省略... return getTomcatWebServer(tomcat); } ​ 嗯,是传进来的,怎么传进来的？当然是创建的时候传的了0.0 // ServletWebServerApplicationContext private void createWebServer() { WebServer webServer = this.webServer; ServletContext servletContext = getServletContext(); if (webServer == null &amp;amp;&amp;amp; servletContext == null) { ServletWebServerFactory factory = getWebServerFactory(); this.webServer = factory.getWebServer(getSelfInitializer()); } else if (servletContext != null) { try { getSelfInitializer().onStartup(servletContext); } catch (ServletException ex) { throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex); } } initPropertySources(); } 6.2 ServletContextInitializer 怎么来的 // ServletWebServerApplicationContext private org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() { return this::selfInitialize; } private void selfInitialize(ServletContext servletContext) throws ServletException { prepareWebApplicationContext(servletContext); registerApplicationScope(servletContext); WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext); for (ServletContextInitializer beans : getServletContextInitializerBeans()) { beans.onStartup(servletContext); } } ​ 这就是了,那配置类DispatcherServletAutoConfiguration里面的DispatcherServletRegistrationBean哪去了?这里的确没有,不过在getServletContextInitializerBeans()方法返回的集合里面. // ServletWebServerApplicationContext protected Collection&amp;lt;ServletContextInitializer&amp;gt; getServletContextInitializerBeans() { return new ServletContextInitializerBeans(getBeanFactory()); } ​ ServletContextInitializerBeans是一个继承了AbstractCollection的集合对象. // ServletContextInitializerBeans public ServletContextInitializerBeans(ListableBeanFactory beanFactory, Class&amp;lt;? extends ServletContextInitializer&amp;gt;... initializerTypes) { this.initializers = new LinkedMultiValueMap&amp;lt;&amp;gt;(); this.initializerTypes = (initializerTypes.length != 0) ? Arrays.asList(initializerTypes) : Collections.singletonList(ServletContextInitializer.class); addServletContextInitializerBeans(beanFactory); addAdaptableBeans(beanFactory); List&amp;lt;ServletContextInitializer&amp;gt; sortedInitializers = this.initializers.values().stream() .flatMap((value) -&amp;gt; value.stream().sorted(AnnotationAwareOrderComparator.INSTANCE)) .collect(Collectors.toList()); this.sortedList = Collections.unmodifiableList(sortedInitializers); logMappings(this.initializers); } ​ 核心逻辑就在构造方法中的addServletContextInitializerBeans方法中. // ServletContextInitializerBeans private void addServletContextInitializerBeans(ListableBeanFactory beanFactory) { for (Class&amp;lt;? extends ServletContextInitializer&amp;gt; initializerType : this.initializerTypes) { for (Entry&amp;lt;String, ? extends ServletContextInitializer&amp;gt; initializerBean : getOrderedBeansOfType(beanFactory, initializerType)) { addServletContextInitializerBean(initializerBean.getKey(), initializerBean.getValue(), beanFactory); } } } private &amp;lt;T&amp;gt; List&amp;lt;Entry&amp;lt;String, T&amp;gt;&amp;gt; getOrderedBeansOfType(ListableBeanFactory beanFactory, Class&amp;lt;T&amp;gt; type) { return getOrderedBeansOfType(beanFactory, type, Collections.emptySet()); } private &amp;lt;T&amp;gt; List&amp;lt;Entry&amp;lt;String, T&amp;gt;&amp;gt; getOrderedBeansOfType(ListableBeanFactory beanFactory, Class&amp;lt;T&amp;gt; type, Set&amp;lt;?&amp;gt; excludes) { String[] names = beanFactory.getBeanNamesForType(type, true, false); Map&amp;lt;String, T&amp;gt; map = new LinkedHashMap&amp;lt;&amp;gt;(); for (String name : names) { if (!excludes.contains(name) &amp;amp;&amp;amp; !ScopedProxyUtils.isScopedTarget(name)) { T bean = beanFactory.getBean(name, type); if (!excludes.contains(bean)) { map.put(name, bean); } } } List&amp;lt;Entry&amp;lt;String, T&amp;gt;&amp;gt; beans = new ArrayList&amp;lt;&amp;gt;(map.entrySet()); beans.sort((o1, o2) -&amp;gt; AnnotationAwareOrderComparator.INSTANCE.compare(o1.getValue(), o2.getValue())); return beans; } ​ 从ioc中获取所有ServletContextInitialize的子类,而这个bean就刚好是之前配置类中的bean,DispatcherServletRegistrationBean. ​ 至于注册的逻辑就不阐述了,很简单,顺着DispatcherServletRegistrationBean的父类RegistrationBean看下去就好. 七、整理线索 ​ 前面说了那么多跟404完全没有关系呀,其实前面是在做铺垫而已,看官别着急.由前文的逻辑可以知道在tomcat里面至少注册了2个servetl,一个是spring的(后面覆盖的),一个是jsp的.那么完全由理由猜测,最后由JstlView转发的请求到了jspServlet里面.来看看jspSerlvet里面干了啥? // JspServlet public void service (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 省略.... try { serviceJspFile(request, response, jspUri, precompile); } catch (RuntimeException e) { throw e; } catch (ServletException e) { throw e; } catch (IOException e) { throw e; } catch (Throwable e) { ExceptionUtils.handleThrowable(e); throw new ServletException(e); } } ​ 别问我为啥只贴了service这个方法.先看看第一个方法serviceJspFile. // JspServlet private void serviceJspFile(HttpServletRequest request, HttpServletResponse response, String jspUri, boolean precompile) throws ServletException, IOException { JspServletWrapper wrapper = rctxt.getWrapper(jspUri); if (wrapper == null) { synchronized(this) { wrapper = rctxt.getWrapper(jspUri); if (wrapper == null) { // Check if the requested JSP page exists, to avoid // creating unnecessary directories and files. // 判断 jsp 文件是否存在 if (null == context.getResource(jspUri)) { handleMissingResource(request, response, jspUri); return; } wrapper = new JspServletWrapper(config, options, jspUri, rctxt); rctxt.addWrapper(jspUri,wrapper); } } } try { wrapper.service(request, response, precompile); } catch (FileNotFoundException fnfe) { handleMissingResource(request, response, jspUri); } } ​ 诺,核心代码被抓了.这个SerlvetContext,既然在tomcat里面那么它的实现类肯定是ApplicationContext,不用怀疑,不信你跟跟流程看看. ​ 既然是ApplicationContext中获取资源,那来看看是怎么拿的文件吧. // ApplicationContext public URL getResource(String path) throws MalformedURLException { // 省略... WebResourceRoot resources = context.getResources(); if (resources != null) { // 获取资源 return resources.getResource(validatedPath).getURL(); } return null; } ​ 转战到 WebResourceRoot里去,WebResourceRoot是个接口,在本案例中的唯一子类是StandardRoot. // StandardRoot @Override public WebResource getResource(String path) { return getResource(path, true, false); } protected WebResource getResource(String path, boolean validate, boolean useClassLoaderResources) { if (validate) { path = validate(path); } // 判断是否允许缓存,这个默认值是true if (isCachingAllowed()) { return cache.getResource(path, useClassLoaderResources); } else { return getResourceInternal(path, useClassLoaderResources); } } ​ 这里分两种情况,一个是从换成里面获取,另外则从非缓存中获取,缓存里面的世界很精彩的. 7.1 从缓存里面获取 // Cache protected WebResource getResource(String path, boolean useClassLoaderResources) { // 省略.... // 判断是否获取到缓存 if (cacheEntry == null) { // Local copy to ensure consistency int objectMaxSizeBytes = getObjectMaxSizeBytes(); // 创建缓存对象 CachedResource newCacheEntry = new CachedResource(this, root, path, getTtl(), objectMaxSizeBytes, useClassLoaderResources); // Concurrent callers will end up with the same CachedResource // instance // 放入缓存中 cacheEntry = resourceCache.putIfAbsent(path, newCacheEntry); // 二次判断 if (cacheEntry == null) { // newCacheEntry was inserted into the cache - validate it cacheEntry = newCacheEntry; // 验证资源的合法性(这里就石锤了) cacheEntry.validateResource(useClassLoaderResources); // 省略.... return cacheEntry; } ​ 还差2步 // CachedResource protected boolean validateResource(boolean useClassLoaderResources) { // 省略.. // 非空检查 if (webResource == null) { // 加锁 synchronized (this) { // 双重检查 if (webResource == null) { webResource = root.getResourceInternal( webAppPath, useClassLoaderResources); getLastModified(); getContentLength(); nextCheck = ttl + now; // exists() is a relatively expensive check for a file so // use the fact that we know if it exists at this point if (webResource instanceof EmptyResource) { cachedExists = Boolean.FALSE; } else { cachedExists = Boolean.TRUE; } return true; } } } } ​ 程序初次允许的时候,webResource肯定是为空的,别说缓存了.这里的root是StandardRoot,又调用回去了. // StandardRoot private final List&amp;lt;List&amp;lt;WebResourceSet&amp;gt;&amp;gt; allResources = new ArrayList&amp;lt;&amp;gt;(); { allResources.add(preResources); allResources.add(mainResources); allResources.add(classResources); allResources.add(jarResources); allResources.add(postResources); } protected final WebResource getResourceInternal(String path, boolean useClassLoaderResources) { WebResource result = null; WebResource virtual = null; WebResource mainEmpty = null; for (List&amp;lt;WebResourceSet&amp;gt; list : allResources) { for (WebResourceSet webResourceSet : list) { if (!useClassLoaderResources &amp;amp;&amp;amp; !webResourceSet.getClassLoaderOnly() || useClassLoaderResources &amp;amp;&amp;amp; !webResourceSet.getStaticOnly()) { result = webResourceSet.getResource(path); if (result.exists()) { return result; } if (virtual == null) { if (result.isVirtual()) { virtual = result; } else if (main.equals(webResourceSet)) { mainEmpty = result; } } } } } // 省略... // Default is empty resource in main resources return mainEmpty; } ​ 这里遍历不同资源类别,来判断文件是否存在,如果存在就返回,然后放入缓存中.至于从非缓存中获取的逻辑就上面getResourceInternal的逻辑,就不罗嗦了. ​ 嗯,这个有啥用呢?还是未解决404的问题呀,别急快了. 八、被遗忘的静态资源监听器(StaticResourceConfigurer) ​ 少侠是否记得在创建tomcat的时候在servletContext中添加了个这个监听器呢? // TomcatServletWebServerFactory protected void prepareContext(Host host, ServletContextInitializer[] initializers) { // 省略... context.addLifecycleListener(new StaticResourceConfigurer(context)); // 省略... } ​ 再来看看这个监听器的逻辑吧. // TomcatServletWebServerFactory$StaticResourceConfigurer private final class StaticResourceConfigurer implements LifecycleListener { private final Context context; private StaticResourceConfigurer(Context context) { this.context = context; } @Override public void lifecycleEvent(LifecycleEvent event) { if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) { addResourceJars(getUrlsOfJarsWithMetaInfResources()); } } private void addResourceJars(List&amp;lt;URL&amp;gt; resourceJarUrls) { for (URL url : resourceJarUrls) { String path = url.getPath(); if (path.endsWith(&quot;.jar&quot;) || path.endsWith(&quot;.jar!/&quot;)) { String jar = url.toString(); if (!jar.startsWith(&quot;jar:&quot;)) { // A jar file in the file system. Convert to Jar URL. jar = &quot;jar:&quot; + jar + &quot;!/&quot;; } addResourceSet(jar); } else { addResourceSet(url.toString()); } } } private void addResourceSet(String resource) { try { if (isInsideNestedJar(resource)) { // It's a nested jar but we now don't want the suffix because Tomcat // is going to try and locate it as a root URL (not the resource // inside it) resource = resource.substring(0, resource.length() - 2); } URL url = new URL(resource); String path = &quot;/META-INF/resources&quot;; this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, &quot;/&quot;, url, path); } catch (Exception ex) { // Ignore (probably not a directory) } } private boolean isInsideNestedJar(String dir) { return dir.indexOf(&quot;!/&quot;) &amp;lt; dir.lastIndexOf(&quot;!/&quot;); } } ​ 无论逻辑怎么变化,最后监听器的代码都会走到this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, &quot;/&quot;, url, path);这句话来. ​ 看到ResourceSetType.RESOURCE_JAR这个常量是否有点感觉呢?没感觉就脱掉衣服再看看. // StandardRoot public void createWebResourceSet(ResourceSetType type, String webAppMount, URL url, String internalPath) { BaseLocation baseLocation = new BaseLocation(url); createWebResourceSet(type, webAppMount, baseLocation.getBasePath(), baseLocation.getArchivePath(), internalPath); } @Override public void createWebResourceSet(ResourceSetType type, String webAppMount, String base, String archivePath, String internalPath) { List&amp;lt;WebResourceSet&amp;gt; resourceList; WebResourceSet resourceSet; switch (type) { case PRE: resourceList = preResources; break; case CLASSES_JAR: resourceList = classResources; break; case RESOURCE_JAR: resourceList = jarResources; break; case POST: resourceList = postResources; break; default: throw new IllegalArgumentException( sm.getString(&quot;standardRoot.createUnknownType&quot;, type)); } // 省略 resourceList.add(resourceSet); } ​ 是不是这一切都园回去了？是不是感觉疑惑都没了?如果还是不解在去看看资源解析的那块儿. 九、真相 ​ 为甚么是404呢?那是因为在StandardRoot里面的resourceList中不存在指定的根路径,所以是404.又要有小伙伴要杠了,说MATE-INFO目录下面的都没问题. ​ 是,没问题.因为springBoot把这个路径加进去了.不信你看. // StaticResourceConfigurer private final class StaticResourceConfigurer implements LifecycleListener { private final Context context; private StaticResourceConfigurer(Context context) { this.context = context; } @Override public void lifecycleEvent(LifecycleEvent event) { if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) { addResourceJars(getUrlsOfJarsWithMetaInfResources()); } } private void addResourceJars(List&amp;lt;URL&amp;gt; resourceJarUrls) { // 省略 } private void addResourceSet(String resource) { // 省略 } private boolean isInsideNestedJar(String dir) { return dir.indexOf(&quot;!/&quot;) &amp;lt; dir.lastIndexOf(&quot;!/&quot;); } } ​ 在getUrlsOfJarsWithMetaInfResources方法里面就有这个路径.逻辑简单就不贴出来了. 9.1 如何解决404 ​ 根据以上的分析,可以和spring一样弄个监听器,在resourceList添加指定的路径.最简单暴力的方法如下: @Controller @EnableAutoConfiguration @Configuration public class Main { public static void main(String[] args) { SpringApplication.run(Main.class,args); } @RequestMapping(&quot;/test-static&quot;) public String testStatic(){ return &quot;index-static&quot;; } @RequestMapping(&quot;/test-public&quot;) public String testPublic(){ return &quot;index-public&quot;; } @RequestMapping(&quot;/test-resources&quot;) public String testResources(){ return &quot;index-resources&quot;; } @RequestMapping(&quot;/test-meta&quot;) public String testMeta(){ return &quot;index-meta&quot;; } @Bean public TomcatServletWebServerFactory getTomcatServletWebServerFactory(){ return new AdvTomcatServletWebServerFactory(); } } 自定义工厂: public class AdvTomcatServletWebServerFactory extends TomcatServletWebServerFactory { private Context context; public AdvTomcatServletWebServerFactory(){ getContextLifecycleListeners().add(new AdvResourceListener()); } // 这个方法是 spring留下的模板方法 // 可以通过这个方法进行扩展 @Override protected void postProcessContext(Context context) { this.context = context; } private class AdvResourceListener implements LifecycleListener{ @Override public void lifecycleEvent(LifecycleEvent event) { if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) { final URL resource = AdvTomcatServletWebServerFactory.class.getClassLoader().getResource(&quot;.&quot;); final WebResourceRoot resources = AdvTomcatServletWebServerFactory.this.context.getResources(); resources.createWebResourceSet(WebResourceRoot.ResourceSetType.RESOURCE_JAR, &quot;/&quot;, resource, &quot;/static&quot;); resources.createWebResourceSet(WebResourceRoot.ResourceSetType.RESOURCE_JAR, &quot;/&quot;, resource, &quot;/public&quot;); resources.createWebResourceSet(WebResourceRoot.ResourceSetType.RESOURCE_JAR, &quot;/&quot;, resource, &quot;/resources&quot;); } } } } ​ 通过自己的工厂替换掉spring的工厂,实现注册自己的监听器,当然方法还有很多,如果你熟悉tomcat的启动流程的话. 十、小结 ​ 在springBoot的懒人套餐下,出现问题往往会让人防不胜防呀,比如这个404,根本没有任何信息说哪里有问题(除非是开了debug日志). ​ 本来就想谢谢解决方案的,结果写了这么多,吃饭了.</summary></entry><entry><title type="html">[断点分析之spring-ioc]-bean属性填充与初始化(九)</title><link href="https://onew.me/spring/2020/03/04/debug-spring-9.html" rel="alternate" type="text/html" title="[断点分析之spring-ioc]-bean属性填充与初始化(九)" /><published>2020-03-04T17:20:25+08:00</published><updated>2020-03-04T17:20:25+08:00</updated><id>https://onew.me/spring/2020/03/04/debug-spring-9</id><content type="html" xml:base="https://onew.me/spring/2020/03/04/debug-spring-9.html"># 一、前言

​	bean是创建好了,但还需要一些属性填充,初始化等操作.

```java
	// 属性填充
	populateBean(beanName, mbd, instanceWrapper);
	// 初始化bean
	exposedObject = initializeBean(beanName, exposedObject, mbd);
```



# 二、populateBean

```java
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
		// 跳过 null bean 赋值
		if (bw == null) {
			if (mbd.hasPropertyValues()) {
				throw new BeanCreationException(
						mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);
			}
			else {
				// Skip property population phase for null instance.
				return;
			}
		}

		// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
		// state of the bean before properties are set. This can be used, for example,
		// to support styles of field injection.
		// 判断是否是拥有InstantiationAwareBeanPostProcessor
		if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
			// 遍历所有BeanPostProcessor
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				// 针对InstantiationAwareBeanPostProcessor 进行调用
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
						return;
					}
				}
			}
		}

		PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);

		// 获取自动注入模式
		int resolvedAutowireMode = mbd.getResolvedAutowireMode();
		// 根据名称 或者 类型 自动注入
		if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
			MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
			// Add property values based on autowire by name if applicable.
			// 处理根据名称注入
			if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
				autowireByName(beanName, mbd, bw, newPvs);
			}
			// Add property values based on autowire by type if applicable.
			// 处理根据类型注入
			if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
				autowireByType(beanName, mbd, bw, newPvs);
			}
			pvs = newPvs;
		}

		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
		// 是否需要依赖检查
		boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

		PropertyDescriptor[] filteredPds = null;
		// BeanPostProcessor 处理
		if (hasInstAwareBpps) {
			if (pvs == null) {
				pvs = mbd.getPropertyValues();
			}
			// 遍历所有的 BeanPostProcessor
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
					if (pvsToUse == null) {
						if (filteredPds == null) {
							filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
						}
						pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
						if (pvsToUse == null) {
							return;
						}
					}
					pvs = pvsToUse;
				}
			}
		}
		// 依赖检查
		if (needsDepCheck) {
			if (filteredPds == null) {
				filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
			}
			checkDependencies(beanName, mbd, filteredPds, pvs);
		}
		// 将属性应用到 bean 中
		if (pvs != null) {
			applyPropertyValues(beanName, mbd, bw, pvs);
		}
	}
```

​	可以看到`InstantiationAwareBeanPostProcessor`对象的调用时机分别是在创建对象后调用了`postProcessAfterInstantiation`方法,在注入完了后调用了`postProcessProperties`方法,随即填充属性.



# 三、initializeBean

```java
protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
		if (System.getSecurityManager() != null) {
			AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
				invokeAwareMethods(beanName, bean);
				return null;
			}, getAccessControlContext());
		}
		else {
			// 对实现Aware接口的类进行注入例如BeanFactoryAware等接口
			invokeAwareMethods(beanName, bean);
		}

		Object wrappedBean = bean;
		if (mbd == null || !mbd.isSynthetic()) {
			// 前置处理
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
		}

		try {
			// 调用用户的init方法
			invokeInitMethods(beanName, wrappedBean, mbd);
		}
		catch (Throwable ex) {
			throw new BeanCreationException(
					(mbd != null ? mbd.getResourceDescription() : null),
					beanName, &quot;Invocation of init method failed&quot;, ex);
		}
		if (mbd == null || !mbd.isSynthetic()) {
			// 后置处理
			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
		}

		return wrappedBean;
	}
```

1. 对实现Aware接口的进行注入
2. 调用PostProcessor的前置方法`postProcessBeforeInitialization`
3. 初始化bean 初始化方法
4. 初始化完毕后调用PostProcessors的后置方法`postProcessAfterInitialization`



单利的创建流程记录完毕,其他scope的创建方式都是大同小异,不再重复记录.



# 四、小结

​	创建的过程终于走完了:)</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">一、前言 ​ bean是创建好了,但还需要一些属性填充,初始化等操作. // 属性填充 populateBean(beanName, mbd, instanceWrapper); // 初始化bean exposedObject = initializeBean(beanName, exposedObject, mbd); 二、populateBean protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) { // 跳过 null bean 赋值 if (bw == null) { if (mbd.hasPropertyValues()) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;); } else { // Skip property population phase for null instance. return; } } // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the // state of the bean before properties are set. This can be used, for example, // to support styles of field injection. // 判断是否是拥有InstantiationAwareBeanPostProcessor if (!mbd.isSynthetic() &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) { // 遍历所有BeanPostProcessor for (BeanPostProcessor bp : getBeanPostProcessors()) { // 针对InstantiationAwareBeanPostProcessor 进行调用 if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { return; } } } } PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null); // 获取自动注入模式 int resolvedAutowireMode = mbd.getResolvedAutowireMode(); // 根据名称 或者 类型 自动注入 if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) { MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // Add property values based on autowire by name if applicable. // 处理根据名称注入 if (resolvedAutowireMode == AUTOWIRE_BY_NAME) { autowireByName(beanName, mbd, bw, newPvs); } // Add property values based on autowire by type if applicable. // 处理根据类型注入 if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) { autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); // 是否需要依赖检查 boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE); PropertyDescriptor[] filteredPds = null; // BeanPostProcessor 处理 if (hasInstAwareBpps) { if (pvs == null) { pvs = mbd.getPropertyValues(); } // 遍历所有的 BeanPostProcessor for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { if (filteredPds == null) { filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { return; } } pvs = pvsToUse; } } } // 依赖检查 if (needsDepCheck) { if (filteredPds == null) { filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } checkDependencies(beanName, mbd, filteredPds, pvs); } // 将属性应用到 bean 中 if (pvs != null) { applyPropertyValues(beanName, mbd, bw, pvs); } } ​ 可以看到InstantiationAwareBeanPostProcessor对象的调用时机分别是在创建对象后调用了postProcessAfterInstantiation方法,在注入完了后调用了postProcessProperties方法,随即填充属性. 三、initializeBean protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) { if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt; { invokeAwareMethods(beanName, bean); return null; }, getAccessControlContext()); } else { // 对实现Aware接口的类进行注入例如BeanFactoryAware等接口 invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { // 前置处理 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } try { // 调用用户的init方法 invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); } if (mbd == null || !mbd.isSynthetic()) { // 后置处理 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean; } 对实现Aware接口的进行注入 调用PostProcessor的前置方法postProcessBeforeInitialization 初始化bean 初始化方法 初始化完毕后调用PostProcessors的后置方法postProcessAfterInitialization 单利的创建流程记录完毕,其他scope的创建方式都是大同小异,不再重复记录. 四、小结 ​ 创建的过程终于走完了:)</summary></entry><entry><title type="html">[断点分析之spring-ioc]-bean的创建(八)</title><link href="https://onew.me/spring/2020/03/04/debug-spring-8.html" rel="alternate" type="text/html" title="[断点分析之spring-ioc]-bean的创建(八)" /><published>2020-03-04T16:20:25+08:00</published><updated>2020-03-04T16:20:25+08:00</updated><id>https://onew.me/spring/2020/03/04/debug-spring-8</id><content type="html" xml:base="https://onew.me/spring/2020/03/04/debug-spring-8.html"># 一、前言

​	经过前面的一顿折腾,终于要到了扯开遮羞布的时候了.

```java
@Test
	public void testSpringLoadXml(){
    // A
		BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBean.xml&quot;));
    // B
		final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);
		final String testStr = testBean.getTestStr();
		System.out.println(testStr);
	}
```

​	前面记录了A这个过程,整个过程总结为:

1. 加载xml文件
2. 解析xml文件
3. 选用合适的handler解析标签
4. 创建bean的定义
5. 注册bean定义



​	那么后面B这一步就是比较重要的一步.



# 二、分析

​	从`MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);`这句代码开始吧,进去看看里面是啥妖魔鬼怪.

```java
// AbstractBeanFactory
@Override
	public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException {
		return doGetBean(name, requiredType, null, false);
	}
	@SuppressWarnings(&quot;unchecked&quot;)
	protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,
			@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

		// 提取 bean name,bean name 可能不是单纯的名称也可能是工厂的名称
		// 例如 &amp;bean 就代表从名称为bean的工厂中获取 bean
		final String beanName = transformedBeanName(name);
		Object bean;

		// Eagerly check singleton cache for manually registered singletons.
		// 通过单利工厂获取 bean
		Object sharedInstance = getSingleton(beanName);
		if (sharedInstance != null &amp;&amp; args == null) {
			if (logger.isTraceEnabled()) {
				if (isSingletonCurrentlyInCreation(beanName)) {
					logger.trace(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName +
							&quot;' that is not fully initialized yet - a consequence of a circular reference&quot;);
				}
				else {
					logger.trace(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;);
				}
			}
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
		}

		else {
			// 如果为原型模式,存在循环依赖则报错
			// Fail if we're already creating this bean instance:
			// We're assumably within a circular reference.
			// 如果是原型模式则不解决循环依赖问题,直接抛出异常
			if (isPrototypeCurrentlyInCreation(beanName)) {
				throw new BeanCurrentlyInCreationException(beanName);
			}
			// 获取父bean工厂
			// Check if bean definition exists in this factory.
			BeanFactory parentBeanFactory = getParentBeanFactory();
			// 通过递归父工厂获取bean对象
			// 如果无bean定义并且还要加载这个bean 说明这个bean已经被加载过了
			if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
				// Not found -&gt; check parent.
				String nameToLookup = originalBeanName(name);
				if (parentBeanFactory instanceof AbstractBeanFactory) {
					return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
							nameToLookup, requiredType, args, typeCheckOnly);
				}
				else if (args != null) {
					// Delegation to parent with explicit args.
					return (T) parentBeanFactory.getBean(nameToLookup, args);
				}
				else if (requiredType != null) {
					// No args -&gt; delegate to standard getBean method.
					return parentBeanFactory.getBean(nameToLookup, requiredType);
				}
				else {
					return (T) parentBeanFactory.getBean(nameToLookup);
				}
			}
			//记录 bean 正在创建中
			if (!typeCheckOnly) {
				markBeanAsCreated(beanName);
			}

			try {
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
				checkMergedBeanDefinition(mbd, beanName, args);

				// Guarantee initialization of beans that the current bean depends on.
				String[] dependsOn = mbd.getDependsOn();
				if (dependsOn != null) {
					for (String dep : dependsOn) {
						if (isDependent(beanName, dep)) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									&quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
						}
						//依赖注册
						registerDependentBean(dep, beanName);
						try {
							//获取bean,循环获取依赖
							getBean(dep);
						}
						catch (NoSuchBeanDefinitionException ex) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									&quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
						}
					}
				}

				// 创建bean实例
				// Create bean instance.
				// 单利模式
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, () -&gt; {
						try {
							return createBean(beanName, mbd, args);
						}
						catch (BeansException ex) {
							// Explicitly remove instance from singleton cache: It might have been put there
							// eagerly by the creation process, to allow for circular reference resolution.
							// Also remove any beans that received a temporary reference to the bean.
							destroySingleton(beanName);
							throw ex;
						}
					});
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
				}
				// 原型模式
				else if (mbd.isPrototype()) {
					// It's a prototype -&gt; create a new instance.
					Object prototypeInstance = null;
					try {
						// 前置处理
						beforePrototypeCreation(beanName);
						// 创建bean
						prototypeInstance = createBean(beanName, mbd, args);
					}
					finally {
						// 后置处理
						afterPrototypeCreation(beanName);
					}
					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
				}

				else {
					// 其他作用域
					String scopeName = mbd.getScope();
					final Scope scope = this.scopes.get(scopeName);
					if (scope == null) {
						throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;);
					}
					try {
						Object scopedInstance = scope.get(beanName, () -&gt; {
							// 前置处理
							beforePrototypeCreation(beanName);
							try {
								// 创建 bean
								return createBean(beanName, mbd, args);
							}
							finally {
								// 后置处理
								afterPrototypeCreation(beanName);
							}
						});
						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
					}
					catch (IllegalStateException ex) {
						throw new BeanCreationException(beanName,
								&quot;Scope '&quot; + scopeName + &quot;' is not active for the current thread; consider &quot; +
								&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
								ex);
					}
				}
			}
			catch (BeansException ex) {
				cleanupAfterBeanCreationFailure(beanName);
				throw ex;
			}
		}

		//类型转换
		// Check if required type matches the type of the actual bean instance.
		if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {
			try {
				T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
				if (convertedBean == null) {
					throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
				}
				return convertedBean;
			}
			catch (TypeMismatchException ex) {
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Failed to convert bean '&quot; + name + &quot;' to required type '&quot; +
							ClassUtils.getQualifiedName(requiredType) + &quot;'&quot;, ex);
				}
				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
			}
		}
		return (T) bean;
	}
```

​	代码很长,看起来比较费劲.拆分来看看。

```java
// AbstractBeanFactory
// 提取 bean name,bean name 可能不是单纯的名称也可能是工厂的名称
		// 例如 &amp;bean 就代表从名称为bean的工厂中获取 bean
final String beanName = transformedBeanName(name);
		Object bean;

		// Eagerly check singleton cache for manually registered singletons.
		// 通过单利工厂获取 bean
		Object sharedInstance = getSingleton(beanName);
		if (sharedInstance != null &amp;&amp; args == null) {
			if (logger.isTraceEnabled()) {
				if (isSingletonCurrentlyInCreation(beanName)) {
					logger.trace(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName +
							&quot;' that is not fully initialized yet - a consequence of a circular reference&quot;);
				}
				else {
					logger.trace(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;);
				}
			}
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
		}

```

1. 获取bean的真实名称
2. 获取bean



​	这部分分成3句代码

1. `String beanName = transformedBeanName(name);`
2. `Object sharedInstance = getSingleton(beanName);`
3. `bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);`



## 2.1 transformedBeanName

```java
// AbstractBeanFactory
protected String transformedBeanName(String name) {
		return canonicalName(BeanFactoryUtils.transformedBeanName(name));
	}
// BeanFactoryUtils
public static String transformedBeanName(String name) {
		Assert.notNull(name, &quot;'name' must not be null&quot;);
		// 判断是否是以&amp; 开头的名称
		if (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {
			return name;
		}
		// 名称-&gt;真实名称 放入换成中
		// 不停的循环截取&amp;后面的部分,直到不以&amp;开头为止
		return transformedBeanNameCache.computeIfAbsent(name, beanName -&gt; {
			do {
				beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());
			}
			while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));
			return beanName;
		});
	}
// AbstractBeanFactory
public String canonicalName(String name) {
		String canonicalName = name;
		// Handle aliasing...
		String resolvedName;
		// 判断bean的名称是否是别名
		// 一直循环 跟着别名的引用链走
		// 直到非别名为止
		// 例如 A-B-C-D-E-F
		// 从A找到F
		do {
			resolvedName = this.aliasMap.get(canonicalName);
			if (resolvedName != null) {
				canonicalName = resolvedName;
			}
		}
		while (resolvedName != null);
		return canonicalName;
	}

```

1. 先判断是否是以&amp;开头,这个符号代表着引用的意思,在c/c++里面估计会很熟悉.
2. 判断是否是别名
3. 返回最终确定下来的bean名称



## 2.2 &amp; 符号的作用

```java

public class MyTestFactoryBean implements FactoryBean&lt;MyTestBean&gt; {
	@Override
	public MyTestBean getObject() throws Exception {
		return new MyTestBean();
	}

	@Override
	public Class&lt;?&gt; getObjectType() {
		return MyTestBean.class;
	}

	@Override
	public boolean isSingleton() {
		return true;
	}
}

```



```java
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                       https://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;
	&lt;bean id=&quot;myTestBeanFactory&quot; class=&quot;com.sjr.test.bean.MyTestFactoryBean&quot;/&gt;
&lt;/beans&gt;

```



```java

public class TestSpringFactoryBean {

	@Test
	public void testFactoryBean() {
		BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBeanFactory.xml&quot;));
		final Object bean = factory.getBean(&quot;myTestBeanFactory&quot;);
		System.out.println(bean.getClass().getName());
		final Object bean1 = factory.getBean(&quot;&amp;myTestBeanFactory&quot;);
		System.out.println(bean1.getClass().getName());
	}
}

```

最后结果输出为:

```properties
com.sjr.test.bean.MyTestBean
com.sjr.test.bean.MyTestFactoryBean
```

​	从结果上来应该秒懂吧,如果一`FactoryBean`对象在spring创建的时候会判断bean名称,如果bean名称中不带有&amp;符号,说明是要获取`FactoryBean`所产生的对象,如果带有&amp;符号,则说明需要获取`FactoryBean`对象本身.

## 2.2 getSingleton

```java
// DefaultSingletonBeanRegistry
@Override
	@Nullable
	public Object getSingleton(String beanName) {
		return getSingleton(beanName, true);
	}

@Nullable
	protected Object getSingleton(String beanName, boolean allowEarlyReference) {
		// 缓存中是否有创建好的bean
		Object singletonObject = this.singletonObjects.get(beanName);
		// 缓存中无指定的bean并且该bean未在创建中
		if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
			// 加锁 
			synchronized (this.singletonObjects) {
				// 指定的bean是否在创建中
				singletonObject = this.earlySingletonObjects.get(beanName);
				// 非创建中,并且允许提前引用
				if (singletonObject == null &amp;&amp; allowEarlyReference) {
					// 获取单利工厂
					ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
					if (singletonFactory != null) {
						// 调用工厂创建对象
						singletonObject = singletonFactory.getObject();
						// 把创建好的对象放入到正在创建的集合中去
						this.earlySingletonObjects.put(beanName, singletonObject);
						// 移除单利工厂
						this.singletonFactories.remove(beanName);
					}
				}
			}
		}
		return singletonObject;
	}
```

​	逻辑比较简单,这里有几个map 比较重要:

1. singletonObjects 用于保存BeanName和创建bean实例之间的关系 beanName-&gt;bean
2. earlySingletonObjects 用于保存BeanName和创建bean实例之间的关系 beanName-&gt;bean,不同点是,当bean放入到此集合中时,在bean创建的过程中就可以通 过getBean方法来获取bean的引用,主要是用于解决循环依赖问题.
3. singletonFactories:用于保存beanName与bean工厂之间的关系
4. registeredSingletons:用来保存当前所有已注册的bean



​	如果bean名称是工厂的名称,那么这里已经完成了bean的创建了,但仅仅是创建完成还是不够,spring还要插上一脚进行管理.



## 2.3 getObjectForBeanInstance

```java
protected Object getObjectForBeanInstance(
			Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {

		// Don't let calling code try to dereference the factory if the bean isn't a factory.
		// 检查bean名称是否符合bean工厂的命名规范,如果名称是工厂的格式,则获取的bean为工厂实例
		if (BeanFactoryUtils.isFactoryDereference(name)) {
			// 符合规范但是个null
			if (beanInstance instanceof NullBean) {
				return beanInstance;
			}
			// 符合规范但不是factory,异常
			if (!(beanInstance instanceof FactoryBean)) {
				throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass());
			}
			// 如果bean定义不为空,设置为true表明是个工厂bean
			if (mbd != null) {
				mbd.isFactoryBean = true;
			}
			return beanInstance;
		}

		// Now we have the bean instance, which may be a normal bean or a FactoryBean.
		// If it's a FactoryBean, we use it to create a bean instance, unless the
		// caller actually wants a reference to the factory.
		// 如果bean实例为非工厂,直接返回
		if (!(beanInstance instanceof FactoryBean)) {
			return beanInstance;
		}

		// 后面的逻辑是bean是工厂,而名称则不是工厂的解引用格式
		Object object = null;
		if (mbd != null) {
			mbd.isFactoryBean = true;
		}
		else {
			// 从缓存中获取对象对应的工厂bean
			object = getCachedObjectForFactoryBean(beanName);
		}
		if (object == null) {
			// Return bean instance from factory.
			FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;
			// Caches object obtained from FactoryBean if it is a singleton.
			if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) {
				mbd = getMergedLocalBeanDefinition(beanName);
			}
			boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());
			object = getObjectFromFactoryBean(factory, beanName, !synthetic);
		}
		return object;
	}
```

1. 如果bean的名称以&amp; 开头并且是`FactoryBean`子类,直接返回工厂对象
2. 如果bean的名称非以&amp;开头并且非`FactoryBean`子类直接返回对象
3. 如果bean的名称非以&amp;开头并且是`FactoryBean`子类调用`FactoryBean`的getObject方法获取对象



以上代码中的核心代码有三处:

1. getCachedObjectForFactoryBean()
2. getMergedLocalBeanDefinition()
3. getObjectFromFactoryBean()



## 2.4 getCachedObjectForFactoryBean

```java
@Nullable
	protected Object getCachedObjectForFactoryBean(String beanName) {
		return this.factoryBeanObjectCache.get(beanName);
	}
```

​	代码很简单,就是根据beanName在换成中获取对应的bean

## 2.5 getMergedLocalBeanDefinition

```java
// AbstractBeanFactory
protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException {
		// Quick check on the concurrent map first, with minimal locking.
		// 从缓存中获取
		RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName);
		if (mbd != null &amp;&amp; !mbd.stale) {
			return mbd;
		}
		return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));
	}
protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd)
			throws BeanDefinitionStoreException {

		return getMergedBeanDefinition(beanName, bd, null);
	}

protected RootBeanDefinition getMergedBeanDefinition(
			String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)
			throws BeanDefinitionStoreException {
		// 加锁,并发控制
		synchronized (this.mergedBeanDefinitions) {
			RootBeanDefinition mbd = null;
			RootBeanDefinition previous = null;

			// Check with full lock now in order to enforce the same merged instance.
			if (containingBd == null) {
				// 如果为空 从缓存中获取
				mbd = this.mergedBeanDefinitions.get(beanName);
			}
			
			
			if (mbd == null || mbd.stale) {
				previous = mbd;
				// 判断是否具有父子关系
				if (bd.getParentName() == null) {
					// Use copy of given root bean definition.
					// 判断类型是否是 RootBeanDefinition
					if (bd instanceof RootBeanDefinition) {
						// copy一个
						mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();
					}
					else {
						// 转换为 RootBeanDefinition
						mbd = new RootBeanDefinition(bd);
					}
				}
				else {
					// Child bean definition: needs to be merged with parent.
					BeanDefinition pbd;
					try {
						// 获取 父bean 名称
						String parentBeanName = transformedBeanName(bd.getParentName());
						// 判断父与子的bean 名称是否相同
						if (!beanName.equals(parentBeanName)) {
							// 如果不相同,则顺则 父子关系 一路递归上去
							// 全部转换为 RootBeanDefinition
							pbd = getMergedBeanDefinition(parentBeanName);
						}
						else {
							// 和上面代码逻辑相同 只是类型不一样
							BeanFactory parent = getParentBeanFactory();
							if (parent instanceof ConfigurableBeanFactory) {
								pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);
							}
							else {
								throw new NoSuchBeanDefinitionException(parentBeanName,
										&quot;Parent name '&quot; + parentBeanName + &quot;' is equal to bean name '&quot; + beanName +
										&quot;': cannot be resolved without an AbstractBeanFactory parent&quot;);
							}
						}
					}
					catch (NoSuchBeanDefinitionException ex) {
						throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName,
								&quot;Could not resolve parent bean definition '&quot; + bd.getParentName() + &quot;'&quot;, ex);
					}
					// Deep copy with overridden values.
					// 深拷贝 转换为RootBeanDefinition
					mbd = new RootBeanDefinition(pbd);
					mbd.overrideFrom(bd);
				}

				// Set default singleton scope, if not configured before.
				if (!StringUtils.hasLength(mbd.getScope())) {
					mbd.setScope(SCOPE_SINGLETON);
				}

				// A bean contained in a non-singleton bean cannot be a singleton itself.
				// Let's correct this on the fly here, since this might be the result of
				// parent-child merging for the outer bean, in which case the original inner bean
				// definition will not have inherited the merged outer bean's singleton status.
				if (containingBd != null &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) {
					mbd.setScope(containingBd.getScope());
				}

				// Cache the merged bean definition for the time being
				// (it might still get re-merged later on in order to pick up metadata changes)
				if (containingBd == null &amp;&amp; isCacheBeanMetadata()) {
					// 加入缓存
					this.mergedBeanDefinitions.put(beanName, mbd);
				}
			}
			if (previous != null) {
				copyRelevantMergedBeanDefinitionCaches(previous, mbd);
			}
			return mbd;
		}
	}

```

​	说这代码之前,先说说spring中的基本数据结构.在spring中基本数据结构为`BeanDefinition`,通过spring产生的普通bean为`GenericBeanDefinition`.而spring后续处理的类型则为`RootBeanDefinition`.关系图如下:

![images](https://gitee.com/oneww/onew_image/raw/master/BeanDefinition.png)

​	这两个长的都差不多,只不过后续处理的步骤用到的类型为`RootBeanDefinition`,所以在上面的方法中,进行递归转换.

## 2.6 getObjectFromFactoryBean

```java
// AbstractBeanFactory
boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());
object = getObjectFromFactoryBean(factory, beanName, !synthetic);
```

​	这里这个`isSynthetic`方法代表是否是人造的,emma就这样理解吧.什么叫做人造的呢?意思就是不加干预通spring产生的就是非人造的,如果是后面通过代理产生的就是非人造的.

​	看了一下setSynthetic这个方法的调用情况,都是在aop那边调用的比较多.不知道解释的对不对哈.

```java
// FactoryBeanRegistrySupport
protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) {
		// 判断工厂是否为单利工厂,并且单利对象已被创建完成
		if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) {
			// 加锁
			synchronized (getSingletonMutex()) {
				// 在缓存中获取通过工厂创建的bean
				Object object = this.factoryBeanObjectCache.get(beanName);
				if (object == null) {
					// 获取bean通过工厂
					object = doGetObjectFromFactoryBean(factory, beanName);
					// Only post-process and store if not put there already during getObject() call above
					// (e.g. because of circular reference processing triggered by custom getBean calls)
					// 再次从缓存中获取bean
					Object alreadyThere = this.factoryBeanObjectCache.get(beanName);
					if (alreadyThere != null) {
						// 如果缓存中获取到bean,则丢弃当前创建的对象
						object = alreadyThere;
					}
					else {
						// 判断是否需要post-processing
						if (shouldPostProcess) {
							// 当前的bean是否被创建中,如果是就直接返回当前的bean不做处理
							if (isSingletonCurrentlyInCreation(beanName)) {
								// Temporarily return non-post-processed object, not storing it yet..
								return object;
							}
							// bean创建之前,把当前bean加入正在创建中的集合中去
							beforeSingletonCreation(beanName);
							try {
								// AOP的核心步骤
								object = postProcessObjectFromFactoryBean(object, beanName);
							}
							catch (Throwable ex) {
								throw new BeanCreationException(beanName,
										&quot;Post-processing of FactoryBean's singleton object failed&quot;, ex);
							}
							finally {
								// bean创建之后,把bean从正在创建中的集合中移除
								afterSingletonCreation(beanName);
							}
						}
						if (containsSingleton(beanName)) {
							// 缓存bean对象
							this.factoryBeanObjectCache.put(beanName, object);
						}
					}
				}
				return object;
			}
		}
		else {
			//创建对象
			Object object = doGetObjectFromFactoryBean(factory, beanName);
			if (shouldPostProcess) {
				try {
					//处理bean流程
					object = postProcessObjectFromFactoryBean(object, beanName);
				}
				catch (Throwable ex) {
					throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean's object failed&quot;, ex);
				}
			}
			return object;
		}
	}
```

1. 判断是否是单利工厂,并且缓存中已经创建了该bean的factoryBean
2. 判断factoryBeanObjectCache缓存中bean是否存在
3. 通过factoryBean创建bean



​	以上逻辑为当有factoryBean的逻辑.

# 三、后半段逻辑

```java
//AbstractBeanFactory
			// 如果为原型模式,存在循环依赖则报错
			// Fail if we're already creating this bean instance:
			// We're assumably within a circular reference.
			// 如果是原型模式则不解决循环依赖问题,直接抛出异常
			if (isPrototypeCurrentlyInCreation(beanName)) {
				throw new BeanCurrentlyInCreationException(beanName);
			}
			// 获取父bean工厂
			// Check if bean definition exists in this factory.
			BeanFactory parentBeanFactory = getParentBeanFactory();
			// 通过递归父工厂获取bean对象
			// 如果无bean定义并且还要加载这个bean 说明这个bean已经被加载过了
			if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
				// Not found -&gt; check parent.
				String nameToLookup = originalBeanName(name);
				if (parentBeanFactory instanceof AbstractBeanFactory) {
					return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
							nameToLookup, requiredType, args, typeCheckOnly);
				}
				else if (args != null) {
					// Delegation to parent with explicit args.
					return (T) parentBeanFactory.getBean(nameToLookup, args);
				}
				else if (requiredType != null) {
					// No args -&gt; delegate to standard getBean method.
					return parentBeanFactory.getBean(nameToLookup, requiredType);
				}
				else {
					return (T) parentBeanFactory.getBean(nameToLookup);
				}
			}
```

​	如果非单利模式,spring在这里不处理循环依赖问题.如果`BeanFactory`存在父子关系,则进行递归创建.

```java
// AbstractBeanFactory
// 记录 bean 正在创建中
			if (!typeCheckOnly) {
				markBeanAsCreated(beanName);
			}
// 转换BeanDefinition为RootBeanDefinition
final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
			// 检查RootBeanDefinition是否合法
				checkMergedBeanDefinition(mbd, beanName, args);

				// Guarantee initialization of beans that the current bean depends on.
				// 遍历所有依赖,并进行注册、创建等过程
				String[] dependsOn = mbd.getDependsOn();
				if (dependsOn != null) {
					for (String dep : dependsOn) {
						if (isDependent(beanName, dep)) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									&quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
						}
						// 依赖注册
						registerDependentBean(dep, beanName);
						try {
							// 获取bean,循环获取依赖
							getBean(dep);
						}
						catch (NoSuchBeanDefinitionException ex) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									&quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
						}
					}
				}

				// 创建bean实例
				// Create bean instance.
				// 单利模式
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, () -&gt; {
						try {
							return createBean(beanName, mbd, args);
						}
						catch (BeansException ex) {
							// Explicitly remove instance from singleton cache: It might have been put there
							// eagerly by the creation process, to allow for circular reference resolution.
							// Also remove any beans that received a temporary reference to the bean.
							destroySingleton(beanName);
							throw ex;
						}
					});
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
				}			
```

1. 标记该bean未正在创建中.

   ```java
   // AbstractBeanFactory
   protected void markBeanAsCreated(String beanName) {
   		// 判断是否包含beanName
   		if (!this.alreadyCreated.contains(beanName)) {
   			// 加锁并发控制
   			synchronized (this.mergedBeanDefinitions) {
   				// 双重检查
   				if (!this.alreadyCreated.contains(beanName)) {
   					// Let the bean definition get re-merged now that we're actually creating
   					// the bean... just in case some of its metadata changed in the meantime.
   					clearMergedBeanDefinition(beanName);
   					// 添加进行已经创建集合中
   					this.alreadyCreated.add(beanName);
   				}
   			}
   		}
   	}
   ```

2. 遍历依赖并进行递归创建

   ```java
   // AbstractBeanFactory
   			if (dependsOn != null) {
   					for (String dep : dependsOn) {
   						if (isDependent(beanName, dep)) {
   							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
   									&quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
   						}
   						//依赖注册
   						registerDependentBean(dep, beanName);
   						try {
   							//获取bean,循环获取依赖
   							getBean(dep);
   						}
   						catch (NoSuchBeanDefinitionException ex) {
   							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
   									&quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
   						}
   					}
   				}
   ```



​	这里的核心逻辑在于`getSingleton`这个方法里



### 3.1 getSingleton

```java
// AbstractBeanFactory
public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
		Assert.notNull(beanName, &quot;Bean name must not be null&quot;);
		// 加锁
		synchronized (this.singletonObjects) {
			// 从缓存中获取 bean
			Object singletonObject = this.singletonObjects.get(beanName);
			// 如果缓存中没有
			if (singletonObject == null) {
        // 判断当前bean是否被标记为销毁
        // 相当于不能在destrory方法里面再去创建这个bean
				if (this.singletonsCurrentlyInDestruction) {
					throw new BeanCreationNotAllowedException(beanName,
							&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +
							&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);
				}
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Creating shared instance of singleton bean '&quot; + beanName + &quot;'&quot;);
				}
				// 开始创建 bean
				// 添加到 创建中集合中去
				// 前置处理
				beforeSingletonCreation(beanName);
				boolean newSingleton = false;
				boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
				if (recordSuppressedExceptions) {
					this.suppressedExceptions = new LinkedHashSet&lt;&gt;();
				}
				try {
					// 从工厂中获取 bean
					singletonObject = singletonFactory.getObject();
					newSingleton = true;
				}
				catch (IllegalStateException ex) {
					// Has the singleton object implicitly appeared in the meantime -&gt;
					// if yes, proceed with it since the exception indicates that state.
					singletonObject = this.singletonObjects.get(beanName);
					if (singletonObject == null) {
						throw ex;
					}
				}
				catch (BeanCreationException ex) {
					if (recordSuppressedExceptions) {
						for (Exception suppressedException : this.suppressedExceptions) {
							ex.addRelatedCause(suppressedException);
						}
					}
					throw ex;
				}
				finally {
					if (recordSuppressedExceptions) {
						this.suppressedExceptions = null;
					}
					// 移除创建中的集合
					afterSingletonCreation(beanName);
				}
				if (newSingleton) {
					// 放入缓存
					addSingleton(beanName, singletonObject);
				}
			}
			return singletonObject;
		}
	}
```

1. 从缓存中获取bean
2. 如果换成中没有,则判断当前的bean是否被记被销毁
3. 在创建之前把beanName加入正在创建的缓存中去
4. 从单利工厂中创建bean
5. 从正在创建的换成中移除beanName
6. 把创建好的singletonObject加入缓存中



值得注意的是这里的`singletonFactory`对象是通过Lambda表达传入进来的

```java
// AbstractBeanFactory
sharedInstance = getSingleton(beanName, () -&gt; {
						try {
							return createBean(beanName, mbd, args);
						}
						catch (BeansException ex) {
							// Explicitly remove instance from singleton cache: It might have been put there
							// eagerly by the creation process, to allow for circular reference resolution.
							// Also remove any beans that received a temporary reference to the bean.
							destroySingleton(beanName);
							throw ex;
						}
					});
```

这里的核心逻辑代码是`createBean(beanName, mbd, args)`



### 3.2 createBean

```java
// AbstractAutowireCapableBeanFactory
@Override
	protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
			throws BeanCreationException {

		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Creating instance of bean '&quot; + beanName + &quot;'&quot;);
		}
		RootBeanDefinition mbdToUse = mbd;

		// Make sure bean class is actually resolved at this point, and
		// clone the bean definition in case of a dynamically resolved Class
		// which cannot be stored in the shared merged bean definition.
		// 根据类名加载class对象
		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
		if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {
			mbdToUse = new RootBeanDefinition(mbd);
			mbdToUse.setBeanClass(resolvedClass);
		}

		// Prepare method overrides.
		try {
			// 匹配需要覆盖的方法
			mbdToUse.prepareMethodOverrides();
		}
		catch (BeanDefinitionValidationException ex) {
			throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
					beanName, &quot;Validation of method overrides failed&quot;, ex);
		}

		try {
			// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
			// 返回一个代理对象,也可能是非代理对象
			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
			if (bean != null) {
				return bean;
			}
		}
		catch (Throwable ex) {
			throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
					&quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);
		}

		try {
			// 创建bean
			Object beanInstance = doCreateBean(beanName, mbdToUse, args);
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;);
			}
			return beanInstance;
		}
		catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
			// A previously detected exception with proper bean creation context already,
			// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.
			throw ex;
		}
		catch (Throwable ex) {
			throw new BeanCreationException(
					mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);
		}
	}
```

1. 加载class
2. 判断该bean是否需要`InstantiationAwareBeanPostProcessor`进行处理,这个接口与`BeanPostProcessor`不同,主要区别是在调用时机上的区别,`InstantiationAwareBeanPostProcessor`会在对象创建前进行调用,而`BeanPostProcessor`会在对象初始化前后进行调用,这个可以从doCreateBean看出时机的差别.
3. 创建对象



### 3.3 doCreateBean

```java
// AbstractAutowireCapableBeanFactory
protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
			throws BeanCreationException {

		// Instantiate the bean.
		BeanWrapper instanceWrapper = null;
		if (mbd.isSingleton()) {
			// 从缓存中获取实例wrapper,并移除它
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
		}
		// 如果没有获取到实例的wrapper,则创建一个实例
		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
		}
		final Object bean = instanceWrapper.getWrappedInstance();
		Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
		if (beanType != NullBean.class) {
			mbd.resolvedTargetType = beanType;
		}

		// Allow post-processors to modify the merged bean definition.
		// 判断是否有 后置处理器
		// 加锁
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				try {
					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
				}
				catch (Throwable ex) {
					throw new BeanCreationException(mbd.getResourceDescription(), beanName,
							&quot;Post-processing of merged bean definition failed&quot;, ex);
				}
				mbd.postProcessed = true;
			}
		}

		// 是否允许循环引用
		// Eagerly cache singletons to be able to resolve circular references
		// even when triggered by lifecycle interfaces like BeanFactoryAware.
		boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;Eagerly caching bean '&quot; + beanName +
						&quot;' to allow for resolving potential circular references&quot;);
			}
			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
		}

		// Initialize the bean instance.
		Object exposedObject = bean;
		try {
			// 填充bean属性
			populateBean(beanName, mbd, instanceWrapper);
			// 初始化bean
			exposedObject = initializeBean(beanName, exposedObject, mbd);
		}
		catch (Throwable ex) {
			if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
				throw (BeanCreationException) ex;
			}
			else {
				throw new BeanCreationException(
						mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
			}
		}
		// 循环依赖处理
		if (earlySingletonExposure) {
			// 获取单利对象
			Object earlySingletonReference = getSingleton(beanName, false);
			if (earlySingletonReference != null) {
				if (exposedObject == bean) {
					exposedObject = earlySingletonReference;
				}
				else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
					String[] dependentBeans = getDependentBeans(beanName);
					Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
					for (String dependentBean : dependentBeans) {
						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
							actualDependentBeans.add(dependentBean);
						}
					}
					if (!actualDependentBeans.isEmpty()) {
						throw new BeanCurrentlyInCreationException(beanName,
								&quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; +
								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
								&quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
								&quot;wrapped. This means that said other beans do not use the final version of the &quot; +
								&quot;bean. This is often the result of over-eager type matching - consider using &quot; +
								&quot;'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.&quot;);
					}
				}
			}
		}

		// Register bean as disposable.
		try {
			// 注册销毁处理器
			registerDisposableBeanIfNecessary(beanName, bean, mbd);
		}
		catch (BeanDefinitionValidationException ex) {
			throw new BeanCreationException(
					mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
		}

		return exposedObject;
	}
```

​	进过以上骚操作就完成了bean的创建,在创建的过程中还会有属性的填充,bean的初始化等.



# 四、小结

​	继续bean的初始化,与属性的填充.</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">一、前言 ​ 经过前面的一顿折腾,终于要到了扯开遮羞布的时候了. @Test public void testSpringLoadXml(){ // A BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBean.xml&quot;)); // B final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class); final String testStr = testBean.getTestStr(); System.out.println(testStr); } ​ 前面记录了A这个过程,整个过程总结为: 加载xml文件 解析xml文件 选用合适的handler解析标签 创建bean的定义 注册bean定义 ​ 那么后面B这一步就是比较重要的一步. 二、分析 ​ 从MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);这句代码开始吧,进去看看里面是啥妖魔鬼怪. // AbstractBeanFactory @Override public &amp;lt;T&amp;gt; T getBean(String name, Class&amp;lt;T&amp;gt; requiredType) throws BeansException { return doGetBean(name, requiredType, null, false); } @SuppressWarnings(&quot;unchecked&quot;) protected &amp;lt;T&amp;gt; T doGetBean(final String name, @Nullable final Class&amp;lt;T&amp;gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { // 提取 bean name,bean name 可能不是单纯的名称也可能是工厂的名称 // 例如 &amp;amp;bean 就代表从名称为bean的工厂中获取 bean final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. // 通过单利工厂获取 bean Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;amp;&amp;amp; args == null) { if (logger.isTraceEnabled()) { if (isSingletonCurrentlyInCreation(beanName)) { logger.trace(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName + &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;); } else { logger.trace(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;); } } bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } else { // 如果为原型模式,存在循环依赖则报错 // Fail if we're already creating this bean instance: // We're assumably within a circular reference. // 如果是原型模式则不解决循环依赖问题,直接抛出异常 if (isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } // 获取父bean工厂 // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); // 通过递归父工厂获取bean对象 // 如果无bean定义并且还要加载这个bean 说明这个bean已经被加载过了 if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) { // Not found -&amp;gt; check parent. String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) { return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); } else if (args != null) { // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); } else if (requiredType != null) { // No args -&amp;gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); } else { return (T) parentBeanFactory.getBean(nameToLookup); } } //记录 bean 正在创建中 if (!typeCheckOnly) { markBeanAsCreated(beanName); } try { final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) { for (String dep : dependsOn) { if (isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;); } //依赖注册 registerDependentBean(dep, beanName); try { //获取bean,循环获取依赖 getBean(dep); } catch (NoSuchBeanDefinitionException ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex); } } } // 创建bean实例 // Create bean instance. // 单利模式 if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -&amp;gt; { try { return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } // 原型模式 else if (mbd.isPrototype()) { // It's a prototype -&amp;gt; create a new instance. Object prototypeInstance = null; try { // 前置处理 beforePrototypeCreation(beanName); // 创建bean prototypeInstance = createBean(beanName, mbd, args); } finally { // 后置处理 afterPrototypeCreation(beanName); } bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } else { // 其他作用域 String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) { throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;); } try { Object scopedInstance = scope.get(beanName, () -&amp;gt; { // 前置处理 beforePrototypeCreation(beanName); try { // 创建 bean return createBean(beanName, mbd, args); } finally { // 后置处理 afterPrototypeCreation(beanName); } }); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException ex) { throw new BeanCreationException(beanName, &quot;Scope '&quot; + scopeName + &quot;' is not active for the current thread; consider &quot; + &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;, ex); } } } catch (BeansException ex) { cleanupAfterBeanCreationFailure(beanName); throw ex; } } //类型转换 // Check if required type matches the type of the actual bean instance. if (requiredType != null &amp;amp;&amp;amp; !requiredType.isInstance(bean)) { try { T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType); if (convertedBean == null) { throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); } return convertedBean; } catch (TypeMismatchException ex) { if (logger.isTraceEnabled()) { logger.trace(&quot;Failed to convert bean '&quot; + name + &quot;' to required type '&quot; + ClassUtils.getQualifiedName(requiredType) + &quot;'&quot;, ex); } throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); } } return (T) bean; } ​ 代码很长,看起来比较费劲.拆分来看看。 // AbstractBeanFactory // 提取 bean name,bean name 可能不是单纯的名称也可能是工厂的名称 // 例如 &amp;amp;bean 就代表从名称为bean的工厂中获取 bean final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. // 通过单利工厂获取 bean Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;amp;&amp;amp; args == null) { if (logger.isTraceEnabled()) { if (isSingletonCurrentlyInCreation(beanName)) { logger.trace(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName + &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;); } else { logger.trace(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;); } } bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } 获取bean的真实名称 获取bean ​ 这部分分成3句代码 String beanName = transformedBeanName(name); Object sharedInstance = getSingleton(beanName); bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); 2.1 transformedBeanName // AbstractBeanFactory protected String transformedBeanName(String name) { return canonicalName(BeanFactoryUtils.transformedBeanName(name)); } // BeanFactoryUtils public static String transformedBeanName(String name) { Assert.notNull(name, &quot;'name' must not be null&quot;); // 判断是否是以&amp;amp; 开头的名称 if (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) { return name; } // 名称-&amp;gt;真实名称 放入换成中 // 不停的循环截取&amp;amp;后面的部分,直到不以&amp;amp;开头为止 return transformedBeanNameCache.computeIfAbsent(name, beanName -&amp;gt; { do { beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length()); } while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)); return beanName; }); } // AbstractBeanFactory public String canonicalName(String name) { String canonicalName = name; // Handle aliasing... String resolvedName; // 判断bean的名称是否是别名 // 一直循环 跟着别名的引用链走 // 直到非别名为止 // 例如 A-B-C-D-E-F // 从A找到F do { resolvedName = this.aliasMap.get(canonicalName); if (resolvedName != null) { canonicalName = resolvedName; } } while (resolvedName != null); return canonicalName; } 先判断是否是以&amp;amp;开头,这个符号代表着引用的意思,在c/c++里面估计会很熟悉. 判断是否是别名 返回最终确定下来的bean名称 2.2 &amp;amp; 符号的作用 public class MyTestFactoryBean implements FactoryBean&amp;lt;MyTestBean&amp;gt; { @Override public MyTestBean getObject() throws Exception { return new MyTestBean(); } @Override public Class&amp;lt;?&amp;gt; getObjectType() { return MyTestBean.class; } @Override public boolean isSingleton() { return true; } } &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&amp;gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&amp;gt; &amp;lt;bean id=&quot;myTestBeanFactory&quot; class=&quot;com.sjr.test.bean.MyTestFactoryBean&quot;/&amp;gt; &amp;lt;/beans&amp;gt; public class TestSpringFactoryBean { @Test public void testFactoryBean() { BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBeanFactory.xml&quot;)); final Object bean = factory.getBean(&quot;myTestBeanFactory&quot;); System.out.println(bean.getClass().getName()); final Object bean1 = factory.getBean(&quot;&amp;amp;myTestBeanFactory&quot;); System.out.println(bean1.getClass().getName()); } } 最后结果输出为: com.sjr.test.bean.MyTestBean com.sjr.test.bean.MyTestFactoryBean ​ 从结果上来应该秒懂吧,如果一FactoryBean对象在spring创建的时候会判断bean名称,如果bean名称中不带有&amp;amp;符号,说明是要获取FactoryBean所产生的对象,如果带有&amp;amp;符号,则说明需要获取FactoryBean对象本身. 2.2 getSingleton // DefaultSingletonBeanRegistry @Override @Nullable public Object getSingleton(String beanName) { return getSingleton(beanName, true); } @Nullable protected Object getSingleton(String beanName, boolean allowEarlyReference) { // 缓存中是否有创建好的bean Object singletonObject = this.singletonObjects.get(beanName); // 缓存中无指定的bean并且该bean未在创建中 if (singletonObject == null &amp;amp;&amp;amp; isSingletonCurrentlyInCreation(beanName)) { // 加锁 synchronized (this.singletonObjects) { // 指定的bean是否在创建中 singletonObject = this.earlySingletonObjects.get(beanName); // 非创建中,并且允许提前引用 if (singletonObject == null &amp;amp;&amp;amp; allowEarlyReference) { // 获取单利工厂 ObjectFactory&amp;lt;?&amp;gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { // 调用工厂创建对象 singletonObject = singletonFactory.getObject(); // 把创建好的对象放入到正在创建的集合中去 this.earlySingletonObjects.put(beanName, singletonObject); // 移除单利工厂 this.singletonFactories.remove(beanName); } } } } return singletonObject; } ​ 逻辑比较简单,这里有几个map 比较重要: singletonObjects 用于保存BeanName和创建bean实例之间的关系 beanName-&amp;gt;bean earlySingletonObjects 用于保存BeanName和创建bean实例之间的关系 beanName-&amp;gt;bean,不同点是,当bean放入到此集合中时,在bean创建的过程中就可以通 过getBean方法来获取bean的引用,主要是用于解决循环依赖问题. singletonFactories:用于保存beanName与bean工厂之间的关系 registeredSingletons:用来保存当前所有已注册的bean ​ 如果bean名称是工厂的名称,那么这里已经完成了bean的创建了,但仅仅是创建完成还是不够,spring还要插上一脚进行管理. 2.3 getObjectForBeanInstance protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) { // Don't let calling code try to dereference the factory if the bean isn't a factory. // 检查bean名称是否符合bean工厂的命名规范,如果名称是工厂的格式,则获取的bean为工厂实例 if (BeanFactoryUtils.isFactoryDereference(name)) { // 符合规范但是个null if (beanInstance instanceof NullBean) { return beanInstance; } // 符合规范但不是factory,异常 if (!(beanInstance instanceof FactoryBean)) { throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass()); } // 如果bean定义不为空,设置为true表明是个工厂bean if (mbd != null) { mbd.isFactoryBean = true; } return beanInstance; } // Now we have the bean instance, which may be a normal bean or a FactoryBean. // If it's a FactoryBean, we use it to create a bean instance, unless the // caller actually wants a reference to the factory. // 如果bean实例为非工厂,直接返回 if (!(beanInstance instanceof FactoryBean)) { return beanInstance; } // 后面的逻辑是bean是工厂,而名称则不是工厂的解引用格式 Object object = null; if (mbd != null) { mbd.isFactoryBean = true; } else { // 从缓存中获取对象对应的工厂bean object = getCachedObjectForFactoryBean(beanName); } if (object == null) { // Return bean instance from factory. FactoryBean&amp;lt;?&amp;gt; factory = (FactoryBean&amp;lt;?&amp;gt;) beanInstance; // Caches object obtained from FactoryBean if it is a singleton. if (mbd == null &amp;amp;&amp;amp; containsBeanDefinition(beanName)) { mbd = getMergedLocalBeanDefinition(beanName); } boolean synthetic = (mbd != null &amp;amp;&amp;amp; mbd.isSynthetic()); object = getObjectFromFactoryBean(factory, beanName, !synthetic); } return object; } 如果bean的名称以&amp;amp; 开头并且是FactoryBean子类,直接返回工厂对象 如果bean的名称非以&amp;amp;开头并且非FactoryBean子类直接返回对象 如果bean的名称非以&amp;amp;开头并且是FactoryBean子类调用FactoryBean的getObject方法获取对象 以上代码中的核心代码有三处: getCachedObjectForFactoryBean() getMergedLocalBeanDefinition() getObjectFromFactoryBean() 2.4 getCachedObjectForFactoryBean @Nullable protected Object getCachedObjectForFactoryBean(String beanName) { return this.factoryBeanObjectCache.get(beanName); } ​ 代码很简单,就是根据beanName在换成中获取对应的bean 2.5 getMergedLocalBeanDefinition // AbstractBeanFactory protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException { // Quick check on the concurrent map first, with minimal locking. // 从缓存中获取 RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName); if (mbd != null &amp;amp;&amp;amp; !mbd.stale) { return mbd; } return getMergedBeanDefinition(beanName, getBeanDefinition(beanName)); } protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd) throws BeanDefinitionStoreException { return getMergedBeanDefinition(beanName, bd, null); } protected RootBeanDefinition getMergedBeanDefinition( String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd) throws BeanDefinitionStoreException { // 加锁,并发控制 synchronized (this.mergedBeanDefinitions) { RootBeanDefinition mbd = null; RootBeanDefinition previous = null; // Check with full lock now in order to enforce the same merged instance. if (containingBd == null) { // 如果为空 从缓存中获取 mbd = this.mergedBeanDefinitions.get(beanName); } if (mbd == null || mbd.stale) { previous = mbd; // 判断是否具有父子关系 if (bd.getParentName() == null) { // Use copy of given root bean definition. // 判断类型是否是 RootBeanDefinition if (bd instanceof RootBeanDefinition) { // copy一个 mbd = ((RootBeanDefinition) bd).cloneBeanDefinition(); } else { // 转换为 RootBeanDefinition mbd = new RootBeanDefinition(bd); } } else { // Child bean definition: needs to be merged with parent. BeanDefinition pbd; try { // 获取 父bean 名称 String parentBeanName = transformedBeanName(bd.getParentName()); // 判断父与子的bean 名称是否相同 if (!beanName.equals(parentBeanName)) { // 如果不相同,则顺则 父子关系 一路递归上去 // 全部转换为 RootBeanDefinition pbd = getMergedBeanDefinition(parentBeanName); } else { // 和上面代码逻辑相同 只是类型不一样 BeanFactory parent = getParentBeanFactory(); if (parent instanceof ConfigurableBeanFactory) { pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName); } else { throw new NoSuchBeanDefinitionException(parentBeanName, &quot;Parent name '&quot; + parentBeanName + &quot;' is equal to bean name '&quot; + beanName + &quot;': cannot be resolved without an AbstractBeanFactory parent&quot;); } } } catch (NoSuchBeanDefinitionException ex) { throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName, &quot;Could not resolve parent bean definition '&quot; + bd.getParentName() + &quot;'&quot;, ex); } // Deep copy with overridden values. // 深拷贝 转换为RootBeanDefinition mbd = new RootBeanDefinition(pbd); mbd.overrideFrom(bd); } // Set default singleton scope, if not configured before. if (!StringUtils.hasLength(mbd.getScope())) { mbd.setScope(SCOPE_SINGLETON); } // A bean contained in a non-singleton bean cannot be a singleton itself. // Let's correct this on the fly here, since this might be the result of // parent-child merging for the outer bean, in which case the original inner bean // definition will not have inherited the merged outer bean's singleton status. if (containingBd != null &amp;amp;&amp;amp; !containingBd.isSingleton() &amp;amp;&amp;amp; mbd.isSingleton()) { mbd.setScope(containingBd.getScope()); } // Cache the merged bean definition for the time being // (it might still get re-merged later on in order to pick up metadata changes) if (containingBd == null &amp;amp;&amp;amp; isCacheBeanMetadata()) { // 加入缓存 this.mergedBeanDefinitions.put(beanName, mbd); } } if (previous != null) { copyRelevantMergedBeanDefinitionCaches(previous, mbd); } return mbd; } } ​ 说这代码之前,先说说spring中的基本数据结构.在spring中基本数据结构为BeanDefinition,通过spring产生的普通bean为GenericBeanDefinition.而spring后续处理的类型则为RootBeanDefinition.关系图如下: ​ 这两个长的都差不多,只不过后续处理的步骤用到的类型为RootBeanDefinition,所以在上面的方法中,进行递归转换. 2.6 getObjectFromFactoryBean // AbstractBeanFactory boolean synthetic = (mbd != null &amp;amp;&amp;amp; mbd.isSynthetic()); object = getObjectFromFactoryBean(factory, beanName, !synthetic); ​ 这里这个isSynthetic方法代表是否是人造的,emma就这样理解吧.什么叫做人造的呢?意思就是不加干预通spring产生的就是非人造的,如果是后面通过代理产生的就是非人造的. ​ 看了一下setSynthetic这个方法的调用情况,都是在aop那边调用的比较多.不知道解释的对不对哈. // FactoryBeanRegistrySupport protected Object getObjectFromFactoryBean(FactoryBean&amp;lt;?&amp;gt; factory, String beanName, boolean shouldPostProcess) { // 判断工厂是否为单利工厂,并且单利对象已被创建完成 if (factory.isSingleton() &amp;amp;&amp;amp; containsSingleton(beanName)) { // 加锁 synchronized (getSingletonMutex()) { // 在缓存中获取通过工厂创建的bean Object object = this.factoryBeanObjectCache.get(beanName); if (object == null) { // 获取bean通过工厂 object = doGetObjectFromFactoryBean(factory, beanName); // Only post-process and store if not put there already during getObject() call above // (e.g. because of circular reference processing triggered by custom getBean calls) // 再次从缓存中获取bean Object alreadyThere = this.factoryBeanObjectCache.get(beanName); if (alreadyThere != null) { // 如果缓存中获取到bean,则丢弃当前创建的对象 object = alreadyThere; } else { // 判断是否需要post-processing if (shouldPostProcess) { // 当前的bean是否被创建中,如果是就直接返回当前的bean不做处理 if (isSingletonCurrentlyInCreation(beanName)) { // Temporarily return non-post-processed object, not storing it yet.. return object; } // bean创建之前,把当前bean加入正在创建中的集合中去 beforeSingletonCreation(beanName); try { // AOP的核心步骤 object = postProcessObjectFromFactoryBean(object, beanName); } catch (Throwable ex) { throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean's singleton object failed&quot;, ex); } finally { // bean创建之后,把bean从正在创建中的集合中移除 afterSingletonCreation(beanName); } } if (containsSingleton(beanName)) { // 缓存bean对象 this.factoryBeanObjectCache.put(beanName, object); } } } return object; } } else { //创建对象 Object object = doGetObjectFromFactoryBean(factory, beanName); if (shouldPostProcess) { try { //处理bean流程 object = postProcessObjectFromFactoryBean(object, beanName); } catch (Throwable ex) { throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean's object failed&quot;, ex); } } return object; } } 判断是否是单利工厂,并且缓存中已经创建了该bean的factoryBean 判断factoryBeanObjectCache缓存中bean是否存在 通过factoryBean创建bean ​ 以上逻辑为当有factoryBean的逻辑. 三、后半段逻辑 //AbstractBeanFactory // 如果为原型模式,存在循环依赖则报错 // Fail if we're already creating this bean instance: // We're assumably within a circular reference. // 如果是原型模式则不解决循环依赖问题,直接抛出异常 if (isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } // 获取父bean工厂 // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); // 通过递归父工厂获取bean对象 // 如果无bean定义并且还要加载这个bean 说明这个bean已经被加载过了 if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) { // Not found -&amp;gt; check parent. String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) { return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); } else if (args != null) { // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); } else if (requiredType != null) { // No args -&amp;gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); } else { return (T) parentBeanFactory.getBean(nameToLookup); } } ​ 如果非单利模式,spring在这里不处理循环依赖问题.如果BeanFactory存在父子关系,则进行递归创建. // AbstractBeanFactory // 记录 bean 正在创建中 if (!typeCheckOnly) { markBeanAsCreated(beanName); } // 转换BeanDefinition为RootBeanDefinition final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); // 检查RootBeanDefinition是否合法 checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. // 遍历所有依赖,并进行注册、创建等过程 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) { for (String dep : dependsOn) { if (isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;); } // 依赖注册 registerDependentBean(dep, beanName); try { // 获取bean,循环获取依赖 getBean(dep); } catch (NoSuchBeanDefinitionException ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex); } } } // 创建bean实例 // Create bean instance. // 单利模式 if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -&amp;gt; { try { return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } 标记该bean未正在创建中. // AbstractBeanFactory protected void markBeanAsCreated(String beanName) { // 判断是否包含beanName if (!this.alreadyCreated.contains(beanName)) { // 加锁并发控制 synchronized (this.mergedBeanDefinitions) { // 双重检查 if (!this.alreadyCreated.contains(beanName)) { // Let the bean definition get re-merged now that we're actually creating // the bean... just in case some of its metadata changed in the meantime. clearMergedBeanDefinition(beanName); // 添加进行已经创建集合中 this.alreadyCreated.add(beanName); } } } } 遍历依赖并进行递归创建 // AbstractBeanFactory if (dependsOn != null) { for (String dep : dependsOn) { if (isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;); } //依赖注册 registerDependentBean(dep, beanName); try { //获取bean,循环获取依赖 getBean(dep); } catch (NoSuchBeanDefinitionException ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex); } } } ​ 这里的核心逻辑在于getSingleton这个方法里 3.1 getSingleton // AbstractBeanFactory public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) { Assert.notNull(beanName, &quot;Bean name must not be null&quot;); // 加锁 synchronized (this.singletonObjects) { // 从缓存中获取 bean Object singletonObject = this.singletonObjects.get(beanName); // 如果缓存中没有 if (singletonObject == null) { // 判断当前bean是否被标记为销毁 // 相当于不能在destrory方法里面再去创建这个bean if (this.singletonsCurrentlyInDestruction) { throw new BeanCreationNotAllowedException(beanName, &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; + &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;); } if (logger.isDebugEnabled()) { logger.debug(&quot;Creating shared instance of singleton bean '&quot; + beanName + &quot;'&quot;); } // 开始创建 bean // 添加到 创建中集合中去 // 前置处理 beforeSingletonCreation(beanName); boolean newSingleton = false; boolean recordSuppressedExceptions = (this.suppressedExceptions == null); if (recordSuppressedExceptions) { this.suppressedExceptions = new LinkedHashSet&amp;lt;&amp;gt;(); } try { // 从工厂中获取 bean singletonObject = singletonFactory.getObject(); newSingleton = true; } catch (IllegalStateException ex) { // Has the singleton object implicitly appeared in the meantime -&amp;gt; // if yes, proceed with it since the exception indicates that state. singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { throw ex; } } catch (BeanCreationException ex) { if (recordSuppressedExceptions) { for (Exception suppressedException : this.suppressedExceptions) { ex.addRelatedCause(suppressedException); } } throw ex; } finally { if (recordSuppressedExceptions) { this.suppressedExceptions = null; } // 移除创建中的集合 afterSingletonCreation(beanName); } if (newSingleton) { // 放入缓存 addSingleton(beanName, singletonObject); } } return singletonObject; } } 从缓存中获取bean 如果换成中没有,则判断当前的bean是否被记被销毁 在创建之前把beanName加入正在创建的缓存中去 从单利工厂中创建bean 从正在创建的换成中移除beanName 把创建好的singletonObject加入缓存中 值得注意的是这里的singletonFactory对象是通过Lambda表达传入进来的 // AbstractBeanFactory sharedInstance = getSingleton(beanName, () -&amp;gt; { try { return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); 这里的核心逻辑代码是createBean(beanName, mbd, args) 3.2 createBean // AbstractAutowireCapableBeanFactory @Override protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { if (logger.isTraceEnabled()) { logger.trace(&quot;Creating instance of bean '&quot; + beanName + &quot;'&quot;); } RootBeanDefinition mbdToUse = mbd; // Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition. // 根据类名加载class对象 Class&amp;lt;?&amp;gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;amp;&amp;amp; !mbd.hasBeanClass() &amp;amp;&amp;amp; mbd.getBeanClassName() != null) { mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); } // Prepare method overrides. try { // 匹配需要覆盖的方法 mbdToUse.prepareMethodOverrides(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, &quot;Validation of method overrides failed&quot;, ex); } try { // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. // 返回一个代理对象,也可能是非代理对象 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) { return bean; } } catch (Throwable ex) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex); } try { // 创建bean Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isTraceEnabled()) { logger.trace(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;); } return beanInstance; } catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) { // A previously detected exception with proper bean creation context already, // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry. throw ex; } catch (Throwable ex) { throw new BeanCreationException( mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex); } } 加载class 判断该bean是否需要InstantiationAwareBeanPostProcessor进行处理,这个接口与BeanPostProcessor不同,主要区别是在调用时机上的区别,InstantiationAwareBeanPostProcessor会在对象创建前进行调用,而BeanPostProcessor会在对象初始化前后进行调用,这个可以从doCreateBean看出时机的差别. 创建对象 3.3 doCreateBean // AbstractAutowireCapableBeanFactory protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException { // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { // 从缓存中获取实例wrapper,并移除它 instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } // 如果没有获取到实例的wrapper,则创建一个实例 if (instanceWrapper == null) { instanceWrapper = createBeanInstance(beanName, mbd, args); } final Object bean = instanceWrapper.getWrappedInstance(); Class&amp;lt;?&amp;gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } // Allow post-processors to modify the merged bean definition. // 判断是否有 后置处理器 // 加锁 synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { try { applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Post-processing of merged bean definition failed&quot;, ex); } mbd.postProcessed = true; } } // 是否允许循环引用 // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isTraceEnabled()) { logger.trace(&quot;Eagerly caching bean '&quot; + beanName + &quot;' to allow for resolving potential circular references&quot;); } addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean)); } // Initialize the bean instance. Object exposedObject = bean; try { // 填充bean属性 populateBean(beanName, mbd, instanceWrapper); // 初始化bean exposedObject = initializeBean(beanName, exposedObject, mbd); } catch (Throwable ex) { if (ex instanceof BeanCreationException &amp;amp;&amp;amp; beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex); } } // 循环依赖处理 if (earlySingletonExposure) { // 获取单利对象 Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { if (exposedObject == bean) { exposedObject = earlySingletonReference; } else if (!this.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp; hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set&amp;lt;String&amp;gt; actualDependentBeans = new LinkedHashSet&amp;lt;&amp;gt;(dependentBeans.length); for (String dependentBean : dependentBeans) { if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + &quot;] in its raw version as part of a circular reference, but has eventually been &quot; + &quot;wrapped. This means that said other beans do not use the final version of the &quot; + &quot;bean. This is often the result of over-eager type matching - consider using &quot; + &quot;'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.&quot;); } } } } // Register bean as disposable. try { // 注册销毁处理器 registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex); } return exposedObject; } ​ 进过以上骚操作就完成了bean的创建,在创建的过程中还会有属性的填充,bean的初始化等. 四、小结 ​ 继续bean的初始化,与属性的填充.</summary></entry><entry><title type="html">[断点分析之spring-ioc]-BeanDefinitionHolder注册(七)</title><link href="https://onew.me/spring/2020/03/02/debug-spring-7.html" rel="alternate" type="text/html" title="[断点分析之spring-ioc]-BeanDefinitionHolder注册(七)" /><published>2020-03-02T14:20:25+08:00</published><updated>2020-03-02T14:20:25+08:00</updated><id>https://onew.me/spring/2020/03/02/debug-spring-7</id><content type="html" xml:base="https://onew.me/spring/2020/03/02/debug-spring-7.html"># 一、前言

​	通过前面大批量的工作,终于要到注册BeanDefinitionHolder这一步了.当然还是通过一下代码作为入口进行分析.

```java
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
		// 解析xml元素
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
		if (bdHolder != null) {
			// 装饰bean
			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
			try {
				// Register the final decorated instance.
				// 注册bean到容器中
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
						bdHolder.getBeanName() + &quot;'&quot;, ele, ex);
			}
			// Send registration event.
			// 发送事件
			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
		}
	}
```

​	解析、装饰都已经记录了,解析来的重点就是`BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());`这句代码了.



# 二、分析

```java
public static void registerBeanDefinition(
			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
			throws BeanDefinitionStoreException {
		// 注册 bean
		// Register bean definition under primary name.
		// 获取 bean 的名称
		String beanName = definitionHolder.getBeanName();
		// 注册
		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

		//注册 bean 的所有别名
		// Register aliases for bean name, if any.
		String[] aliases = definitionHolder.getAliases();
		if (aliases != null) {
			for (String alias : aliases) {
				registry.registerAlias(beanName, alias);
			}
		}
	}
```

1. 通过bean的名称进行注册
2. 通过bean的别名进行注册



`BeanDefinitionRegistry`这个对象是通过`XmlReaderContext`中获取的.

```java
// XmlReaderContext
public final BeanDefinitionRegistry getRegistry() {
		return this.reader.getRegistry();
	}
```

​	而这个reader则是`XmlBeanDefinitionReader`,`registry`对象则通过`XmlBeanDefinitionReader`的构造方法传入进来,实际上这个`registry`对象就是`XmlBeanFactory`或者说是`DefaultListableBeanFactory`,因为这两个有继承关系.

​	![images](https://gitee.com/oneww/onew_image/raw/master/XmlBeanFactory.png)





## 2.1 registerBeanDefinition



```java
// DefaultListableBeanFactory
@Override
	public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
			throws BeanDefinitionStoreException {

		Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);
		Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);

		if (beanDefinition instanceof AbstractBeanDefinition) {
			try {
				// 校验 bean 的定义是否合法
				((AbstractBeanDefinition) beanDefinition).validate();
			}
			catch (BeanDefinitionValidationException ex) {
				throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
						&quot;Validation of bean definition failed&quot;, ex);
			}
		}
		// 从缓存中取出 BeanDefinition
		BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
		// bean 已被注册过
		if (existingDefinition != null) {
			// 如果不允许重复注册则抛出异常
			if (!isAllowBeanDefinitionOverriding()) {
				throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
			}
			else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) {
				// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
				if (logger.isInfoEnabled()) {
					logger.info(&quot;Overriding user-defined bean definition for bean '&quot; + beanName +
							&quot;' with a framework-generated bean definition: replacing [&quot; +
							existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
				}
			}
			else if (!beanDefinition.equals(existingDefinition)) {
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Overriding bean definition for bean '&quot; + beanName +
							&quot;' with a different definition: replacing [&quot; + existingDefinition +
							&quot;] with [&quot; + beanDefinition + &quot;]&quot;);
				}
			}
			else {
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Overriding bean definition for bean '&quot; + beanName +
							&quot;' with an equivalent definition: replacing [&quot; + existingDefinition +
							&quot;] with [&quot; + beanDefinition + &quot;]&quot;);
				}
			}
			// 放入到 map 中
			// 覆盖
			this.beanDefinitionMap.put(beanName, beanDefinition);
		}
		else {
			// 判断是否有创建中的bean
			if (hasBeanCreationStarted()) {
				// Cannot modify startup-time collection elements anymore (for stable iteration)
				// 加锁
				// 不能修改启动时的集合,需要重新创建一个集合
				synchronized (this.beanDefinitionMap) {
					// 放入map中
					this.beanDefinitionMap.put(beanName, beanDefinition);
					List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);
					updatedDefinitions.addAll(this.beanDefinitionNames);
					updatedDefinitions.add(beanName);
					this.beanDefinitionNames = updatedDefinitions;
					// 如果这个已经 bean 在存在 则移除
					removeManualSingletonName(beanName);
				}
			}
			else {
				// Still in startup registration phase
				this.beanDefinitionMap.put(beanName, beanDefinition);
				this.beanDefinitionNames.add(beanName);
        // 如果这个已经 bean 在存在 则移除
				removeManualSingletonName(beanName);
			}
			this.frozenBeanDefinitionNames = null;
		}
		//注册成功,如果是重复注册的则销毁之前注册的bean
		if (existingDefinition != null || containsSingleton(beanName)) {
			resetBeanDefinition(beanName);
		}
	}
```

​	这个阶段呢,bean都还没开始创建,都是在做解析,注册之类的事情,所以这里有一个判断看起来比较迷惑`hasBeanCreationStarted`.或许后面才会知道这个判断条件有啥用吧.

1. 验证`beanDefinition`是否合法

 	2. 判断bean是否被注册过,如果不允许重复注册则抛出异常
 	3. 如果允许重复注册则放入`beanDefinitionMap`这个map集合中
 	4. 如果该`beanDefinition`未被注册过,则添加映射到`beanDefinitionMap`中去和`beanDefinitionNames`集合中去.
 	5. 注册成功,如果是重复注册的则销毁之前注册的bean



## 2.2 registerAlias

```java
// SimpleAliasRegistry
@Override
	public void registerAlias(String name, String alias) {
		Assert.hasText(name, &quot;'name' must not be empty&quot;);
		Assert.hasText(alias, &quot;'alias' must not be empty&quot;);
		// 加锁 并发控制
		synchronized (this.aliasMap) {
			// 判断 bean 名称是否与别名相同,如果相同则忽略
			if (alias.equals(name)) {
				// 移除别名
				this.aliasMap.remove(alias);
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Alias definition '&quot; + alias + &quot;' ignored since it points to same name&quot;);
				}
			}
			else {
				// 判断别名是否已存在
				String registeredName = this.aliasMap.get(alias);
				if (registeredName != null) {
					// 如果别名对应的bean的名称与name相同则忽略
					if (registeredName.equals(name)) {
						// An existing alias - no need to re-register
						return;
					}
					// 是否允许覆盖,如果不允许则报错
					if (!allowAliasOverriding()) {
						throw new IllegalStateException(&quot;Cannot define alias '&quot; + alias + &quot;' for name '&quot; +
								name + &quot;': It is already registered for name '&quot; + registeredName + &quot;'.&quot;);
					}
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Overriding alias '&quot; + alias + &quot;' definition for registered name '&quot; +
								registeredName + &quot;' with new target name '&quot; + name + &quot;'&quot;);
					}
				}
				//检查是否有循环引用别名 例如:A-B C-B A-C
				checkForAliasCircle(name, alias);
				//映射别名和名称到map中
				this.aliasMap.put(alias, name);
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Alias definition '&quot; + alias + &quot;' registered for name '&quot; + name + &quot;'&quot;);
				}
			}
		}
	}
```

1. 判断别名是否与bean名称是否相同
2. 如果相同则移除别名
3. 判断别名是否已经存在
4. 如果不存在检查是否存在循环引用
5. 映射别名



​	这里检测是否存在循环引用比较有意思,之前文章应该记录到了这块儿的逻辑.



# 三、小结

​	bean的解析与注册已经分析完了,接下来就是重头戏了,终于要看看 spring 是怎么根据`BeanDefinition`来创建bean对象.</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">一、前言 ​ 通过前面大批量的工作,终于要到注册BeanDefinitionHolder这一步了.当然还是通过一下代码作为入口进行分析. protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // 解析xml元素 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { // 装饰bean bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. // 注册bean到容器中 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(&quot;Failed to register bean definition with name '&quot; + bdHolder.getBeanName() + &quot;'&quot;, ele, ex); } // Send registration event. // 发送事件 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } ​ 解析、装饰都已经记录了,解析来的重点就是BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());这句代码了. 二、分析 public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { // 注册 bean // Register bean definition under primary name. // 获取 bean 的名称 String beanName = definitionHolder.getBeanName(); // 注册 registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); //注册 bean 的所有别名 // Register aliases for bean name, if any. String[] aliases = definitionHolder.getAliases(); if (aliases != null) { for (String alias : aliases) { registry.registerAlias(beanName, alias); } } } 通过bean的名称进行注册 通过bean的别名进行注册 BeanDefinitionRegistry这个对象是通过XmlReaderContext中获取的. // XmlReaderContext public final BeanDefinitionRegistry getRegistry() { return this.reader.getRegistry(); } ​ 而这个reader则是XmlBeanDefinitionReader,registry对象则通过XmlBeanDefinitionReader的构造方法传入进来,实际上这个registry对象就是XmlBeanFactory或者说是DefaultListableBeanFactory,因为这两个有继承关系. ​ 2.1 registerBeanDefinition // DefaultListableBeanFactory @Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { Assert.hasText(beanName, &quot;Bean name must not be empty&quot;); Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;); if (beanDefinition instanceof AbstractBeanDefinition) { try { // 校验 bean 的定义是否合法 ((AbstractBeanDefinition) beanDefinition).validate(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, &quot;Validation of bean definition failed&quot;, ex); } } // 从缓存中取出 BeanDefinition BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName); // bean 已被注册过 if (existingDefinition != null) { // 如果不允许重复注册则抛出异常 if (!isAllowBeanDefinitionOverriding()) { throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition); } else if (existingDefinition.getRole() &amp;lt; beanDefinition.getRole()) { // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE if (logger.isInfoEnabled()) { logger.info(&quot;Overriding user-defined bean definition for bean '&quot; + beanName + &quot;' with a framework-generated bean definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); } } else if (!beanDefinition.equals(existingDefinition)) { if (logger.isDebugEnabled()) { logger.debug(&quot;Overriding bean definition for bean '&quot; + beanName + &quot;' with a different definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); } } else { if (logger.isTraceEnabled()) { logger.trace(&quot;Overriding bean definition for bean '&quot; + beanName + &quot;' with an equivalent definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); } } // 放入到 map 中 // 覆盖 this.beanDefinitionMap.put(beanName, beanDefinition); } else { // 判断是否有创建中的bean if (hasBeanCreationStarted()) { // Cannot modify startup-time collection elements anymore (for stable iteration) // 加锁 // 不能修改启动时的集合,需要重新创建一个集合 synchronized (this.beanDefinitionMap) { // 放入map中 this.beanDefinitionMap.put(beanName, beanDefinition); List&amp;lt;String&amp;gt; updatedDefinitions = new ArrayList&amp;lt;&amp;gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; // 如果这个已经 bean 在存在 则移除 removeManualSingletonName(beanName); } } else { // Still in startup registration phase this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); // 如果这个已经 bean 在存在 则移除 removeManualSingletonName(beanName); } this.frozenBeanDefinitionNames = null; } //注册成功,如果是重复注册的则销毁之前注册的bean if (existingDefinition != null || containsSingleton(beanName)) { resetBeanDefinition(beanName); } } ​ 这个阶段呢,bean都还没开始创建,都是在做解析,注册之类的事情,所以这里有一个判断看起来比较迷惑hasBeanCreationStarted.或许后面才会知道这个判断条件有啥用吧. 验证beanDefinition是否合法 2. 判断bean是否被注册过,如果不允许重复注册则抛出异常 3. 如果允许重复注册则放入beanDefinitionMap这个map集合中 4. 如果该beanDefinition未被注册过,则添加映射到beanDefinitionMap中去和beanDefinitionNames集合中去. 5. 注册成功,如果是重复注册的则销毁之前注册的bean 2.2 registerAlias // SimpleAliasRegistry @Override public void registerAlias(String name, String alias) { Assert.hasText(name, &quot;'name' must not be empty&quot;); Assert.hasText(alias, &quot;'alias' must not be empty&quot;); // 加锁 并发控制 synchronized (this.aliasMap) { // 判断 bean 名称是否与别名相同,如果相同则忽略 if (alias.equals(name)) { // 移除别名 this.aliasMap.remove(alias); if (logger.isDebugEnabled()) { logger.debug(&quot;Alias definition '&quot; + alias + &quot;' ignored since it points to same name&quot;); } } else { // 判断别名是否已存在 String registeredName = this.aliasMap.get(alias); if (registeredName != null) { // 如果别名对应的bean的名称与name相同则忽略 if (registeredName.equals(name)) { // An existing alias - no need to re-register return; } // 是否允许覆盖,如果不允许则报错 if (!allowAliasOverriding()) { throw new IllegalStateException(&quot;Cannot define alias '&quot; + alias + &quot;' for name '&quot; + name + &quot;': It is already registered for name '&quot; + registeredName + &quot;'.&quot;); } if (logger.isDebugEnabled()) { logger.debug(&quot;Overriding alias '&quot; + alias + &quot;' definition for registered name '&quot; + registeredName + &quot;' with new target name '&quot; + name + &quot;'&quot;); } } //检查是否有循环引用别名 例如:A-B C-B A-C checkForAliasCircle(name, alias); //映射别名和名称到map中 this.aliasMap.put(alias, name); if (logger.isTraceEnabled()) { logger.trace(&quot;Alias definition '&quot; + alias + &quot;' registered for name '&quot; + name + &quot;'&quot;); } } } } 判断别名是否与bean名称是否相同 如果相同则移除别名 判断别名是否已经存在 如果不存在检查是否存在循环引用 映射别名 ​ 这里检测是否存在循环引用比较有意思,之前文章应该记录到了这块儿的逻辑. 三、小结 ​ bean的解析与注册已经分析完了,接下来就是重头戏了,终于要看看 spring 是怎么根据BeanDefinition来创建bean对象.</summary></entry><entry><title type="html">[断点分析之spring-ioc]-BeanDefinitionHolder装饰(六)</title><link href="https://onew.me/spring/2020/03/01/debug-spring-6.html" rel="alternate" type="text/html" title="[断点分析之spring-ioc]-BeanDefinitionHolder装饰(六)" /><published>2020-03-01T14:20:25+08:00</published><updated>2020-03-01T14:20:25+08:00</updated><id>https://onew.me/spring/2020/03/01/debug-spring-6</id><content type="html" xml:base="https://onew.me/spring/2020/03/01/debug-spring-6.html"># 一、前言

​	在xml标签解析完之后会产生一个`BeanDefinitionHolder`对象,紧接着就来谈谈,`spring`用这个对象来干嘛吧.

```java
//DefaultBeanDefinitionDocumentReader.java
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
		// 解析xml元素 
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
		if (bdHolder != null) {
			// 装饰
			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
			try {
				// Register the final decorated instance.
				// 注册到容器中
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
						bdHolder.getBeanName() + &quot;'&quot;, ele, ex);
			}
			// Send registration event.
			// 发送事件
			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
		}
	}
```

​	解析xml这边已经记录过了,接下来的重点在于`delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);`,从方法名可以看出意思大概为:如果有必要就进行装饰.说到装饰感觉跟装饰模式有关.



# 二、分析

```java
public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef) {
		return decorateBeanDefinitionIfRequired(ele, originalDef, null);
	}

	/**
	 * Decorate the given bean definition through a namespace handler, if applicable.
	 * @param ele the current element
	 * @param originalDef the current bean definition
	 * @param containingBd the containing bean definition (if any)
	 * @return the decorated bean definition
	 */
	public BeanDefinitionHolder decorateBeanDefinitionIfRequired(
			Element ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {

		BeanDefinitionHolder finalDefinition = originalDef;
		// 遍历节点,寻找可以装饰的属性
		// Decorate based on custom attributes first.
		NamedNodeMap attributes = ele.getAttributes();
		for (int i = 0; i &lt; attributes.getLength(); i++) {
			Node node = attributes.item(i);
			finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);
		}
		// 遍历子节点,寻找可以装饰的子节点
		// Decorate based on custom nested elements.
		NodeList children = ele.getChildNodes();
		for (int i = 0; i &lt; children.getLength(); i++) {
			Node node = children.item(i);
			if (node.getNodeType() == Node.ELEMENT_NODE) {
				finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);
			}
		}
		return finalDefinition;
	}
```

1. 遍历当前节点的所有属性进行装饰
2. 遍历当前节点的所有子节点进行装饰
3. 返回`BeanDefinitionHolder`



​	从上面可以看到核心方法在于`decorateIfRequired`,进去看一看.

## 2.1 decorateIfRequired

```java
public BeanDefinitionHolder decorateIfRequired(
			Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {
		// 获取名称空间URI
		String namespaceUri = getNamespaceURI(node);
		// 判断是否是自定义名称空间,只对自定义名称空间进行处理
		if (namespaceUri != null &amp;&amp; !isDefaultNamespace(namespaceUri)) {
			// 获取名称空间对应的处理器
			NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
			if (handler != null) {
				// 进行装饰处理
				BeanDefinitionHolder decorated =
						handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));
				if (decorated != null) {
					return decorated;
				}
			}
			else if (namespaceUri.startsWith(&quot;http://www.springframework.org/schema/&quot;)) {
				error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, node);
			}
			else {
				// A custom namespace, not to be handled by Spring - maybe &quot;xml:...&quot;.
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;No Spring NamespaceHandler found for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;);
				}
			}
		}
		return originalDef;
	}
```

1. 判断是否是默认名称命名空间
2. 非默认进行装饰处理



​	那么这个装饰是个什么鬼呢？通过判断是否是默认名称空间这个条件感觉在前面分析的时候遇到过.从这个条件可以看出这个逻辑与最后达到的效果与前面自定义标签是一回事.可以看看官方给出的例子.

- 用于测试的xml

```xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	   xmlns:test=&quot;http://www.springframework.org/schema/beans/test&quot;
	   xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
	   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-2.0.xsd
       http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util-2.0.xsd
       http://www.springframework.org/schema/beans/test https://www.springframework.org/schema/beans/factory/xml/support/CustomNamespaceHandlerTests.xsd&quot;
	default-lazy-init=&quot;true&quot;&gt;

	&lt;test:testBean id=&quot;testBean&quot; name=&quot;Rob Harrop&quot; age=&quot;23&quot;/&gt;

	&lt;bean id=&quot;customisedTestBean&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot;&gt;
		&lt;test:set name=&quot;Rob Harrop&quot; age=&quot;23&quot;/&gt;
	&lt;/bean&gt;

	&lt;bean id=&quot;debuggingTestBean&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot;&gt;
		&lt;test:debug/&gt;
		&lt;property name=&quot;name&quot; value=&quot;Rob Harrop&quot;/&gt;
		&lt;property name=&quot;age&quot; value=&quot;23&quot;/&gt;
	&lt;/bean&gt;

	&lt;bean id=&quot;debuggingTestBeanNoInstance&quot; class=&quot;org.springframework.context.ApplicationListener&quot;&gt;
		&lt;test:debug/&gt;
	&lt;/bean&gt;

	&lt;bean id=&quot;chainedTestBean&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot;&gt;
		&lt;test:debug/&gt;
		&lt;test:nop/&gt;
		&lt;property name=&quot;name&quot; value=&quot;Rob Harrop&quot;/&gt;
		&lt;property name=&quot;age&quot; value=&quot;23&quot;/&gt;
	&lt;/bean&gt;

	&lt;bean id=&quot;decorateWithAttribute&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot; test:object-name=&quot;foo&quot;/&gt;

	&lt;util:list id=&quot;list.of.things&quot;&gt;
		&lt;test:person name=&quot;Fiona Apple&quot; age=&quot;20&quot;/&gt;
		&lt;test:person name=&quot;Harriet Wheeler&quot; age=&quot;30&quot;/&gt;
	&lt;/util:list&gt;

	&lt;util:set id=&quot;set.of.things&quot;&gt;
		&lt;test:person name=&quot;Fiona Apple&quot; age=&quot;20&quot;/&gt;
		&lt;test:person name=&quot;Harriet Wheeler&quot; age=&quot;30&quot;/&gt;
	&lt;/util:set&gt;

	&lt;util:map id=&quot;map.of.things&quot;&gt;
		&lt;entry key=&quot;fiona.apple&quot;&gt;
			&lt;test:person name=&quot;Fiona Apple&quot; age=&quot;20&quot;/&gt;
		&lt;/entry&gt;
		&lt;entry key=&quot;harriet.wheeler&quot;&gt;
			&lt;test:person name=&quot;Harriet Wheeler&quot; age=&quot;30&quot;/&gt;
		&lt;/entry&gt;
	&lt;/util:map&gt;

&lt;/beans&gt;


```

- 用于测试的xsd文件

```xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;

&lt;xsd:schema xmlns=&quot;http://www.springframework.org/schema/beans/test&quot;
			xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
			targetNamespace=&quot;http://www.springframework.org/schema/beans/test&quot;
			elementFormDefault=&quot;qualified&quot;&gt;
	
	&lt;xsd:element name=&quot;person&quot;&gt;
		&lt;xsd:complexType&gt;
			&lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:string&quot; use=&quot;optional&quot; form=&quot;unqualified&quot;/&gt;
			&lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&gt;
			&lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:integer&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&gt;
		&lt;/xsd:complexType&gt;
	&lt;/xsd:element&gt;

	&lt;xsd:element name=&quot;testBean&quot;&gt;
		&lt;xsd:complexType&gt;
			&lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&gt;
			&lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&gt;
			&lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:integer&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&gt;
		&lt;/xsd:complexType&gt;
	&lt;/xsd:element&gt;

	&lt;xsd:element name=&quot;set&quot;&gt;
		&lt;xsd:complexType&gt;
			&lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&gt;
			&lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:integer&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&gt;
		&lt;/xsd:complexType&gt;
	&lt;/xsd:element&gt;

	&lt;xsd:element name=&quot;debug&quot;/&gt;
	&lt;xsd:element name=&quot;nop&quot;/&gt;

	&lt;xsd:attribute name=&quot;object-name&quot; type=&quot;xsd:string&quot;/&gt;

&lt;/xsd:schema&gt;

```

- 用于测试的property文件

```properties
http\://www.springframework.org/schema/beans/test=org.springframework.beans.factory.xml.support.TestNamespaceHandler
http\://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler
```

- 测试代码

```java
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.beans.factory.xml.support;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;

import org.springframework.aop.Advisor;
import org.springframework.aop.config.AbstractInterceptorDrivenBeanDefinitionDecorator;
import org.springframework.aop.framework.Advised;
import org.springframework.aop.interceptor.DebugInterceptor;
import org.springframework.aop.support.AopUtils;
import org.springframework.beans.BeanInstantiationException;
import org.springframework.beans.MutablePropertyValues;
import org.springframework.beans.factory.BeanCreationException;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanDefinitionHolder;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
import org.springframework.beans.factory.xml.BeanDefinitionDecorator;
import org.springframework.beans.factory.xml.BeanDefinitionParser;
import org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver;
import org.springframework.beans.factory.xml.NamespaceHandlerResolver;
import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.beans.factory.xml.PluggableSchemaResolver;
import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;
import org.springframework.context.ApplicationListener;
import org.springframework.context.support.GenericApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.tests.aop.interceptor.NopInterceptor;
import org.springframework.tests.sample.beans.ITestBean;
import org.springframework.tests.sample.beans.TestBean;

import static java.lang.String.format;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

/**
 * Unit tests for custom XML namespace handler implementations.
 *
 * @author Rob Harrop
 * @author Rick Evans
 * @author Chris Beams
 * @author Juergen Hoeller
 */
public class CustomNamespaceHandlerTests {

	private static final Class&lt;?&gt; CLASS = CustomNamespaceHandlerTests.class;
	private static final String CLASSNAME = CLASS.getSimpleName();
	private static final String FQ_PATH = &quot;org/springframework/beans/factory/xml/support&quot;;

	private static final String NS_PROPS = format(&quot;%s/%s.properties&quot;, FQ_PATH, CLASSNAME);
	private static final String NS_XML = format(&quot;%s/%s-context.xml&quot;, FQ_PATH, CLASSNAME);
	private static final String TEST_XSD = format(&quot;%s/%s.xsd&quot;, FQ_PATH, CLASSNAME);

	private GenericApplicationContext beanFactory;


	@BeforeEach
	public void setUp() throws Exception {
		NamespaceHandlerResolver resolver = new DefaultNamespaceHandlerResolver(CLASS.getClassLoader(), NS_PROPS);
		this.beanFactory = new GenericApplicationContext();
		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this.beanFactory);
		reader.setNamespaceHandlerResolver(resolver);
		reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_XSD);
		reader.setEntityResolver(new DummySchemaResolver());
		reader.loadBeanDefinitions(getResource());
		this.beanFactory.refresh();
	}


	@Test
	public void testSimpleParser() throws Exception {
		TestBean bean = (TestBean) this.beanFactory.getBean(&quot;testBean&quot;);
		assertTestBean(bean);
	}

	@Test
	public void testSimpleDecorator() throws Exception {
		TestBean bean = (TestBean) this.beanFactory.getBean(&quot;customisedTestBean&quot;);
		assertTestBean(bean);
	}

	@Test
	public void testProxyingDecorator() throws Exception {
		ITestBean bean = (ITestBean) this.beanFactory.getBean(&quot;debuggingTestBean&quot;);
		assertTestBean(bean);
		assertThat(AopUtils.isAopProxy(bean)).isTrue();
		Advisor[] advisors = ((Advised) bean).getAdvisors();
		assertThat(advisors.length).as(&quot;Incorrect number of advisors&quot;).isEqualTo(1);
		assertThat(advisors[0].getAdvice().getClass()).as(&quot;Incorrect advice class&quot;).isEqualTo(DebugInterceptor.class);
	}

	@Test
	public void testProxyingDecoratorNoInstance() throws Exception {
		String[] beanNames = this.beanFactory.getBeanNamesForType(ApplicationListener.class);
		assertThat(Arrays.asList(beanNames).contains(&quot;debuggingTestBeanNoInstance&quot;)).isTrue();
		assertThat(this.beanFactory.getType(&quot;debuggingTestBeanNoInstance&quot;)).isEqualTo(ApplicationListener.class);
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(() -&gt;
				this.beanFactory.getBean(&quot;debuggingTestBeanNoInstance&quot;))
			.satisfies(ex -&gt; assertThat(ex.getRootCause()).isInstanceOf(BeanInstantiationException.class));
	}

	@Test
	public void testChainedDecorators() throws Exception {
		ITestBean bean = (ITestBean) this.beanFactory.getBean(&quot;chainedTestBean&quot;);
		assertTestBean(bean);
		assertThat(AopUtils.isAopProxy(bean)).isTrue();
		Advisor[] advisors = ((Advised) bean).getAdvisors();
		assertThat(advisors.length).as(&quot;Incorrect number of advisors&quot;).isEqualTo(2);
		assertThat(advisors[0].getAdvice().getClass()).as(&quot;Incorrect advice class&quot;).isEqualTo(DebugInterceptor.class);
		assertThat(advisors[1].getAdvice().getClass()).as(&quot;Incorrect advice class&quot;).isEqualTo(NopInterceptor.class);
	}

	@Test
	public void testDecorationViaAttribute() throws Exception {
		BeanDefinition beanDefinition = this.beanFactory.getBeanDefinition(&quot;decorateWithAttribute&quot;);
		assertThat(beanDefinition.getAttribute(&quot;objectName&quot;)).isEqualTo(&quot;foo&quot;);
	}

	@Test  // SPR-2728
	public void testCustomElementNestedWithinUtilList() throws Exception {
		List&lt;?&gt; things = (List&lt;?&gt;) this.beanFactory.getBean(&quot;list.of.things&quot;);
		assertThat(things).isNotNull();
		assertThat(things.size()).isEqualTo(2);
	}

	@Test  // SPR-2728
	public void testCustomElementNestedWithinUtilSet() throws Exception {
		Set&lt;?&gt; things = (Set&lt;?&gt;) this.beanFactory.getBean(&quot;set.of.things&quot;);
		assertThat(things).isNotNull();
		assertThat(things.size()).isEqualTo(2);
	}

	@Test  // SPR-2728
	public void testCustomElementNestedWithinUtilMap() throws Exception {
		Map&lt;?, ?&gt; things = (Map&lt;?, ?&gt;) this.beanFactory.getBean(&quot;map.of.things&quot;);
		assertThat(things).isNotNull();
		assertThat(things.size()).isEqualTo(2);
	}


	private void assertTestBean(ITestBean bean) {
		assertThat(bean.getName()).as(&quot;Invalid name&quot;).isEqualTo(&quot;Rob Harrop&quot;);
		assertThat(bean.getAge()).as(&quot;Invalid age&quot;).isEqualTo(23);
	}

	private Resource getResource() {
		return new ClassPathResource(NS_XML);
	}


	private final class DummySchemaResolver extends PluggableSchemaResolver {

		public DummySchemaResolver() {
			super(CLASS.getClassLoader());
		}

		@Override
		public InputSource resolveEntity(String publicId, String systemId) throws IOException {
			InputSource source = super.resolveEntity(publicId, systemId);
			if (source == null) {
				Resource resource = new ClassPathResource(TEST_XSD);
				source = new InputSource(resource.getInputStream());
				source.setPublicId(publicId);
				source.setSystemId(systemId);
			}
			return source;
		}
	}

}


/**
 * Custom namespace handler implementation.
 *	自定义名称空间处理器
 * @author Rob Harrop
 */
final class TestNamespaceHandler extends NamespaceHandlerSupport {

	@Override
	public void init() {
    // 注册节点为 testBean 的解析器
		registerBeanDefinitionParser(&quot;testBean&quot;, new TestBeanDefinitionParser());
    // 注册节点为 person 的解析器
		registerBeanDefinitionParser(&quot;person&quot;, new PersonDefinitionParser());
		
    // 注册 set 装饰器
		registerBeanDefinitionDecorator(&quot;set&quot;, new PropertyModifyingBeanDefinitionDecorator());
    // 注册 debug 装饰器
		registerBeanDefinitionDecorator(&quot;debug&quot;, new DebugBeanDefinitionDecorator());
    // 注册 nop 装饰器
		registerBeanDefinitionDecorator(&quot;nop&quot;, new NopInterceptorBeanDefinitionDecorator());
    // 注册 属性为 object-name 的装饰器
		registerBeanDefinitionDecoratorForAttribute(&quot;object-name&quot;, new ObjectNameBeanDefinitionDecorator());
	}

	// 节点为 testBean 的解析器
	private static class TestBeanDefinitionParser implements BeanDefinitionParser {

		@Override
		public BeanDefinition parse(Element element, ParserContext parserContext) {
			RootBeanDefinition definition = new RootBeanDefinition();
			definition.setBeanClass(TestBean.class);

			MutablePropertyValues mpvs = new MutablePropertyValues();
			mpvs.add(&quot;name&quot;, element.getAttribute(&quot;name&quot;));
			mpvs.add(&quot;age&quot;, element.getAttribute(&quot;age&quot;));
			definition.setPropertyValues(mpvs);

			parserContext.getRegistry().registerBeanDefinition(element.getAttribute(&quot;id&quot;), definition);
			return null;
		}
	}

	// 节点为 person 的解析器
	private static final class PersonDefinitionParser extends AbstractSingleBeanDefinitionParser {

		@Override
		protected Class&lt;?&gt; getBeanClass(Element element) {
			return TestBean.class;
		}

		@Override
		protected void doParse(Element element, BeanDefinitionBuilder builder) {
			builder.addPropertyValue(&quot;name&quot;, element.getAttribute(&quot;name&quot;));
			builder.addPropertyValue(&quot;age&quot;, element.getAttribute(&quot;age&quot;));
		}
	}

	// set 装饰器
	private static class PropertyModifyingBeanDefinitionDecorator implements BeanDefinitionDecorator {

		@Override
		public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {
			Element element = (Element) node;
			BeanDefinition def = definition.getBeanDefinition();

			MutablePropertyValues mpvs = (def.getPropertyValues() == null) ? new MutablePropertyValues() : def.getPropertyValues();
			mpvs.add(&quot;name&quot;, element.getAttribute(&quot;name&quot;));
			mpvs.add(&quot;age&quot;, element.getAttribute(&quot;age&quot;));

			((AbstractBeanDefinition) def).setPropertyValues(mpvs);
			return definition;
		}
	}

	// debug 装饰器
	private static class DebugBeanDefinitionDecorator extends AbstractInterceptorDrivenBeanDefinitionDecorator {

		@Override
		protected BeanDefinition createInterceptorDefinition(Node node) {
			return new RootBeanDefinition(DebugInterceptor.class);
		}
	}

	// nop 装饰器
	private static class NopInterceptorBeanDefinitionDecorator extends AbstractInterceptorDrivenBeanDefinitionDecorator {

		@Override
		protected BeanDefinition createInterceptorDefinition(Node node) {
			return new RootBeanDefinition(NopInterceptor.class);
		}
	}

	// 属性为 object-name 的装饰器
	private static class ObjectNameBeanDefinitionDecorator implements BeanDefinitionDecorator {

		@Override
		public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {
			Attr objectNameAttribute = (Attr) node;
			definition.getBeanDefinition().setAttribute(&quot;objectName&quot;, objectNameAttribute.getValue());
			return definition;
		}
	}

}

```

通过运行结果可以看出这个装饰器可以针对与节点或者属性进行操作,相当于IO流中的设计模式一样,进行额外的增强.



# 三、小结

​	解析过了,也装饰过了,那就可以注册`BeanDefinitionHolder`对象了.</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">一、前言 ​ 在xml标签解析完之后会产生一个BeanDefinitionHolder对象,紧接着就来谈谈,spring用这个对象来干嘛吧. //DefaultBeanDefinitionDocumentReader.java protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // 解析xml元素 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { // 装饰 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. // 注册到容器中 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(&quot;Failed to register bean definition with name '&quot; + bdHolder.getBeanName() + &quot;'&quot;, ele, ex); } // Send registration event. // 发送事件 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } ​ 解析xml这边已经记录过了,接下来的重点在于delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);,从方法名可以看出意思大概为:如果有必要就进行装饰.说到装饰感觉跟装饰模式有关. 二、分析 public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef) { return decorateBeanDefinitionIfRequired(ele, originalDef, null); } /** * Decorate the given bean definition through a namespace handler, if applicable. * @param ele the current element * @param originalDef the current bean definition * @param containingBd the containing bean definition (if any) * @return the decorated bean definition */ public BeanDefinitionHolder decorateBeanDefinitionIfRequired( Element ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) { BeanDefinitionHolder finalDefinition = originalDef; // 遍历节点,寻找可以装饰的属性 // Decorate based on custom attributes first. NamedNodeMap attributes = ele.getAttributes(); for (int i = 0; i &amp;lt; attributes.getLength(); i++) { Node node = attributes.item(i); finalDefinition = decorateIfRequired(node, finalDefinition, containingBd); } // 遍历子节点,寻找可以装饰的子节点 // Decorate based on custom nested elements. NodeList children = ele.getChildNodes(); for (int i = 0; i &amp;lt; children.getLength(); i++) { Node node = children.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) { finalDefinition = decorateIfRequired(node, finalDefinition, containingBd); } } return finalDefinition; } 遍历当前节点的所有属性进行装饰 遍历当前节点的所有子节点进行装饰 返回BeanDefinitionHolder ​ 从上面可以看到核心方法在于decorateIfRequired,进去看一看. 2.1 decorateIfRequired public BeanDefinitionHolder decorateIfRequired( Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) { // 获取名称空间URI String namespaceUri = getNamespaceURI(node); // 判断是否是自定义名称空间,只对自定义名称空间进行处理 if (namespaceUri != null &amp;amp;&amp;amp; !isDefaultNamespace(namespaceUri)) { // 获取名称空间对应的处理器 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler != null) { // 进行装饰处理 BeanDefinitionHolder decorated = handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd)); if (decorated != null) { return decorated; } } else if (namespaceUri.startsWith(&quot;http://www.springframework.org/schema/&quot;)) { error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, node); } else { // A custom namespace, not to be handled by Spring - maybe &quot;xml:...&quot;. if (logger.isDebugEnabled()) { logger.debug(&quot;No Spring NamespaceHandler found for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;); } } } return originalDef; } 判断是否是默认名称命名空间 非默认进行装饰处理 ​ 那么这个装饰是个什么鬼呢？通过判断是否是默认名称空间这个条件感觉在前面分析的时候遇到过.从这个条件可以看出这个逻辑与最后达到的效果与前面自定义标签是一回事.可以看看官方给出的例子. 用于测试的xml &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:test=&quot;http://www.springframework.org/schema/beans/test&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util-2.0.xsd http://www.springframework.org/schema/beans/test https://www.springframework.org/schema/beans/factory/xml/support/CustomNamespaceHandlerTests.xsd&quot; default-lazy-init=&quot;true&quot;&amp;gt; &amp;lt;test:testBean id=&quot;testBean&quot; name=&quot;Rob Harrop&quot; age=&quot;23&quot;/&amp;gt; &amp;lt;bean id=&quot;customisedTestBean&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot;&amp;gt; &amp;lt;test:set name=&quot;Rob Harrop&quot; age=&quot;23&quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&quot;debuggingTestBean&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot;&amp;gt; &amp;lt;test:debug/&amp;gt; &amp;lt;property name=&quot;name&quot; value=&quot;Rob Harrop&quot;/&amp;gt; &amp;lt;property name=&quot;age&quot; value=&quot;23&quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&quot;debuggingTestBeanNoInstance&quot; class=&quot;org.springframework.context.ApplicationListener&quot;&amp;gt; &amp;lt;test:debug/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&quot;chainedTestBean&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot;&amp;gt; &amp;lt;test:debug/&amp;gt; &amp;lt;test:nop/&amp;gt; &amp;lt;property name=&quot;name&quot; value=&quot;Rob Harrop&quot;/&amp;gt; &amp;lt;property name=&quot;age&quot; value=&quot;23&quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&quot;decorateWithAttribute&quot; class=&quot;org.springframework.tests.sample.beans.TestBean&quot; test:object-name=&quot;foo&quot;/&amp;gt; &amp;lt;util:list id=&quot;list.of.things&quot;&amp;gt; &amp;lt;test:person name=&quot;Fiona Apple&quot; age=&quot;20&quot;/&amp;gt; &amp;lt;test:person name=&quot;Harriet Wheeler&quot; age=&quot;30&quot;/&amp;gt; &amp;lt;/util:list&amp;gt; &amp;lt;util:set id=&quot;set.of.things&quot;&amp;gt; &amp;lt;test:person name=&quot;Fiona Apple&quot; age=&quot;20&quot;/&amp;gt; &amp;lt;test:person name=&quot;Harriet Wheeler&quot; age=&quot;30&quot;/&amp;gt; &amp;lt;/util:set&amp;gt; &amp;lt;util:map id=&quot;map.of.things&quot;&amp;gt; &amp;lt;entry key=&quot;fiona.apple&quot;&amp;gt; &amp;lt;test:person name=&quot;Fiona Apple&quot; age=&quot;20&quot;/&amp;gt; &amp;lt;/entry&amp;gt; &amp;lt;entry key=&quot;harriet.wheeler&quot;&amp;gt; &amp;lt;test:person name=&quot;Harriet Wheeler&quot; age=&quot;30&quot;/&amp;gt; &amp;lt;/entry&amp;gt; &amp;lt;/util:map&amp;gt; &amp;lt;/beans&amp;gt; 用于测试的xsd文件 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&amp;gt; &amp;lt;xsd:schema xmlns=&quot;http://www.springframework.org/schema/beans/test&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://www.springframework.org/schema/beans/test&quot; elementFormDefault=&quot;qualified&quot;&amp;gt; &amp;lt;xsd:element name=&quot;person&quot;&amp;gt; &amp;lt;xsd:complexType&amp;gt; &amp;lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:string&quot; use=&quot;optional&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:integer&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;/xsd:complexType&amp;gt; &amp;lt;/xsd:element&amp;gt; &amp;lt;xsd:element name=&quot;testBean&quot;&amp;gt; &amp;lt;xsd:complexType&amp;gt; &amp;lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:integer&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;/xsd:complexType&amp;gt; &amp;lt;/xsd:element&amp;gt; &amp;lt;xsd:element name=&quot;set&quot;&amp;gt; &amp;lt;xsd:complexType&amp;gt; &amp;lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:integer&quot; use=&quot;required&quot; form=&quot;unqualified&quot;/&amp;gt; &amp;lt;/xsd:complexType&amp;gt; &amp;lt;/xsd:element&amp;gt; &amp;lt;xsd:element name=&quot;debug&quot;/&amp;gt; &amp;lt;xsd:element name=&quot;nop&quot;/&amp;gt; &amp;lt;xsd:attribute name=&quot;object-name&quot; type=&quot;xsd:string&quot;/&amp;gt; &amp;lt;/xsd:schema&amp;gt; 用于测试的property文件 http\://www.springframework.org/schema/beans/test=org.springframework.beans.factory.xml.support.TestNamespaceHandler http\://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler 测试代码 /* * Copyright 2002-2019 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.springframework.beans.factory.xml.support; import java.io.IOException; import java.util.Arrays; import java.util.List; import java.util.Map; import java.util.Set; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.w3c.dom.Attr; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.xml.sax.InputSource; import org.springframework.aop.Advisor; import org.springframework.aop.config.AbstractInterceptorDrivenBeanDefinitionDecorator; import org.springframework.aop.framework.Advised; import org.springframework.aop.interceptor.DebugInterceptor; import org.springframework.aop.support.AopUtils; import org.springframework.beans.BeanInstantiationException; import org.springframework.beans.MutablePropertyValues; import org.springframework.beans.factory.BeanCreationException; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.beans.factory.config.BeanDefinitionHolder; import org.springframework.beans.factory.support.AbstractBeanDefinition; import org.springframework.beans.factory.support.BeanDefinitionBuilder; import org.springframework.beans.factory.support.RootBeanDefinition; import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser; import org.springframework.beans.factory.xml.BeanDefinitionDecorator; import org.springframework.beans.factory.xml.BeanDefinitionParser; import org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver; import org.springframework.beans.factory.xml.NamespaceHandlerResolver; import org.springframework.beans.factory.xml.NamespaceHandlerSupport; import org.springframework.beans.factory.xml.ParserContext; import org.springframework.beans.factory.xml.PluggableSchemaResolver; import org.springframework.beans.factory.xml.XmlBeanDefinitionReader; import org.springframework.context.ApplicationListener; import org.springframework.context.support.GenericApplicationContext; import org.springframework.core.io.ClassPathResource; import org.springframework.core.io.Resource; import org.springframework.tests.aop.interceptor.NopInterceptor; import org.springframework.tests.sample.beans.ITestBean; import org.springframework.tests.sample.beans.TestBean; import static java.lang.String.format; import static org.assertj.core.api.Assertions.assertThat; import static org.assertj.core.api.Assertions.assertThatExceptionOfType; /** * Unit tests for custom XML namespace handler implementations. * * @author Rob Harrop * @author Rick Evans * @author Chris Beams * @author Juergen Hoeller */ public class CustomNamespaceHandlerTests { private static final Class&amp;lt;?&amp;gt; CLASS = CustomNamespaceHandlerTests.class; private static final String CLASSNAME = CLASS.getSimpleName(); private static final String FQ_PATH = &quot;org/springframework/beans/factory/xml/support&quot;; private static final String NS_PROPS = format(&quot;%s/%s.properties&quot;, FQ_PATH, CLASSNAME); private static final String NS_XML = format(&quot;%s/%s-context.xml&quot;, FQ_PATH, CLASSNAME); private static final String TEST_XSD = format(&quot;%s/%s.xsd&quot;, FQ_PATH, CLASSNAME); private GenericApplicationContext beanFactory; @BeforeEach public void setUp() throws Exception { NamespaceHandlerResolver resolver = new DefaultNamespaceHandlerResolver(CLASS.getClassLoader(), NS_PROPS); this.beanFactory = new GenericApplicationContext(); XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this.beanFactory); reader.setNamespaceHandlerResolver(resolver); reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_XSD); reader.setEntityResolver(new DummySchemaResolver()); reader.loadBeanDefinitions(getResource()); this.beanFactory.refresh(); } @Test public void testSimpleParser() throws Exception { TestBean bean = (TestBean) this.beanFactory.getBean(&quot;testBean&quot;); assertTestBean(bean); } @Test public void testSimpleDecorator() throws Exception { TestBean bean = (TestBean) this.beanFactory.getBean(&quot;customisedTestBean&quot;); assertTestBean(bean); } @Test public void testProxyingDecorator() throws Exception { ITestBean bean = (ITestBean) this.beanFactory.getBean(&quot;debuggingTestBean&quot;); assertTestBean(bean); assertThat(AopUtils.isAopProxy(bean)).isTrue(); Advisor[] advisors = ((Advised) bean).getAdvisors(); assertThat(advisors.length).as(&quot;Incorrect number of advisors&quot;).isEqualTo(1); assertThat(advisors[0].getAdvice().getClass()).as(&quot;Incorrect advice class&quot;).isEqualTo(DebugInterceptor.class); } @Test public void testProxyingDecoratorNoInstance() throws Exception { String[] beanNames = this.beanFactory.getBeanNamesForType(ApplicationListener.class); assertThat(Arrays.asList(beanNames).contains(&quot;debuggingTestBeanNoInstance&quot;)).isTrue(); assertThat(this.beanFactory.getType(&quot;debuggingTestBeanNoInstance&quot;)).isEqualTo(ApplicationListener.class); assertThatExceptionOfType(BeanCreationException.class).isThrownBy(() -&amp;gt; this.beanFactory.getBean(&quot;debuggingTestBeanNoInstance&quot;)) .satisfies(ex -&amp;gt; assertThat(ex.getRootCause()).isInstanceOf(BeanInstantiationException.class)); } @Test public void testChainedDecorators() throws Exception { ITestBean bean = (ITestBean) this.beanFactory.getBean(&quot;chainedTestBean&quot;); assertTestBean(bean); assertThat(AopUtils.isAopProxy(bean)).isTrue(); Advisor[] advisors = ((Advised) bean).getAdvisors(); assertThat(advisors.length).as(&quot;Incorrect number of advisors&quot;).isEqualTo(2); assertThat(advisors[0].getAdvice().getClass()).as(&quot;Incorrect advice class&quot;).isEqualTo(DebugInterceptor.class); assertThat(advisors[1].getAdvice().getClass()).as(&quot;Incorrect advice class&quot;).isEqualTo(NopInterceptor.class); } @Test public void testDecorationViaAttribute() throws Exception { BeanDefinition beanDefinition = this.beanFactory.getBeanDefinition(&quot;decorateWithAttribute&quot;); assertThat(beanDefinition.getAttribute(&quot;objectName&quot;)).isEqualTo(&quot;foo&quot;); } @Test // SPR-2728 public void testCustomElementNestedWithinUtilList() throws Exception { List&amp;lt;?&amp;gt; things = (List&amp;lt;?&amp;gt;) this.beanFactory.getBean(&quot;list.of.things&quot;); assertThat(things).isNotNull(); assertThat(things.size()).isEqualTo(2); } @Test // SPR-2728 public void testCustomElementNestedWithinUtilSet() throws Exception { Set&amp;lt;?&amp;gt; things = (Set&amp;lt;?&amp;gt;) this.beanFactory.getBean(&quot;set.of.things&quot;); assertThat(things).isNotNull(); assertThat(things.size()).isEqualTo(2); } @Test // SPR-2728 public void testCustomElementNestedWithinUtilMap() throws Exception { Map&amp;lt;?, ?&amp;gt; things = (Map&amp;lt;?, ?&amp;gt;) this.beanFactory.getBean(&quot;map.of.things&quot;); assertThat(things).isNotNull(); assertThat(things.size()).isEqualTo(2); } private void assertTestBean(ITestBean bean) { assertThat(bean.getName()).as(&quot;Invalid name&quot;).isEqualTo(&quot;Rob Harrop&quot;); assertThat(bean.getAge()).as(&quot;Invalid age&quot;).isEqualTo(23); } private Resource getResource() { return new ClassPathResource(NS_XML); } private final class DummySchemaResolver extends PluggableSchemaResolver { public DummySchemaResolver() { super(CLASS.getClassLoader()); } @Override public InputSource resolveEntity(String publicId, String systemId) throws IOException { InputSource source = super.resolveEntity(publicId, systemId); if (source == null) { Resource resource = new ClassPathResource(TEST_XSD); source = new InputSource(resource.getInputStream()); source.setPublicId(publicId); source.setSystemId(systemId); } return source; } } } /** * Custom namespace handler implementation. * 自定义名称空间处理器 * @author Rob Harrop */ final class TestNamespaceHandler extends NamespaceHandlerSupport { @Override public void init() { // 注册节点为 testBean 的解析器 registerBeanDefinitionParser(&quot;testBean&quot;, new TestBeanDefinitionParser()); // 注册节点为 person 的解析器 registerBeanDefinitionParser(&quot;person&quot;, new PersonDefinitionParser()); // 注册 set 装饰器 registerBeanDefinitionDecorator(&quot;set&quot;, new PropertyModifyingBeanDefinitionDecorator()); // 注册 debug 装饰器 registerBeanDefinitionDecorator(&quot;debug&quot;, new DebugBeanDefinitionDecorator()); // 注册 nop 装饰器 registerBeanDefinitionDecorator(&quot;nop&quot;, new NopInterceptorBeanDefinitionDecorator()); // 注册 属性为 object-name 的装饰器 registerBeanDefinitionDecoratorForAttribute(&quot;object-name&quot;, new ObjectNameBeanDefinitionDecorator()); } // 节点为 testBean 的解析器 private static class TestBeanDefinitionParser implements BeanDefinitionParser { @Override public BeanDefinition parse(Element element, ParserContext parserContext) { RootBeanDefinition definition = new RootBeanDefinition(); definition.setBeanClass(TestBean.class); MutablePropertyValues mpvs = new MutablePropertyValues(); mpvs.add(&quot;name&quot;, element.getAttribute(&quot;name&quot;)); mpvs.add(&quot;age&quot;, element.getAttribute(&quot;age&quot;)); definition.setPropertyValues(mpvs); parserContext.getRegistry().registerBeanDefinition(element.getAttribute(&quot;id&quot;), definition); return null; } } // 节点为 person 的解析器 private static final class PersonDefinitionParser extends AbstractSingleBeanDefinitionParser { @Override protected Class&amp;lt;?&amp;gt; getBeanClass(Element element) { return TestBean.class; } @Override protected void doParse(Element element, BeanDefinitionBuilder builder) { builder.addPropertyValue(&quot;name&quot;, element.getAttribute(&quot;name&quot;)); builder.addPropertyValue(&quot;age&quot;, element.getAttribute(&quot;age&quot;)); } } // set 装饰器 private static class PropertyModifyingBeanDefinitionDecorator implements BeanDefinitionDecorator { @Override public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) { Element element = (Element) node; BeanDefinition def = definition.getBeanDefinition(); MutablePropertyValues mpvs = (def.getPropertyValues() == null) ? new MutablePropertyValues() : def.getPropertyValues(); mpvs.add(&quot;name&quot;, element.getAttribute(&quot;name&quot;)); mpvs.add(&quot;age&quot;, element.getAttribute(&quot;age&quot;)); ((AbstractBeanDefinition) def).setPropertyValues(mpvs); return definition; } } // debug 装饰器 private static class DebugBeanDefinitionDecorator extends AbstractInterceptorDrivenBeanDefinitionDecorator { @Override protected BeanDefinition createInterceptorDefinition(Node node) { return new RootBeanDefinition(DebugInterceptor.class); } } // nop 装饰器 private static class NopInterceptorBeanDefinitionDecorator extends AbstractInterceptorDrivenBeanDefinitionDecorator { @Override protected BeanDefinition createInterceptorDefinition(Node node) { return new RootBeanDefinition(NopInterceptor.class); } } // 属性为 object-name 的装饰器 private static class ObjectNameBeanDefinitionDecorator implements BeanDefinitionDecorator { @Override public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) { Attr objectNameAttribute = (Attr) node; definition.getBeanDefinition().setAttribute(&quot;objectName&quot;, objectNameAttribute.getValue()); return definition; } } } 通过运行结果可以看出这个装饰器可以针对与节点或者属性进行操作,相当于IO流中的设计模式一样,进行额外的增强. 三、小结 ​ 解析过了,也装饰过了,那就可以注册BeanDefinitionHolder对象了.</summary></entry><entry><title type="html">[断点分析之spring-ioc]-bean标签解析(五)</title><link href="https://onew.me/spring/2020/02/19/debug-spring-5.html" rel="alternate" type="text/html" title="[断点分析之spring-ioc]-bean标签解析(五)" /><published>2020-02-19T14:20:25+08:00</published><updated>2020-02-19T14:20:25+08:00</updated><id>https://onew.me/spring/2020/02/19/debug-spring-5</id><content type="html" xml:base="https://onew.me/spring/2020/02/19/debug-spring-5.html"># 一、前言

​	分析了`import`标签、`alias`标签,顺势引出了`bean`标签,只不过`bean`标签逻辑较为复杂没有记录完.

# 二、从BeanDefinitionParserDelegate开始

```java
// BeanDefinitionParserDelegate
 @Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
		return parseBeanDefinitionElement(ele, null);
	}

	/**
	 * Parses the supplied {@code &lt;bean&gt;} element. May return {@code null}
	 * if there were errors during parse. Errors are reported to the
	 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
	 */
	@Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
		// 获取id
		String id = ele.getAttribute(ID_ATTRIBUTE);
		// 获取名称
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
		// 获取别名,别名可以使用多个
		List&lt;String&gt; aliases = new ArrayList&lt;&gt;();
		// 名称不为空
		if (StringUtils.hasLength(nameAttr)) {
			// 如果有多个名称,使用,;切割
			String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
			aliases.addAll(Arrays.asList(nameArr));
		}
		// bean名称就是id
		String beanName = id;
		// 如果名称为空,并且别名集合不为空,则从别名中获取第一个,作为名称
		if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {
			beanName = aliases.remove(0);
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName +
						&quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;);
			}
		}

		if (containingBean == null) {
			// 检查beanName是否唯一(名称未被使用过)
			checkNameUniqueness(beanName, aliases, ele);
		}
		// 解析标签封装为beanDefinition
		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
		// beanDefinition对象不为空
		if (beanDefinition != null) {
			// beanName为空
			if (!StringUtils.hasText(beanName)) {
				try {
					if (containingBean != null) {
						// 生成bean的 name
						beanName = BeanDefinitionReaderUtils.generateBeanName(
								beanDefinition, this.readerContext.getRegistry(), true);
					}
					else {
            // 生成bean的 name
						beanName = this.readerContext.generateBeanName(beanDefinition);
						// Register an alias for the plain bean class name, if still possible,
						// if the generator returned the class name plus a suffix.
						// This is expected for Spring 1.2/2.0 backwards compatibility.
            // 获取 className
						String beanClassName = beanDefinition.getBeanClassName();
            // 判断bean名称不为空 并且 以类名开头 并且名称没有被使用
						if (beanClassName != null &amp;&amp;
								beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;
								!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
							aliases.add(beanClassName);
						}
					}
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; +
								&quot;using generated bean name [&quot; + beanName + &quot;]&quot;);
					}
				}
				catch (Exception ex) {
					error(ex.getMessage(), ele);
					return null;
				}
			}
			// 别名集合转为数组
			String[] aliasesArray = StringUtils.toStringArray(aliases);
			// 返回BeanDefinitionHolder
			return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
		}

		return null;
	}
```

​	核心逻辑在于`	AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);`这句代码,进去看看.



## 2.1 parseBeanDefinitionElement

```java
  // BeanDefinitionParserDelegate
  @Nullable
	public AbstractBeanDefinition parseBeanDefinitionElement(
			Element ele, String beanName, @Nullable BeanDefinition containingBean) {
		// 放入状态对象到链表中
		this.parseState.push(new BeanEntry(beanName));

		String className = null;
		// 判断是否拥有class属性
		if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
			// 获取className属性值
			className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
		}
		String parent = null;
		// 判断是否拥有parent属性
		if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
			// 获取parent属性值
			parent = ele.getAttribute(PARENT_ATTRIBUTE);
		}
		try {
			// 创建BeanDefinitio对象,封装bean的描述信息
			AbstractBeanDefinition bd = createBeanDefinition(className, parent);
			// 解析bean标签中的各种属性,例如:singleton,scope,abstract等属性
			parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
			// 提取描述信息
			bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));
			// 解析元数据
			parseMetaElements(ele, bd);
			// 解析lookup-method,相当于动态代理了,可利用此功能来进行热插拔,不用修改代码
			// 此功能可以修改方法的返回值
			parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
			// 解析replaced-method,此功能可在运行过程中替换掉原有的方法,与lookup-method有点不同
			// 要替换需要实现MethodReplacer接口才能替换掉目标方法
			parseReplacedMethodSubElements(ele, bd.getMethodOverrides());
			// 解析构造方法参数
			parseConstructorArgElements(ele, bd);
			// 解析property属性
			parsePropertyElements(ele, bd);
			// 解析qualifier属性
			parseQualifierElements(ele, bd);

			bd.setResource(this.readerContext.getResource());
			bd.setSource(extractSource(ele));

			return bd;
		}
		catch (ClassNotFoundException ex) {
			error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);
		}
		catch (NoClassDefFoundError err) {
			error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);
		}
		catch (Throwable ex) {
			error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);
		}
		finally {
			// 弹出解析状态
			this.parseState.pop();
		}

		return null;
	}

```

1. 判断是否拥有class属性,获取class属性值
2. 判断是否拥有parent属性,获取parent属性值
3. 创建`AbstractBeanDefinition`对象
4. 解析`bean`标签中的描述信息,例如:singleton,scope,abstract等属性
5. 提取描述信息
6. 解析元数据
7. 解析`lookup-method`
8. 解析`replaced-method`
9. 解析构造方法参数
10. 解析`property`属性
11. 解析`qualifier`属性

大体逻辑如上,以上步骤从步骤3开始进行分析.



## 2.2 createBeanDefinition

```java
// BeanDefinitionParserDelegate
protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)
			throws ClassNotFoundException {

		return BeanDefinitionReaderUtils.createBeanDefinition(
				parentName, className, this.readerContext.getBeanClassLoader());
	}
```

```java
// BeanDefinitionReaderUtils
public static AbstractBeanDefinition createBeanDefinition(
			@Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException {

		GenericBeanDefinition bd = new GenericBeanDefinition();
		bd.setParentName(parentName);
		if (className != null) {
			if (classLoader != null) {
				// 加载类
				bd.setBeanClass(ClassUtils.forName(className, classLoader));
			}
			else {
				// 如果class-loader为空则只记录类名
				bd.setBeanClassName(className);
			}
		}
		return bd;
	}
```

1. 判断类加载器是否为空,如果类加载器不为空则使用指定的类加载器加载类
2. 返回`GenericBeanDefinition`对象

以上逻辑比较简单,重点是`GenericBeanDefinition`这个对象.



## 2.3 GenericBeanDefinition

​	`GenericBeanDefinition`是用于描述`bean`,该类继承了`AbstractBeanDefinition`.如下图:

![images](https://gitee.com/oneww/onew_image/raw/master/GenericBeanDefinition.png)

​	总共有2个作用,描述`bean`的信息,访问`bean`中的属性值.

## 2.4 parseBeanDefinitionAttributes

```java
// BeanDefinitionParserDelegate
public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,
			@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {
		// 解析singleton属性
		// singleton属性不能使用,已经过时
		if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {
			error(&quot;Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration&quot;, ele);
		}
		// 判断是否存在scope属性
		else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {
			// 设置scope属性值
			bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));
		}
		else if (containingBean != null) {
			// Take default from containing bean in case of an inner bean definition.
			bd.setScope(containingBean.getScope());
		}
		// 判断是否存在abstract属性
		if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {
			// 设置abstract属性值
			bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));
		}
		// 解析lazy-init属性
		String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);
		if (isDefaultValue(lazyInit)) {
			lazyInit = this.defaults.getLazyInit();
		}
		// 设置懒加载值
		bd.setLazyInit(TRUE_VALUE.equals(lazyInit));
		// 获取自动装配属性值
		String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);
		// 设置自动装配模式
		bd.setAutowireMode(getAutowireMode(autowire));
		// 判断是否存在depends-on属性
		if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
			// 获取depends-on属性值
			String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);
			// 设置depends-on属性值
			bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));
		}
		// 解析autowire属性,自动装配.存在条件判断
		String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);
		if (isDefaultValue(autowireCandidate)) {
			String candidatePattern = this.defaults.getAutowireCandidates();
			if (candidatePattern != null) {
				String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);
				bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));
			}
		}
		else {
			// 设置autowire-candidate属性值
			bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));
		}
		// 判断是否存在primary属性
		if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {
			// 设置primary值
			bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));
		}
		// 判断是否存在init属性
		if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {
			// 获取init属性值
			String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);
			// 设置init属性值
			bd.setInitMethodName(initMethodName);
		}
		// 设置init属性默认值
		else if (this.defaults.getInitMethod() != null) {
			bd.setInitMethodName(this.defaults.getInitMethod());
			bd.setEnforceInitMethod(false);
		}
		// 判断是否存在destroy属性
		if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {
			// 获取destroy属性值
			String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);
			// 设置destroy属性值
			bd.setDestroyMethodName(destroyMethodName);
		}
		// 设置destroy属性默认值
		else if (this.defaults.getDestroyMethod() != null) {
			bd.setDestroyMethodName(this.defaults.getDestroyMethod());
			bd.setEnforceDestroyMethod(false);
		}
		// 判断是否存在factory属性
		if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {
			// 设置factory属性值
			bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));
		}
		// 判断是否存在factory-bean属性
		if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {
			// 设置factory-bean属性值
			bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));
		}

		return bd;
	}
```

1. 设置`BeanDefinition`的scope属性值
2. 设置`BeanDefinition`的abstract属性值
3. 设置`BeanDefinition`的lazy-init属性值
4. 设置`BeanDefinition`的autowire属性值
5. 设置`BeanDefinition`的depends-on属性值
6. 设置`BeanDefinition`的autowire-candidate属性值
7. 设置`BeanDefinition`的primary属性值
8. 设置`BeanDefinition`的init-method属性值
9. 设置`BeanDefinition`的destroy-method属性值
10. 设置`BeanDefinition`的factory-method属性值
11. 设置`BeanDefinition`的factory-bean的属性值

以上代码就是对`BeanDefinition`对象的一个属性填充.



## 2.5 parseMetaElements

```java
// BeanDefinitionParserDelegate
public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {
		// 解析元数据
		NodeList nl = ele.getChildNodes();
		for (int i = 0; i &lt; nl.getLength(); i++) {
			Node node = nl.item(i);
			// 解析meta标签
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) {
				Element metaElement = (Element) node;
				String key = metaElement.getAttribute(KEY_ATTRIBUTE);
				String value = metaElement.getAttribute(VALUE_ATTRIBUTE);
				// 使用kv方式创建对象
				BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);
				attribute.setSource(extractSource(metaElement));
				// 记录属性
				attributeAccessor.addMetadataAttribute(attribute);
			}
		}
	}

```

	1. 遍历所有节点
 	2. 解析meta标签
 	3. 设置值到attributeAccessor中



## 2.6 parseLookupOverrideSubElements

```java
	// BeanDefinitionParserDelegate
public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) {
		// 获取所有子节点
		NodeList nl = beanEle.getChildNodes();
		for (int i = 0; i &lt; nl.getLength(); i++) {
			// 遍历子节点
			Node node = nl.item(i);
			// 判断是lookup-method 节点
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) {
				Element ele = (Element) node;
				// 获取name属性 方法名
				String methodName = ele.getAttribute(NAME_ATTRIBUTE);
				// 获取bean属性 用于替代的bean名称,用于引用bean对象
				String beanRef = ele.getAttribute(BEAN_ELEMENT);
				// 创建LookupOverride 对象
				LookupOverride override = new LookupOverride(methodName, beanRef);
				override.setSource(extractSource(ele));
				// 添加到overrides对象中的集合中
				overrides.addOverride(override);
			}
		}
	}
```

1. 遍历所有节点
2. 获取name属性
3. 获取bean属性
4. 创建`LookupOverride`对象
5. 添加到`MethodOverrides`中

​	`lookup-method`这个东西,相当于是替换一个方法,与`replaced-method`这个有些许不同.在后面处理bean的时候还会再次出现.



## 2.7 parseReplacedMethodSubElements

```java
// BeanDefinitionParserDelegate
public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {
		// 获取所有节点
		NodeList nl = beanEle.getChildNodes();
		for (int i = 0; i &lt; nl.getLength(); i++) {
			// 遍历所有节点
			Node node = nl.item(i);
			// 判断是replaced-method 节点
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) {
				Element replacedMethodEle = (Element) node;
				// 获取name属性
				String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);
				// 获取replacer 属性
				String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);
				// 创建ReplaceOverride 对象
				ReplaceOverride replaceOverride = new ReplaceOverride(name, callback);
				// Look for arg-type match elements.
				// 获取arg-type 子节点
				List&lt;Element&gt; argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);
				// 遍历arg-type 节点
				for (Element argTypeEle : argTypeEles) {
					// 获取match 属性
					String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);
					// 如果match属性为空 说明有子节点循环遍历子节点值,拼装参数
					// 如果match属性不为空 match 值就为本身
					match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));
					if (StringUtils.hasText(match)) {
						replaceOverride.addTypeIdentifier(match);
					}
				}
				replaceOverride.setSource(extractSource(replacedMethodEle));
				// 添加到集合
				overrides.addOverride(replaceOverride);
			}
		}
	}

```

​	逻辑与lookup-method处理的差不多.



## 2.8 parseConstructorArgElements

```java
// BeanDefinitionParserDelegate
public void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {
		// 获取所有子节点
		NodeList nl = beanEle.getChildNodes();
		for (int i = 0; i &lt; nl.getLength(); i++) {
			// 遍历子节点
			Node node = nl.item(i);
			// 判断是constructor-arg 节点
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {
				parseConstructorArgElement((Element) node, bd);
			}
		}
	}

```

1. 遍历所有节点
2. 查找节点`constructor-arg`
3. 解析参数

解析参数的逻辑单独在一个方法中`parseConstructorArgElement`。

```java
// BeanDefinitionParserDelegate
public void parseConstructorArgElement(Element ele, BeanDefinition bd) {
		// 提取 index 属性
		String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);
		// 提取 type 属性
		String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);
		// 提取 name 属性
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
		// 处理 index 属性逻辑
		if (StringUtils.hasLength(indexAttr)) {
			try {
				// 下标转换为 int
				int index = Integer.parseInt(indexAttr);
				// 下标不允许小于0
				if (index &lt; 0) {
					error(&quot;'index' cannot be lower than 0&quot;, ele);
				}
				else {
					try {
						this.parseState.push(new ConstructorArgumentEntry(index));
						// 解析 properties 属性
						Object value = parsePropertyValue(ele, bd, null);
						ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
						// 设置 typeAttr 属性值
						if (StringUtils.hasLength(typeAttr)) {
							valueHolder.setType(typeAttr);
						}
						// 设置 name 属性值
						if (StringUtils.hasLength(nameAttr)) {
							valueHolder.setName(nameAttr);
						}
						valueHolder.setSource(extractSource(ele));
						// 判断下标是否重复
						if (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) {
							error(&quot;Ambiguous constructor-arg entries for index &quot; + index, ele);
						}
						else {
							// 添加 下标 参数
							bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);
						}
					}
					finally {
						this.parseState.pop();
					}
				}
			}
			catch (NumberFormatException ex) {
				error(&quot;Attribute 'index' of tag 'constructor-arg' must be an integer&quot;, ele);
			}
		}
		else {
			// 不包含 index 属性处理逻辑
			try {
				this.parseState.push(new ConstructorArgumentEntry());
				Object value = parsePropertyValue(ele, bd, null);
				ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
				if (StringUtils.hasLength(typeAttr)) {
					valueHolder.setType(typeAttr);
				}
				if (StringUtils.hasLength(nameAttr)) {
					valueHolder.setName(nameAttr);
				}
				valueHolder.setSource(extractSource(ele));
				bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);
			}
			finally {
				this.parseState.pop();
			}
		}
	}
```

通过判断是否有index属性来进行解析配置文件.解析参数的代码为`parsePropertyValue(ele, bd, null);`

```java
// BeanDefinitionParserDelegate
@Nullable
	public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {
		String elementName = (propertyName != null ?
				&quot;&lt;property&gt; element for property '&quot; + propertyName + &quot;'&quot; :
				&quot;&lt;constructor-arg&gt; element&quot;);

		// Should only have one child element: ref, value, list, etc.
		// 获取所有子节点
		NodeList nl = ele.getChildNodes();
		Element subElement = null;
		// 遍历所有子节点
		for (int i = 0; i &lt; nl.getLength(); i++) {
			Node node = nl.item(i);
			// description 节点 和 meta节点 不处理
			if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;
					!nodeNameEquals(node, META_ELEMENT)) {
				// Child element is what we're looking for.
				if (subElement != null) {
					error(elementName + &quot; must not contain more than one sub-element&quot;, ele);
				}
				else {
					subElement = (Element) node;
				}
			}
		}
		// 判断是够包含 ref 属性
		boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);
		// 判断是否包含 value 属性
		boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);
		// 如果 [[同时包含 ref 属性 和 value 属性] 或者 [[包含 ref 属性 或者 value属性 之一] 并且 subElement 不为空]]
		// 则 抛出异常
		if ((hasRefAttribute &amp;&amp; hasValueAttribute) ||
				((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) {
			error(elementName +
					&quot; is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element&quot;, ele);
		}
		// 处理只包含 ref 属性逻辑
		if (hasRefAttribute) {
			// 获取 ref 属性值
			String refName = ele.getAttribute(REF_ATTRIBUTE);
			// 如果 ref 属性值为空 error
			if (!StringUtils.hasText(refName)) {
				error(elementName + &quot; contains empty 'ref' attribute&quot;, ele);
			}
			// 创建 RuntimeBeanReference 对象
			RuntimeBeanReference ref = new RuntimeBeanReference(refName);
			ref.setSource(extractSource(ele));
			return ref;
		}
		// 处理值包含 value 属性逻辑
		else if (hasValueAttribute) {
			// 创建 TypedStringValue 对象
			TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));
			valueHolder.setSource(extractSource(ele));
			return valueHolder;
		}
		// 处理只有子元素逻辑
		else if (subElement != null) {
			return parsePropertySubElement(subElement, bd);
		}
		// error
		else {
			// Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found.
			error(elementName + &quot; must specify a ref or value&quot;, ele);
			return null;
		}
	}
```

1. 遍历所有节点
2. description 和 meta 节点不处理,跳过.
3. 判断是否包含 ref 属性
4. 判断是否包含 value 属性
5. 处理 ref
6. 处理 value
7. 处理子元素

​	处理逻辑不复杂,复杂点的可能是在处理子元素的实时,相对复杂点.通常子元素的处理就是把值转换为 Map\List\Set等数据结构.处理子元素的方法是`parsePropertySubElement`.

```java
// BeanDefinitionParserDelegate
@Nullable
	public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) {
		return parsePropertySubElement(ele, bd, null);
	}

	/**
	 * Parse a value, ref or collection sub-element of a property or
	 * constructor-arg element.
	 * @param ele subelement of property element; we don't know which yet
	 * @param bd the current bean definition (if any)
	 * @param defaultValueType the default type (class name) for any
	 * {@code &lt;value&gt;} tag that might be created
	 */
	@Nullable
	public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) {
		// 处理非默认名称空间
		if (!isDefaultNamespace(ele)) {
			return parseNestedCustomElement(ele, bd);
		}
		// 处理 bean
		else if (nodeNameEquals(ele, BEAN_ELEMENT)) {
			BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);
			if (nestedBd != null) {
				nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);
			}
			return nestedBd;
		}
		// 处理 ref
		else if (nodeNameEquals(ele, REF_ELEMENT)) {
			// A generic reference to any name of any bean.
			// 获取 需要引用的 bean 名称
			String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);
			boolean toParent = false;
			// 如果 需要引用的bean 名称为空
			if (!StringUtils.hasLength(refName)) {
				// A reference to the id of another bean in a parent context.
				// 获取 需要引用的parent 属性
				refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);
				toParent = true;
				// 如果 bean 为空 并且 parent 属性都为空 则 error
				if (!StringUtils.hasLength(refName)) {
					error(&quot;'bean' or 'parent' is required for &lt;ref&gt; element&quot;, ele);
					return null;
				}
			}
			// 如果需要引用的 bean 名称 依然为空 则 error
			if (!StringUtils.hasText(refName)) {
				error(&quot;&lt;ref&gt; element contains empty target attribute&quot;, ele);
				return null;
			}
			// 创建 RuntimeBeanReference 对象
			RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);
			ref.setSource(extractSource(ele));
			return ref;
		}
		// 处理 idref
		else if (nodeNameEquals(ele, IDREF_ELEMENT)) {
			return parseIdRefElement(ele);
		}
		// 处理 value
		else if (nodeNameEquals(ele, VALUE_ELEMENT)) {
			return parseValueElement(ele, defaultValueType);
		}
		// 处理 null
		else if (nodeNameEquals(ele, NULL_ELEMENT)) {
			// It's a distinguished null value. Let's wrap it in a TypedStringValue
			// object in order to preserve the source location.
			// 创建 TypedStringValue 对象
			TypedStringValue nullHolder = new TypedStringValue(null);
			nullHolder.setSource(extractSource(ele));
			return nullHolder;
		}
		// 处理 array
		else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {
			return parseArrayElement(ele, bd);
		}
		// 处理 list
		else if (nodeNameEquals(ele, LIST_ELEMENT)) {
			return parseListElement(ele, bd);
		}
		// 处理 set
		else if (nodeNameEquals(ele, SET_ELEMENT)) {
			return parseSetElement(ele, bd);
		}
		// 处理 map
		else if (nodeNameEquals(ele, MAP_ELEMENT)) {
			return parseMapElement(ele, bd);
		}
		// 处理 props
		else if (nodeNameEquals(ele, PROPS_ELEMENT)) {
			return parsePropsElement(ele);
		}
		// error
		else {
			error(&quot;Unknown property sub-element: [&quot; + ele.getNodeName() + &quot;]&quot;, ele);
			return null;
		}
	}
```

​	开头就是一个判断,判断是否是默认名称空间,如果非默认名称空间采用自定义解析逻辑.



### 2.8.1 自定义解析

​	创建自定义xsd

```xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
			xmlns=&quot;https://onew.me/schema/adv&quot;
			targetNamespace=&quot;https://onew.me/schema/adv&quot; elementFormDefault=&quot;qualified&quot;&gt;
	&lt;xsd:element name=&quot;AdvProp&quot;&gt;
		&lt;xsd:complexType&gt;
			&lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; /&gt;
			&lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:string&quot; /&gt;
		&lt;/xsd:complexType&gt;
	&lt;/xsd:element&gt;

&lt;/xsd:schema&gt;
```

​	创建类

```java
package com.sjr.test.bean;

public class AdvProp {

	private String name;

	private String age;

	public String getName() {
		return name;
	}

	public AdvProp setName(String name) {
		this.name = name;
		return this;
	}

	public String getAge() {
		return age;
	}

	public AdvProp setAge(String age) {
		this.age = age;
		return this;
	}
}

```

​	修改测试类

```java
package com.sjr.test.bean;

public class MyTestBean {

	private AdvProp advProp;

	private String testStr = &quot;test--one&quot;;

	public MyTestBean(AdvProp advProp) {
		this.advProp = advProp;
	}

	public MyTestBean() {
	}

	public String getTestStr() {
		return testStr;
	}

	public MyTestBean setTestStr(String testStr) {
		this.testStr = testStr;
		return this;
	}

	public AdvProp getAdvProp() {
		return advProp;
	}

	public MyTestBean setAdvProp(AdvProp advProp) {
		this.advProp = advProp;
		return this;
	}

	public void printAdvProp(){
		System.out.println(&quot;advProp: age-&quot; + advProp.getAge() + &quot;,name-&quot; + advProp.getName());
	}
}

```

​	创建自定义解析类

```java
public class TestAdvPropParser extends AbstractSingleBeanDefinitionParser {

	@Override
	protected Class&lt;?&gt; getBeanClass(Element element) {
		return AdvProp.class;
	}

	@Override
	protected void doParse(Element element, BeanDefinitionBuilder builder) {
		final String name = element.getAttribute(&quot;name&quot;);
		final String age = element.getAttribute(&quot;age&quot;);
		builder.addPropertyValue(&quot;name&quot;,name);
		builder.addPropertyValue(&quot;age&quot;,age);
	}
}

```

​	创建自定义NamespaceHandler类

```java
public class TestNamespaceHandler extends NamespaceHandlerSupport {

	@Override
	public void init() {
		registerBeanDefinitionParser(&quot;AdvProp&quot;,new TestAdvPropParser());
	}
}

```

​	配置spring.handlers

```properties
https\://onew.me/schema/adv=com.sjr.test.handler.TestNamespaceHandler
```

​	配置spring.schemas

```properties
https\://onew.me/schema/adv/AdvProp.xsd=com/sjr/test/bean/AdvProp.xsd
```

​	配置xml

```xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	   xmlns:adv=&quot;https://onew.me/schema/adv&quot;
	   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                       https://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                       https://onew.me/schema/adv https://onew.me/schema/adv/AdvProp.xsd
&quot;&gt;
	&lt;bean id=&quot;myTestBean&quot; class=&quot;com.sjr.test.bean.MyTestBean&quot;&gt;
		&lt;constructor-arg&gt;
			&lt;adv:AdvProp  name=&quot;testAdv&quot; age=&quot;31&quot;/&gt;
		&lt;/constructor-arg&gt;
	&lt;/bean&gt;
&lt;/beans&gt;

```

​	修改测试代码

```java
@Test
	public void testSpringAdvParseTag(){
		BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/AdvTestBean.xml&quot;));
		final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);
		testBean.printAdvProp();
	}
```

​	运行结果

```properties
advProp: age-31,name-testAdv
```



1. `TestNamespaceHandler`用于注册自定义解析器
2. `TestAdvPropParser`用于解析自定义标签
3. `spring.schemas`用于描述xsd文件路径
4. `spring.handlers`用于指定自定义名称空间使用指定的handler



### 2.8.2 解析bean标签

​	解析逻辑与bean标签逻辑一致

```java
// BeanDefinitionParserDelegate	
// 处理 bean
		else if (nodeNameEquals(ele, BEAN_ELEMENT)) {
			BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);
			if (nestedBd != null) {
				nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);
			}
			return nestedBd;
		}
```

### 2.8.3 解析ref标签

```java
// BeanDefinitionParserDelegate
if (nodeNameEquals(ele, REF_ELEMENT)) {
			// A generic reference to any name of any bean.
			// 获取 需要引用的 bean 名称
			String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);
			boolean toParent = false;
			// 如果 需要引用的bean 名称为空
			if (!StringUtils.hasLength(refName)) {
				// A reference to the id of another bean in a parent context.
				// 获取 需要引用的parent 属性
				refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);
				toParent = true;
				// 如果 bean 为空 并且 parent 属性都为空 则 error
				if (!StringUtils.hasLength(refName)) {
					error(&quot;'bean' or 'parent' is required for &lt;ref&gt; element&quot;, ele);
					return null;
				}
			}
			// 如果需要引用的 bean 名称 依然为空 则 error
			if (!StringUtils.hasText(refName)) {
				error(&quot;&lt;ref&gt; element contains empty target attribute&quot;, ele);
				return null;
			}
			// 创建 RuntimeBeanReference 对象
			RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);
			ref.setSource(extractSource(ele));
			return ref;
		}
```

### 2.8.4 解析idref标签

```java
	// BeanDefinitionParserDelegate
	@Nullable
	public Object parseIdRefElement(Element ele) {
		// A generic reference to any name of any bean.
		// 获取需要引用的 bean 属性
		String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);
		// 引用的名称为空 则 error
		if (!StringUtils.hasLength(refName)) {
			error(&quot;'bean' is required for &lt;idref&gt; element&quot;, ele);
			return null;
		}
		// 引用的名称为空 则 error
		if (!StringUtils.hasText(refName)) {
			error(&quot;&lt;idref&gt; element contains empty target attribute&quot;, ele);
			return null;
		}
		// 创建 RuntimeBeanNameReference
		RuntimeBeanNameReference ref = new RuntimeBeanNameReference(refName);
		ref.setSource(extractSource(ele));
		return ref;
	}
```

### 2.8.5 解析value标签

```java
	// BeanDefinitionParserDelegate
	public Object parseValueElement(Element ele, @Nullable String defaultTypeName) {
		// It's a literal value.
		// 获取文本值
		String value = DomUtils.getTextValue(ele);
		// 获取 type 属性
		String specifiedTypeName = ele.getAttribute(TYPE_ATTRIBUTE);
		String typeName = specifiedTypeName;
		// 如果 type 属性为空 则 设置为默认的 type
		if (!StringUtils.hasText(typeName)) {
			// 默认为 null
			typeName = defaultTypeName;
		}
		try {
			// 创建 TypedStringValue 对象
			TypedStringValue typedValue = buildTypedStringValue(value, typeName);
			typedValue.setSource(extractSource(ele));
			typedValue.setSpecifiedTypeName(specifiedTypeName);
			return typedValue;
		}
		catch (ClassNotFoundException ex) {
			error(&quot;Type class [&quot; + typeName + &quot;] not found for &lt;value&gt; element&quot;, ele, ex);
			return value;
		}
	}

```

### 2.8.6 解析array 标签

```java
	// BeanDefinitionParserDelegate
public Object parseArrayElement(Element arrayEle, @Nullable BeanDefinition bd) {
		// 获取 value-type 属性
		String elementType = arrayEle.getAttribute(VALUE_TYPE_ATTRIBUTE);
		// 获取所有子节点
		NodeList nl = arrayEle.getChildNodes();
		// 创建 ManagedArray 对象
		ManagedArray target = new ManagedArray(elementType, nl.getLength());
		target.setSource(extractSource(arrayEle));
		target.setElementTypeName(elementType);
		target.setMergeEnabled(parseMergeAttribute(arrayEle));
		parseCollectionElements(nl, target, bd, elementType);
		return target;
	}
```

### 2.8.7 解析list标签

```java
	// BeanDefinitionParserDelegate
public List&lt;Object&gt; parseListElement(Element collectionEle, @Nullable BeanDefinition bd) {
		// 获取 value-type 属性
		String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);
		// 获取所有子节点
		NodeList nl = collectionEle.getChildNodes();
		// 创建 ManagedList 对象
		ManagedList&lt;Object&gt; target = new ManagedList&lt;&gt;(nl.getLength());
		target.setSource(extractSource(collectionEle));
		target.setElementTypeName(defaultElementType);
		target.setMergeEnabled(parseMergeAttribute(collectionEle));
		parseCollectionElements(nl, target, bd, defaultElementType);
		return target;
	}
```

### 2.8.8 解析set标签

```java
	// BeanDefinitionParserDelegate
public Set&lt;Object&gt; parseSetElement(Element collectionEle, @Nullable BeanDefinition bd) {
		// 获取 value-type 属性
		String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);
		// 获取所有子节点
		NodeList nl = collectionEle.getChildNodes();
		// 创建 ManagedSet 对象
		ManagedSet&lt;Object&gt; target = new ManagedSet&lt;&gt;(nl.getLength());
		target.setSource(extractSource(collectionEle));
		target.setElementTypeName(defaultElementType);
		target.setMergeEnabled(parseMergeAttribute(collectionEle));
		parseCollectionElements(nl, target, bd, defaultElementType);
		return target;
	}
```



### 2.8.9 解析map标签

```java
	// BeanDefinitionParserDelegate
public Map&lt;Object, Object&gt; parseMapElement(Element mapEle, @Nullable BeanDefinition bd) {
		// 获取 key-type 属性值
		String defaultKeyType = mapEle.getAttribute(KEY_TYPE_ATTRIBUTE);
		// 获取 value-type 属性值
		String defaultValueType = mapEle.getAttribute(VALUE_TYPE_ATTRIBUTE);

		// 获取 entry 子节点
		List&lt;Element&gt; entryEles = DomUtils.getChildElementsByTagName(mapEle, ENTRY_ELEMENT);
		// 创建 ManagedMap 对象
		ManagedMap&lt;Object, Object&gt; map = new ManagedMap&lt;&gt;(entryEles.size());
		map.setSource(extractSource(mapEle));
		map.setKeyTypeName(defaultKeyType);
		map.setValueTypeName(defaultValueType);
		map.setMergeEnabled(parseMergeAttribute(mapEle));

		// 遍历 entryEles 集合
		for (Element entryEle : entryEles) {
			// Should only have one value child element: ref, value, list, etc.
			// Optionally, there might be a key child element.
			// 获取子节点
			NodeList entrySubNodes = entryEle.getChildNodes();
			Element keyEle = null;
			Element valueEle = null;
			// 遍历 entrySubNodes
			for (int j = 0; j &lt; entrySubNodes.getLength(); j++) {
				Node node = entrySubNodes.item(j);
				if (node instanceof Element) {
					Element candidateEle = (Element) node;
					// 处理 key 节点逻辑
					if (nodeNameEquals(candidateEle, KEY_ELEMENT)) {
						if (keyEle != null) {
							error(&quot;&lt;entry&gt; element is only allowed to contain one &lt;key&gt; sub-element&quot;, entryEle);
						}
						else {
							keyEle = candidateEle;
						}
					}
					else {
						// 忽略 description 节点
						// Child element is what we're looking for.
						if (nodeNameEquals(candidateEle, DESCRIPTION_ELEMENT)) {
							// the element is a &lt;description&gt; -&gt; ignore it
						}
						else if (valueEle != null) {
							error(&quot;&lt;entry&gt; element must not contain more than one value sub-element&quot;, entryEle);
						}
						else {
							valueEle = candidateEle;
						}
					}
				}
			}

			// Extract key from attribute or sub-element.
			Object key = null;
			// 判断是否包含 key 属性
			boolean hasKeyAttribute = entryEle.hasAttribute(KEY_ATTRIBUTE);
			// 判断是否包含 key-ref 属性
			boolean hasKeyRefAttribute = entryEle.hasAttribute(KEY_REF_ATTRIBUTE);
			// 如果 [[包含 key 属性 并且 包含 key-ref 属性] 或者 [[包含 key 属性 或 包含 key-ref 之一]] 并且 keyEle 不为空]
			// 则 报错
			if ((hasKeyAttribute &amp;&amp; hasKeyRefAttribute) ||
					(hasKeyAttribute || hasKeyRefAttribute) &amp;&amp; keyEle != null) {
				error(&quot;&lt;entry&gt; element is only allowed to contain either &quot; +
						&quot;a 'key' attribute OR a 'key-ref' attribute OR a &lt;key&gt; sub-element&quot;, entryEle);
			}
			// 处理 key 属性
			if (hasKeyAttribute) {
				key = buildTypedStringValueForMap(entryEle.getAttribute(KEY_ATTRIBUTE), defaultKeyType, entryEle);
			}
			// 处理 key-ref 属性
			else if (hasKeyRefAttribute) {
				String refName = entryEle.getAttribute(KEY_REF_ATTRIBUTE);
				if (!StringUtils.hasText(refName)) {
					error(&quot;&lt;entry&gt; element contains empty 'key-ref' attribute&quot;, entryEle);
				}
				RuntimeBeanReference ref = new RuntimeBeanReference(refName);
				ref.setSource(extractSource(entryEle));
				key = ref;
			}
			else if (keyEle != null) {
				key = parseKeyElement(keyEle, bd, defaultKeyType);
			}
			else {
				error(&quot;&lt;entry&gt; element must specify a key&quot;, entryEle);
			}

			// Extract value from attribute or sub-element.
			Object value = null;
			// 判断 是否包含 value 属性
			boolean hasValueAttribute = entryEle.hasAttribute(VALUE_ATTRIBUTE);
			// 判断 是否包含 value-ref 属性
			boolean hasValueRefAttribute = entryEle.hasAttribute(VALUE_REF_ATTRIBUTE);
			// 判断 是否包含 value-type 属性
			boolean hasValueTypeAttribute = entryEle.hasAttribute(VALUE_TYPE_ATTRIBUTE);
			if ((hasValueAttribute &amp;&amp; hasValueRefAttribute) ||
					(hasValueAttribute || hasValueRefAttribute) &amp;&amp; valueEle != null) {
				error(&quot;&lt;entry&gt; element is only allowed to contain either &quot; +
						&quot;'value' attribute OR 'value-ref' attribute OR &lt;value&gt; sub-element&quot;, entryEle);
			}
			if ((hasValueTypeAttribute &amp;&amp; hasValueRefAttribute) ||
				(hasValueTypeAttribute &amp;&amp; !hasValueAttribute) ||
					(hasValueTypeAttribute &amp;&amp; valueEle != null)) {
				error(&quot;&lt;entry&gt; element is only allowed to contain a 'value-type' &quot; +
						&quot;attribute when it has a 'value' attribute&quot;, entryEle);
			}
			// 处理 value 属性
			if (hasValueAttribute) {
				String valueType = entryEle.getAttribute(VALUE_TYPE_ATTRIBUTE);
				if (!StringUtils.hasText(valueType)) {
					valueType = defaultValueType;
				}
				value = buildTypedStringValueForMap(entryEle.getAttribute(VALUE_ATTRIBUTE), valueType, entryEle);
			}
			// 处理 value-ref 属性
			else if (hasValueRefAttribute) {
				String refName = entryEle.getAttribute(VALUE_REF_ATTRIBUTE);
				if (!StringUtils.hasText(refName)) {
					error(&quot;&lt;entry&gt; element contains empty 'value-ref' attribute&quot;, entryEle);
				}
				RuntimeBeanReference ref = new RuntimeBeanReference(refName);
				ref.setSource(extractSource(entryEle));
				value = ref;
			}
			// 处理 valueEle
			else if (valueEle != null) {
				value = parsePropertySubElement(valueEle, bd, defaultValueType);
			}
			else {
				error(&quot;&lt;entry&gt; element must specify a value&quot;, entryEle);
			}

			// Add final key and value to the Map.
			// 添加最终的 key 和 value 到 map 中去
			map.put(key, value);
		}

		return map;
	}
```

转换为map的时候逻辑稍微有点复杂,慢慢看,还是能看懂.

### 2.8.10 解析props标签

```java
	// BeanDefinitionParserDelegate
public Properties parsePropsElement(Element propsEle) {
		// 创建 ManagedProperties 对象
		ManagedProperties props = new ManagedProperties();
		props.setSource(extractSource(propsEle));
		props.setMergeEnabled(parseMergeAttribute(propsEle));

		//获取节点下面素有 prop 节点
		List&lt;Element&gt; propEles = DomUtils.getChildElementsByTagName(propsEle, PROP_ELEMENT);
		// 遍历 prop 节点
		for (Element propEle : propEles) {
			// 获取 key
			String key = propEle.getAttribute(KEY_ATTRIBUTE);
			// Trim the text value to avoid unwanted whitespace
			// caused by typical XML formatting.
			// 获取 值
			String value = DomUtils.getTextValue(propEle).trim();
			TypedStringValue keyHolder = new TypedStringValue(key);
			keyHolder.setSource(extractSource(propEle));
			TypedStringValue valueHolder = new TypedStringValue(value);
			valueHolder.setSource(extractSource(propEle));
			// 放入到 props 对象中
			props.put(keyHolder, valueHolder);
		}

		return props;
	}
```



## 2.9 parsePropertyElements

```java
	// BeanDefinitionParserDelegate	
 public void parsePropertyElements(Element beanEle, BeanDefinition bd) {
		// 获取所有子节点
		NodeList nl = beanEle.getChildNodes();
		for (int i = 0; i &lt; nl.getLength(); i++) {
			// 遍历 所有节点
			Node node = nl.item(i);
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) {
				parsePropertyElement((Element) node, bd);
			}
		}
	}
	
	public void parsePropertyElement(Element ele, BeanDefinition bd) {
		// 获取 name 属性
		String propertyName = ele.getAttribute(NAME_ATTRIBUTE);
		// name 属性为空 则报错
		if (!StringUtils.hasLength(propertyName)) {
			error(&quot;Tag 'property' must have a 'name' attribute&quot;, ele);
			return;
		}
		this.parseState.push(new PropertyEntry(propertyName));
		try {
			// 属性名相同则报错
			if (bd.getPropertyValues().contains(propertyName)) {
				error(&quot;Multiple 'property' definitions for property '&quot; + propertyName + &quot;'&quot;, ele);
				return;
			}
			Object val = parsePropertyValue(ele, bd, propertyName);
			PropertyValue pv = new PropertyValue(propertyName, val);
			parseMetaElements(ele, pv);
			pv.setSource(extractSource(ele));
			bd.getPropertyValues().addPropertyValue(pv);
		}
		finally {
			this.parseState.pop();
		}
	}
```

1. 遍历所有节点
2. 使用`parsePropertyValue`方法处理值(该方法已经写到过)
3. 把解析到的值放入`BeanDefinition`中去



## 2.10 parseQualifierElements

```java
	// BeanDefinitionParserDelegate
public void parseQualifierElements(Element beanEle, AbstractBeanDefinition bd) {
		// 获取所有子节点
		NodeList nl = beanEle.getChildNodes();
		for (int i = 0; i &lt; nl.getLength(); i++) {
			// 遍历所有子节点
			Node node = nl.item(i);
			// 处理 qualifier 节点
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ELEMENT)) {
				parseQualifierElement((Element) node, bd);
			}
		}
	}
	
```

1. 遍历所有节点
2. 通过`parseQualifierElement`方法处理

```java
// BeanDefinitionParserDelegate
public void parseQualifierElement(Element ele, AbstractBeanDefinition bd) {
		// 获取 type 属性
		String typeName = ele.getAttribute(TYPE_ATTRIBUTE);
		// 如果 type 属性为空 则 error
		if (!StringUtils.hasLength(typeName)) {
			error(&quot;Tag 'qualifier' must have a 'type' attribute&quot;, ele);
			return;
		}
		this.parseState.push(new QualifierEntry(typeName));
		try {
			// 创建 AutowireCandidateQualifier 对象
			AutowireCandidateQualifier qualifier = new AutowireCandidateQualifier(typeName);
			qualifier.setSource(extractSource(ele));
			// 获取 value 属性
			String value = ele.getAttribute(VALUE_ATTRIBUTE);
			if (StringUtils.hasLength(value)) {
				qualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value);
			}
			// 获取当前节点下的所有节点
			NodeList nl = ele.getChildNodes();
			for (int i = 0; i &lt; nl.getLength(); i++) {
				// 遍历所有子节点
				Node node = nl.item(i);
				// 处理 attribute 属性
				if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) {
					Element attributeEle = (Element) node;
					// 获取 key 属性
					String attributeName = attributeEle.getAttribute(KEY_ATTRIBUTE);
					// 获取 value 属性
					String attributeValue = attributeEle.getAttribute(VALUE_ATTRIBUTE);
					// key and value is not null
					if (StringUtils.hasLength(attributeName) &amp;&amp; StringUtils.hasLength(attributeValue)) {
						BeanMetadataAttribute attribute = new BeanMetadataAttribute(attributeName, attributeValue);
						attribute.setSource(extractSource(attributeEle));
						qualifier.addMetadataAttribute(attribute);
					}
					else {
						error(&quot;Qualifier 'attribute' tag must have a 'name' and 'value'&quot;, attributeEle);
						return;
					}
				}
			}
			bd.addQualifier(qualifier);
		}
		finally {
			this.parseState.pop();
		}
	}
```

1. 遍历所有节点
2. 把获取到的kv全部放入到`AutowireCandidateQualifier`对象中去
3. `BeanDefinition`对象设置`qualifier`属性



# 三、小结

​	至此已经创建一了一个完整的`AbstractBeanDefinition`对象,一个对bean信息的描述对象有了,会转为`BeanDefinitionHolder`为后续操作作为基础.</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">一、前言 ​ 分析了import标签、alias标签,顺势引出了bean标签,只不过bean标签逻辑较为复杂没有记录完. 二、从BeanDefinitionParserDelegate开始 // BeanDefinitionParserDelegate @Nullable public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { return parseBeanDefinitionElement(ele, null); } /** * Parses the supplied {@code &amp;lt;bean&amp;gt;} element. May return {@code null} * if there were errors during parse. Errors are reported to the * {@link org.springframework.beans.factory.parsing.ProblemReporter}. */ @Nullable public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) { // 获取id String id = ele.getAttribute(ID_ATTRIBUTE); // 获取名称 String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); // 获取别名,别名可以使用多个 List&amp;lt;String&amp;gt; aliases = new ArrayList&amp;lt;&amp;gt;(); // 名称不为空 if (StringUtils.hasLength(nameAttr)) { // 如果有多个名称,使用,;切割 String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } // bean名称就是id String beanName = id; // 如果名称为空,并且别名集合不为空,则从别名中获取第一个,作为名称 if (!StringUtils.hasText(beanName) &amp;amp;&amp;amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isTraceEnabled()) { logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName + &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;); } } if (containingBean == null) { // 检查beanName是否唯一(名称未被使用过) checkNameUniqueness(beanName, aliases, ele); } // 解析标签封装为beanDefinition AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); // beanDefinition对象不为空 if (beanDefinition != null) { // beanName为空 if (!StringUtils.hasText(beanName)) { try { if (containingBean != null) { // 生成bean的 name beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { // 生成bean的 name beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. // 获取 className String beanClassName = beanDefinition.getBeanClassName(); // 判断bean名称不为空 并且 以类名开头 并且名称没有被使用 if (beanClassName != null &amp;amp;&amp;amp; beanName.startsWith(beanClassName) &amp;amp;&amp;amp; beanName.length() &amp;gt; beanClassName.length() &amp;amp;&amp;amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { aliases.add(beanClassName); } } if (logger.isTraceEnabled()) { logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } // 别名集合转为数组 String[] aliasesArray = StringUtils.toStringArray(aliases); // 返回BeanDefinitionHolder return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } return null; } ​ 核心逻辑在于 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);这句代码,进去看看. 2.1 parseBeanDefinitionElement // BeanDefinitionParserDelegate @Nullable public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) { // 放入状态对象到链表中 this.parseState.push(new BeanEntry(beanName)); String className = null; // 判断是否拥有class属性 if (ele.hasAttribute(CLASS_ATTRIBUTE)) { // 获取className属性值 className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } String parent = null; // 判断是否拥有parent属性 if (ele.hasAttribute(PARENT_ATTRIBUTE)) { // 获取parent属性值 parent = ele.getAttribute(PARENT_ATTRIBUTE); } try { // 创建BeanDefinitio对象,封装bean的描述信息 AbstractBeanDefinition bd = createBeanDefinition(className, parent); // 解析bean标签中的各种属性,例如:singleton,scope,abstract等属性 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); // 提取描述信息 bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); // 解析元数据 parseMetaElements(ele, bd); // 解析lookup-method,相当于动态代理了,可利用此功能来进行热插拔,不用修改代码 // 此功能可以修改方法的返回值 parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); // 解析replaced-method,此功能可在运行过程中替换掉原有的方法,与lookup-method有点不同 // 要替换需要实现MethodReplacer接口才能替换掉目标方法 parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 解析构造方法参数 parseConstructorArgElements(ele, bd); // 解析property属性 parsePropertyElements(ele, bd); // 解析qualifier属性 parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex); } catch (NoClassDefFoundError err) { error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err); } catch (Throwable ex) { error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex); } finally { // 弹出解析状态 this.parseState.pop(); } return null; } 判断是否拥有class属性,获取class属性值 判断是否拥有parent属性,获取parent属性值 创建AbstractBeanDefinition对象 解析bean标签中的描述信息,例如:singleton,scope,abstract等属性 提取描述信息 解析元数据 解析lookup-method 解析replaced-method 解析构造方法参数 解析property属性 解析qualifier属性 大体逻辑如上,以上步骤从步骤3开始进行分析. 2.2 createBeanDefinition // BeanDefinitionParserDelegate protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName) throws ClassNotFoundException { return BeanDefinitionReaderUtils.createBeanDefinition( parentName, className, this.readerContext.getBeanClassLoader()); } // BeanDefinitionReaderUtils public static AbstractBeanDefinition createBeanDefinition( @Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException { GenericBeanDefinition bd = new GenericBeanDefinition(); bd.setParentName(parentName); if (className != null) { if (classLoader != null) { // 加载类 bd.setBeanClass(ClassUtils.forName(className, classLoader)); } else { // 如果class-loader为空则只记录类名 bd.setBeanClassName(className); } } return bd; } 判断类加载器是否为空,如果类加载器不为空则使用指定的类加载器加载类 返回GenericBeanDefinition对象 以上逻辑比较简单,重点是GenericBeanDefinition这个对象. 2.3 GenericBeanDefinition ​ GenericBeanDefinition是用于描述bean,该类继承了AbstractBeanDefinition.如下图: ​ 总共有2个作用,描述bean的信息,访问bean中的属性值. 2.4 parseBeanDefinitionAttributes // BeanDefinitionParserDelegate public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName, @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) { // 解析singleton属性 // singleton属性不能使用,已经过时 if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) { error(&quot;Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration&quot;, ele); } // 判断是否存在scope属性 else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) { // 设置scope属性值 bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE)); } else if (containingBean != null) { // Take default from containing bean in case of an inner bean definition. bd.setScope(containingBean.getScope()); } // 判断是否存在abstract属性 if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) { // 设置abstract属性值 bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE))); } // 解析lazy-init属性 String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE); if (isDefaultValue(lazyInit)) { lazyInit = this.defaults.getLazyInit(); } // 设置懒加载值 bd.setLazyInit(TRUE_VALUE.equals(lazyInit)); // 获取自动装配属性值 String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE); // 设置自动装配模式 bd.setAutowireMode(getAutowireMode(autowire)); // 判断是否存在depends-on属性 if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) { // 获取depends-on属性值 String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE); // 设置depends-on属性值 bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS)); } // 解析autowire属性,自动装配.存在条件判断 String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE); if (isDefaultValue(autowireCandidate)) { String candidatePattern = this.defaults.getAutowireCandidates(); if (candidatePattern != null) { String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern); bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName)); } } else { // 设置autowire-candidate属性值 bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate)); } // 判断是否存在primary属性 if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) { // 设置primary值 bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE))); } // 判断是否存在init属性 if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) { // 获取init属性值 String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE); // 设置init属性值 bd.setInitMethodName(initMethodName); } // 设置init属性默认值 else if (this.defaults.getInitMethod() != null) { bd.setInitMethodName(this.defaults.getInitMethod()); bd.setEnforceInitMethod(false); } // 判断是否存在destroy属性 if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) { // 获取destroy属性值 String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE); // 设置destroy属性值 bd.setDestroyMethodName(destroyMethodName); } // 设置destroy属性默认值 else if (this.defaults.getDestroyMethod() != null) { bd.setDestroyMethodName(this.defaults.getDestroyMethod()); bd.setEnforceDestroyMethod(false); } // 判断是否存在factory属性 if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) { // 设置factory属性值 bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE)); } // 判断是否存在factory-bean属性 if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) { // 设置factory-bean属性值 bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE)); } return bd; } 设置BeanDefinition的scope属性值 设置BeanDefinition的abstract属性值 设置BeanDefinition的lazy-init属性值 设置BeanDefinition的autowire属性值 设置BeanDefinition的depends-on属性值 设置BeanDefinition的autowire-candidate属性值 设置BeanDefinition的primary属性值 设置BeanDefinition的init-method属性值 设置BeanDefinition的destroy-method属性值 设置BeanDefinition的factory-method属性值 设置BeanDefinition的factory-bean的属性值 以上代码就是对BeanDefinition对象的一个属性填充. 2.5 parseMetaElements // BeanDefinitionParserDelegate public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) { // 解析元数据 NodeList nl = ele.getChildNodes(); for (int i = 0; i &amp;lt; nl.getLength(); i++) { Node node = nl.item(i); // 解析meta标签 if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, META_ELEMENT)) { Element metaElement = (Element) node; String key = metaElement.getAttribute(KEY_ATTRIBUTE); String value = metaElement.getAttribute(VALUE_ATTRIBUTE); // 使用kv方式创建对象 BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value); attribute.setSource(extractSource(metaElement)); // 记录属性 attributeAccessor.addMetadataAttribute(attribute); } } } 1. 遍历所有节点 2. 解析meta标签 3. 设置值到attributeAccessor中 2.6 parseLookupOverrideSubElements // BeanDefinitionParserDelegate public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) { // 获取所有子节点 NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &amp;lt; nl.getLength(); i++) { // 遍历子节点 Node node = nl.item(i); // 判断是lookup-method 节点 if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) { Element ele = (Element) node; // 获取name属性 方法名 String methodName = ele.getAttribute(NAME_ATTRIBUTE); // 获取bean属性 用于替代的bean名称,用于引用bean对象 String beanRef = ele.getAttribute(BEAN_ELEMENT); // 创建LookupOverride 对象 LookupOverride override = new LookupOverride(methodName, beanRef); override.setSource(extractSource(ele)); // 添加到overrides对象中的集合中 overrides.addOverride(override); } } } 遍历所有节点 获取name属性 获取bean属性 创建LookupOverride对象 添加到MethodOverrides中 ​ lookup-method这个东西,相当于是替换一个方法,与replaced-method这个有些许不同.在后面处理bean的时候还会再次出现. 2.7 parseReplacedMethodSubElements // BeanDefinitionParserDelegate public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) { // 获取所有节点 NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &amp;lt; nl.getLength(); i++) { // 遍历所有节点 Node node = nl.item(i); // 判断是replaced-method 节点 if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) { Element replacedMethodEle = (Element) node; // 获取name属性 String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE); // 获取replacer 属性 String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE); // 创建ReplaceOverride 对象 ReplaceOverride replaceOverride = new ReplaceOverride(name, callback); // Look for arg-type match elements. // 获取arg-type 子节点 List&amp;lt;Element&amp;gt; argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT); // 遍历arg-type 节点 for (Element argTypeEle : argTypeEles) { // 获取match 属性 String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE); // 如果match属性为空 说明有子节点循环遍历子节点值,拼装参数 // 如果match属性不为空 match 值就为本身 match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle)); if (StringUtils.hasText(match)) { replaceOverride.addTypeIdentifier(match); } } replaceOverride.setSource(extractSource(replacedMethodEle)); // 添加到集合 overrides.addOverride(replaceOverride); } } } ​ 逻辑与lookup-method处理的差不多. 2.8 parseConstructorArgElements // BeanDefinitionParserDelegate public void parseConstructorArgElements(Element beanEle, BeanDefinition bd) { // 获取所有子节点 NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &amp;lt; nl.getLength(); i++) { // 遍历子节点 Node node = nl.item(i); // 判断是constructor-arg 节点 if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) { parseConstructorArgElement((Element) node, bd); } } } 遍历所有节点 查找节点constructor-arg 解析参数 解析参数的逻辑单独在一个方法中parseConstructorArgElement。 // BeanDefinitionParserDelegate public void parseConstructorArgElement(Element ele, BeanDefinition bd) { // 提取 index 属性 String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE); // 提取 type 属性 String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE); // 提取 name 属性 String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); // 处理 index 属性逻辑 if (StringUtils.hasLength(indexAttr)) { try { // 下标转换为 int int index = Integer.parseInt(indexAttr); // 下标不允许小于0 if (index &amp;lt; 0) { error(&quot;'index' cannot be lower than 0&quot;, ele); } else { try { this.parseState.push(new ConstructorArgumentEntry(index)); // 解析 properties 属性 Object value = parsePropertyValue(ele, bd, null); ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value); // 设置 typeAttr 属性值 if (StringUtils.hasLength(typeAttr)) { valueHolder.setType(typeAttr); } // 设置 name 属性值 if (StringUtils.hasLength(nameAttr)) { valueHolder.setName(nameAttr); } valueHolder.setSource(extractSource(ele)); // 判断下标是否重复 if (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) { error(&quot;Ambiguous constructor-arg entries for index &quot; + index, ele); } else { // 添加 下标 参数 bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder); } } finally { this.parseState.pop(); } } } catch (NumberFormatException ex) { error(&quot;Attribute 'index' of tag 'constructor-arg' must be an integer&quot;, ele); } } else { // 不包含 index 属性处理逻辑 try { this.parseState.push(new ConstructorArgumentEntry()); Object value = parsePropertyValue(ele, bd, null); ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value); if (StringUtils.hasLength(typeAttr)) { valueHolder.setType(typeAttr); } if (StringUtils.hasLength(nameAttr)) { valueHolder.setName(nameAttr); } valueHolder.setSource(extractSource(ele)); bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder); } finally { this.parseState.pop(); } } } 通过判断是否有index属性来进行解析配置文件.解析参数的代码为parsePropertyValue(ele, bd, null); // BeanDefinitionParserDelegate @Nullable public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) { String elementName = (propertyName != null ? &quot;&amp;lt;property&amp;gt; element for property '&quot; + propertyName + &quot;'&quot; : &quot;&amp;lt;constructor-arg&amp;gt; element&quot;); // Should only have one child element: ref, value, list, etc. // 获取所有子节点 NodeList nl = ele.getChildNodes(); Element subElement = null; // 遍历所有子节点 for (int i = 0; i &amp;lt; nl.getLength(); i++) { Node node = nl.item(i); // description 节点 和 meta节点 不处理 if (node instanceof Element &amp;amp;&amp;amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;amp;&amp;amp; !nodeNameEquals(node, META_ELEMENT)) { // Child element is what we're looking for. if (subElement != null) { error(elementName + &quot; must not contain more than one sub-element&quot;, ele); } else { subElement = (Element) node; } } } // 判断是够包含 ref 属性 boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE); // 判断是否包含 value 属性 boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE); // 如果 [[同时包含 ref 属性 和 value 属性] 或者 [[包含 ref 属性 或者 value属性 之一] 并且 subElement 不为空]] // 则 抛出异常 if ((hasRefAttribute &amp;amp;&amp;amp; hasValueAttribute) || ((hasRefAttribute || hasValueAttribute) &amp;amp;&amp;amp; subElement != null)) { error(elementName + &quot; is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element&quot;, ele); } // 处理只包含 ref 属性逻辑 if (hasRefAttribute) { // 获取 ref 属性值 String refName = ele.getAttribute(REF_ATTRIBUTE); // 如果 ref 属性值为空 error if (!StringUtils.hasText(refName)) { error(elementName + &quot; contains empty 'ref' attribute&quot;, ele); } // 创建 RuntimeBeanReference 对象 RuntimeBeanReference ref = new RuntimeBeanReference(refName); ref.setSource(extractSource(ele)); return ref; } // 处理值包含 value 属性逻辑 else if (hasValueAttribute) { // 创建 TypedStringValue 对象 TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE)); valueHolder.setSource(extractSource(ele)); return valueHolder; } // 处理只有子元素逻辑 else if (subElement != null) { return parsePropertySubElement(subElement, bd); } // error else { // Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found. error(elementName + &quot; must specify a ref or value&quot;, ele); return null; } } 遍历所有节点 description 和 meta 节点不处理,跳过. 判断是否包含 ref 属性 判断是否包含 value 属性 处理 ref 处理 value 处理子元素 ​ 处理逻辑不复杂,复杂点的可能是在处理子元素的实时,相对复杂点.通常子元素的处理就是把值转换为 Map\List\Set等数据结构.处理子元素的方法是parsePropertySubElement. // BeanDefinitionParserDelegate @Nullable public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) { return parsePropertySubElement(ele, bd, null); } /** * Parse a value, ref or collection sub-element of a property or * constructor-arg element. * @param ele subelement of property element; we don't know which yet * @param bd the current bean definition (if any) * @param defaultValueType the default type (class name) for any * {@code &amp;lt;value&amp;gt;} tag that might be created */ @Nullable public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) { // 处理非默认名称空间 if (!isDefaultNamespace(ele)) { return parseNestedCustomElement(ele, bd); } // 处理 bean else if (nodeNameEquals(ele, BEAN_ELEMENT)) { BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd); if (nestedBd != null) { nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd); } return nestedBd; } // 处理 ref else if (nodeNameEquals(ele, REF_ELEMENT)) { // A generic reference to any name of any bean. // 获取 需要引用的 bean 名称 String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE); boolean toParent = false; // 如果 需要引用的bean 名称为空 if (!StringUtils.hasLength(refName)) { // A reference to the id of another bean in a parent context. // 获取 需要引用的parent 属性 refName = ele.getAttribute(PARENT_REF_ATTRIBUTE); toParent = true; // 如果 bean 为空 并且 parent 属性都为空 则 error if (!StringUtils.hasLength(refName)) { error(&quot;'bean' or 'parent' is required for &amp;lt;ref&amp;gt; element&quot;, ele); return null; } } // 如果需要引用的 bean 名称 依然为空 则 error if (!StringUtils.hasText(refName)) { error(&quot;&amp;lt;ref&amp;gt; element contains empty target attribute&quot;, ele); return null; } // 创建 RuntimeBeanReference 对象 RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent); ref.setSource(extractSource(ele)); return ref; } // 处理 idref else if (nodeNameEquals(ele, IDREF_ELEMENT)) { return parseIdRefElement(ele); } // 处理 value else if (nodeNameEquals(ele, VALUE_ELEMENT)) { return parseValueElement(ele, defaultValueType); } // 处理 null else if (nodeNameEquals(ele, NULL_ELEMENT)) { // It's a distinguished null value. Let's wrap it in a TypedStringValue // object in order to preserve the source location. // 创建 TypedStringValue 对象 TypedStringValue nullHolder = new TypedStringValue(null); nullHolder.setSource(extractSource(ele)); return nullHolder; } // 处理 array else if (nodeNameEquals(ele, ARRAY_ELEMENT)) { return parseArrayElement(ele, bd); } // 处理 list else if (nodeNameEquals(ele, LIST_ELEMENT)) { return parseListElement(ele, bd); } // 处理 set else if (nodeNameEquals(ele, SET_ELEMENT)) { return parseSetElement(ele, bd); } // 处理 map else if (nodeNameEquals(ele, MAP_ELEMENT)) { return parseMapElement(ele, bd); } // 处理 props else if (nodeNameEquals(ele, PROPS_ELEMENT)) { return parsePropsElement(ele); } // error else { error(&quot;Unknown property sub-element: [&quot; + ele.getNodeName() + &quot;]&quot;, ele); return null; } } ​ 开头就是一个判断,判断是否是默认名称空间,如果非默认名称空间采用自定义解析逻辑. 2.8.1 自定义解析 ​ 创建自定义xsd &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns=&quot;https://onew.me/schema/adv&quot; targetNamespace=&quot;https://onew.me/schema/adv&quot; elementFormDefault=&quot;qualified&quot;&amp;gt; &amp;lt;xsd:element name=&quot;AdvProp&quot;&amp;gt; &amp;lt;xsd:complexType&amp;gt; &amp;lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; /&amp;gt; &amp;lt;xsd:attribute name=&quot;age&quot; type=&quot;xsd:string&quot; /&amp;gt; &amp;lt;/xsd:complexType&amp;gt; &amp;lt;/xsd:element&amp;gt; &amp;lt;/xsd:schema&amp;gt; ​ 创建类 package com.sjr.test.bean; public class AdvProp { private String name; private String age; public String getName() { return name; } public AdvProp setName(String name) { this.name = name; return this; } public String getAge() { return age; } public AdvProp setAge(String age) { this.age = age; return this; } } ​ 修改测试类 package com.sjr.test.bean; public class MyTestBean { private AdvProp advProp; private String testStr = &quot;test--one&quot;; public MyTestBean(AdvProp advProp) { this.advProp = advProp; } public MyTestBean() { } public String getTestStr() { return testStr; } public MyTestBean setTestStr(String testStr) { this.testStr = testStr; return this; } public AdvProp getAdvProp() { return advProp; } public MyTestBean setAdvProp(AdvProp advProp) { this.advProp = advProp; return this; } public void printAdvProp(){ System.out.println(&quot;advProp: age-&quot; + advProp.getAge() + &quot;,name-&quot; + advProp.getName()); } } ​ 创建自定义解析类 public class TestAdvPropParser extends AbstractSingleBeanDefinitionParser { @Override protected Class&amp;lt;?&amp;gt; getBeanClass(Element element) { return AdvProp.class; } @Override protected void doParse(Element element, BeanDefinitionBuilder builder) { final String name = element.getAttribute(&quot;name&quot;); final String age = element.getAttribute(&quot;age&quot;); builder.addPropertyValue(&quot;name&quot;,name); builder.addPropertyValue(&quot;age&quot;,age); } } ​ 创建自定义NamespaceHandler类 public class TestNamespaceHandler extends NamespaceHandlerSupport { @Override public void init() { registerBeanDefinitionParser(&quot;AdvProp&quot;,new TestAdvPropParser()); } } ​ 配置spring.handlers https\://onew.me/schema/adv=com.sjr.test.handler.TestNamespaceHandler ​ 配置spring.schemas https\://onew.me/schema/adv/AdvProp.xsd=com/sjr/test/bean/AdvProp.xsd ​ 配置xml &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&amp;gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:adv=&quot;https://onew.me/schema/adv&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd https://onew.me/schema/adv https://onew.me/schema/adv/AdvProp.xsd &quot;&amp;gt; &amp;lt;bean id=&quot;myTestBean&quot; class=&quot;com.sjr.test.bean.MyTestBean&quot;&amp;gt; &amp;lt;constructor-arg&amp;gt; &amp;lt;adv:AdvProp name=&quot;testAdv&quot; age=&quot;31&quot;/&amp;gt; &amp;lt;/constructor-arg&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/beans&amp;gt; ​ 修改测试代码 @Test public void testSpringAdvParseTag(){ BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/AdvTestBean.xml&quot;)); final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class); testBean.printAdvProp(); } ​ 运行结果 advProp: age-31,name-testAdv TestNamespaceHandler用于注册自定义解析器 TestAdvPropParser用于解析自定义标签 spring.schemas用于描述xsd文件路径 spring.handlers用于指定自定义名称空间使用指定的handler 2.8.2 解析bean标签 ​ 解析逻辑与bean标签逻辑一致 // BeanDefinitionParserDelegate // 处理 bean else if (nodeNameEquals(ele, BEAN_ELEMENT)) { BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd); if (nestedBd != null) { nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd); } return nestedBd; } 2.8.3 解析ref标签 // BeanDefinitionParserDelegate if (nodeNameEquals(ele, REF_ELEMENT)) { // A generic reference to any name of any bean. // 获取 需要引用的 bean 名称 String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE); boolean toParent = false; // 如果 需要引用的bean 名称为空 if (!StringUtils.hasLength(refName)) { // A reference to the id of another bean in a parent context. // 获取 需要引用的parent 属性 refName = ele.getAttribute(PARENT_REF_ATTRIBUTE); toParent = true; // 如果 bean 为空 并且 parent 属性都为空 则 error if (!StringUtils.hasLength(refName)) { error(&quot;'bean' or 'parent' is required for &amp;lt;ref&amp;gt; element&quot;, ele); return null; } } // 如果需要引用的 bean 名称 依然为空 则 error if (!StringUtils.hasText(refName)) { error(&quot;&amp;lt;ref&amp;gt; element contains empty target attribute&quot;, ele); return null; } // 创建 RuntimeBeanReference 对象 RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent); ref.setSource(extractSource(ele)); return ref; } 2.8.4 解析idref标签 // BeanDefinitionParserDelegate @Nullable public Object parseIdRefElement(Element ele) { // A generic reference to any name of any bean. // 获取需要引用的 bean 属性 String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE); // 引用的名称为空 则 error if (!StringUtils.hasLength(refName)) { error(&quot;'bean' is required for &amp;lt;idref&amp;gt; element&quot;, ele); return null; } // 引用的名称为空 则 error if (!StringUtils.hasText(refName)) { error(&quot;&amp;lt;idref&amp;gt; element contains empty target attribute&quot;, ele); return null; } // 创建 RuntimeBeanNameReference RuntimeBeanNameReference ref = new RuntimeBeanNameReference(refName); ref.setSource(extractSource(ele)); return ref; } 2.8.5 解析value标签 // BeanDefinitionParserDelegate public Object parseValueElement(Element ele, @Nullable String defaultTypeName) { // It's a literal value. // 获取文本值 String value = DomUtils.getTextValue(ele); // 获取 type 属性 String specifiedTypeName = ele.getAttribute(TYPE_ATTRIBUTE); String typeName = specifiedTypeName; // 如果 type 属性为空 则 设置为默认的 type if (!StringUtils.hasText(typeName)) { // 默认为 null typeName = defaultTypeName; } try { // 创建 TypedStringValue 对象 TypedStringValue typedValue = buildTypedStringValue(value, typeName); typedValue.setSource(extractSource(ele)); typedValue.setSpecifiedTypeName(specifiedTypeName); return typedValue; } catch (ClassNotFoundException ex) { error(&quot;Type class [&quot; + typeName + &quot;] not found for &amp;lt;value&amp;gt; element&quot;, ele, ex); return value; } } 2.8.6 解析array 标签 // BeanDefinitionParserDelegate public Object parseArrayElement(Element arrayEle, @Nullable BeanDefinition bd) { // 获取 value-type 属性 String elementType = arrayEle.getAttribute(VALUE_TYPE_ATTRIBUTE); // 获取所有子节点 NodeList nl = arrayEle.getChildNodes(); // 创建 ManagedArray 对象 ManagedArray target = new ManagedArray(elementType, nl.getLength()); target.setSource(extractSource(arrayEle)); target.setElementTypeName(elementType); target.setMergeEnabled(parseMergeAttribute(arrayEle)); parseCollectionElements(nl, target, bd, elementType); return target; } 2.8.7 解析list标签 // BeanDefinitionParserDelegate public List&amp;lt;Object&amp;gt; parseListElement(Element collectionEle, @Nullable BeanDefinition bd) { // 获取 value-type 属性 String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE); // 获取所有子节点 NodeList nl = collectionEle.getChildNodes(); // 创建 ManagedList 对象 ManagedList&amp;lt;Object&amp;gt; target = new ManagedList&amp;lt;&amp;gt;(nl.getLength()); target.setSource(extractSource(collectionEle)); target.setElementTypeName(defaultElementType); target.setMergeEnabled(parseMergeAttribute(collectionEle)); parseCollectionElements(nl, target, bd, defaultElementType); return target; } 2.8.8 解析set标签 // BeanDefinitionParserDelegate public Set&amp;lt;Object&amp;gt; parseSetElement(Element collectionEle, @Nullable BeanDefinition bd) { // 获取 value-type 属性 String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE); // 获取所有子节点 NodeList nl = collectionEle.getChildNodes(); // 创建 ManagedSet 对象 ManagedSet&amp;lt;Object&amp;gt; target = new ManagedSet&amp;lt;&amp;gt;(nl.getLength()); target.setSource(extractSource(collectionEle)); target.setElementTypeName(defaultElementType); target.setMergeEnabled(parseMergeAttribute(collectionEle)); parseCollectionElements(nl, target, bd, defaultElementType); return target; } 2.8.9 解析map标签 // BeanDefinitionParserDelegate public Map&amp;lt;Object, Object&amp;gt; parseMapElement(Element mapEle, @Nullable BeanDefinition bd) { // 获取 key-type 属性值 String defaultKeyType = mapEle.getAttribute(KEY_TYPE_ATTRIBUTE); // 获取 value-type 属性值 String defaultValueType = mapEle.getAttribute(VALUE_TYPE_ATTRIBUTE); // 获取 entry 子节点 List&amp;lt;Element&amp;gt; entryEles = DomUtils.getChildElementsByTagName(mapEle, ENTRY_ELEMENT); // 创建 ManagedMap 对象 ManagedMap&amp;lt;Object, Object&amp;gt; map = new ManagedMap&amp;lt;&amp;gt;(entryEles.size()); map.setSource(extractSource(mapEle)); map.setKeyTypeName(defaultKeyType); map.setValueTypeName(defaultValueType); map.setMergeEnabled(parseMergeAttribute(mapEle)); // 遍历 entryEles 集合 for (Element entryEle : entryEles) { // Should only have one value child element: ref, value, list, etc. // Optionally, there might be a key child element. // 获取子节点 NodeList entrySubNodes = entryEle.getChildNodes(); Element keyEle = null; Element valueEle = null; // 遍历 entrySubNodes for (int j = 0; j &amp;lt; entrySubNodes.getLength(); j++) { Node node = entrySubNodes.item(j); if (node instanceof Element) { Element candidateEle = (Element) node; // 处理 key 节点逻辑 if (nodeNameEquals(candidateEle, KEY_ELEMENT)) { if (keyEle != null) { error(&quot;&amp;lt;entry&amp;gt; element is only allowed to contain one &amp;lt;key&amp;gt; sub-element&quot;, entryEle); } else { keyEle = candidateEle; } } else { // 忽略 description 节点 // Child element is what we're looking for. if (nodeNameEquals(candidateEle, DESCRIPTION_ELEMENT)) { // the element is a &amp;lt;description&amp;gt; -&amp;gt; ignore it } else if (valueEle != null) { error(&quot;&amp;lt;entry&amp;gt; element must not contain more than one value sub-element&quot;, entryEle); } else { valueEle = candidateEle; } } } } // Extract key from attribute or sub-element. Object key = null; // 判断是否包含 key 属性 boolean hasKeyAttribute = entryEle.hasAttribute(KEY_ATTRIBUTE); // 判断是否包含 key-ref 属性 boolean hasKeyRefAttribute = entryEle.hasAttribute(KEY_REF_ATTRIBUTE); // 如果 [[包含 key 属性 并且 包含 key-ref 属性] 或者 [[包含 key 属性 或 包含 key-ref 之一]] 并且 keyEle 不为空] // 则 报错 if ((hasKeyAttribute &amp;amp;&amp;amp; hasKeyRefAttribute) || (hasKeyAttribute || hasKeyRefAttribute) &amp;amp;&amp;amp; keyEle != null) { error(&quot;&amp;lt;entry&amp;gt; element is only allowed to contain either &quot; + &quot;a 'key' attribute OR a 'key-ref' attribute OR a &amp;lt;key&amp;gt; sub-element&quot;, entryEle); } // 处理 key 属性 if (hasKeyAttribute) { key = buildTypedStringValueForMap(entryEle.getAttribute(KEY_ATTRIBUTE), defaultKeyType, entryEle); } // 处理 key-ref 属性 else if (hasKeyRefAttribute) { String refName = entryEle.getAttribute(KEY_REF_ATTRIBUTE); if (!StringUtils.hasText(refName)) { error(&quot;&amp;lt;entry&amp;gt; element contains empty 'key-ref' attribute&quot;, entryEle); } RuntimeBeanReference ref = new RuntimeBeanReference(refName); ref.setSource(extractSource(entryEle)); key = ref; } else if (keyEle != null) { key = parseKeyElement(keyEle, bd, defaultKeyType); } else { error(&quot;&amp;lt;entry&amp;gt; element must specify a key&quot;, entryEle); } // Extract value from attribute or sub-element. Object value = null; // 判断 是否包含 value 属性 boolean hasValueAttribute = entryEle.hasAttribute(VALUE_ATTRIBUTE); // 判断 是否包含 value-ref 属性 boolean hasValueRefAttribute = entryEle.hasAttribute(VALUE_REF_ATTRIBUTE); // 判断 是否包含 value-type 属性 boolean hasValueTypeAttribute = entryEle.hasAttribute(VALUE_TYPE_ATTRIBUTE); if ((hasValueAttribute &amp;amp;&amp;amp; hasValueRefAttribute) || (hasValueAttribute || hasValueRefAttribute) &amp;amp;&amp;amp; valueEle != null) { error(&quot;&amp;lt;entry&amp;gt; element is only allowed to contain either &quot; + &quot;'value' attribute OR 'value-ref' attribute OR &amp;lt;value&amp;gt; sub-element&quot;, entryEle); } if ((hasValueTypeAttribute &amp;amp;&amp;amp; hasValueRefAttribute) || (hasValueTypeAttribute &amp;amp;&amp;amp; !hasValueAttribute) || (hasValueTypeAttribute &amp;amp;&amp;amp; valueEle != null)) { error(&quot;&amp;lt;entry&amp;gt; element is only allowed to contain a 'value-type' &quot; + &quot;attribute when it has a 'value' attribute&quot;, entryEle); } // 处理 value 属性 if (hasValueAttribute) { String valueType = entryEle.getAttribute(VALUE_TYPE_ATTRIBUTE); if (!StringUtils.hasText(valueType)) { valueType = defaultValueType; } value = buildTypedStringValueForMap(entryEle.getAttribute(VALUE_ATTRIBUTE), valueType, entryEle); } // 处理 value-ref 属性 else if (hasValueRefAttribute) { String refName = entryEle.getAttribute(VALUE_REF_ATTRIBUTE); if (!StringUtils.hasText(refName)) { error(&quot;&amp;lt;entry&amp;gt; element contains empty 'value-ref' attribute&quot;, entryEle); } RuntimeBeanReference ref = new RuntimeBeanReference(refName); ref.setSource(extractSource(entryEle)); value = ref; } // 处理 valueEle else if (valueEle != null) { value = parsePropertySubElement(valueEle, bd, defaultValueType); } else { error(&quot;&amp;lt;entry&amp;gt; element must specify a value&quot;, entryEle); } // Add final key and value to the Map. // 添加最终的 key 和 value 到 map 中去 map.put(key, value); } return map; } 转换为map的时候逻辑稍微有点复杂,慢慢看,还是能看懂. 2.8.10 解析props标签 // BeanDefinitionParserDelegate public Properties parsePropsElement(Element propsEle) { // 创建 ManagedProperties 对象 ManagedProperties props = new ManagedProperties(); props.setSource(extractSource(propsEle)); props.setMergeEnabled(parseMergeAttribute(propsEle)); //获取节点下面素有 prop 节点 List&amp;lt;Element&amp;gt; propEles = DomUtils.getChildElementsByTagName(propsEle, PROP_ELEMENT); // 遍历 prop 节点 for (Element propEle : propEles) { // 获取 key String key = propEle.getAttribute(KEY_ATTRIBUTE); // Trim the text value to avoid unwanted whitespace // caused by typical XML formatting. // 获取 值 String value = DomUtils.getTextValue(propEle).trim(); TypedStringValue keyHolder = new TypedStringValue(key); keyHolder.setSource(extractSource(propEle)); TypedStringValue valueHolder = new TypedStringValue(value); valueHolder.setSource(extractSource(propEle)); // 放入到 props 对象中 props.put(keyHolder, valueHolder); } return props; } 2.9 parsePropertyElements // BeanDefinitionParserDelegate public void parsePropertyElements(Element beanEle, BeanDefinition bd) { // 获取所有子节点 NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &amp;lt; nl.getLength(); i++) { // 遍历 所有节点 Node node = nl.item(i); if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, PROPERTY_ELEMENT)) { parsePropertyElement((Element) node, bd); } } } public void parsePropertyElement(Element ele, BeanDefinition bd) { // 获取 name 属性 String propertyName = ele.getAttribute(NAME_ATTRIBUTE); // name 属性为空 则报错 if (!StringUtils.hasLength(propertyName)) { error(&quot;Tag 'property' must have a 'name' attribute&quot;, ele); return; } this.parseState.push(new PropertyEntry(propertyName)); try { // 属性名相同则报错 if (bd.getPropertyValues().contains(propertyName)) { error(&quot;Multiple 'property' definitions for property '&quot; + propertyName + &quot;'&quot;, ele); return; } Object val = parsePropertyValue(ele, bd, propertyName); PropertyValue pv = new PropertyValue(propertyName, val); parseMetaElements(ele, pv); pv.setSource(extractSource(ele)); bd.getPropertyValues().addPropertyValue(pv); } finally { this.parseState.pop(); } } 遍历所有节点 使用parsePropertyValue方法处理值(该方法已经写到过) 把解析到的值放入BeanDefinition中去 2.10 parseQualifierElements // BeanDefinitionParserDelegate public void parseQualifierElements(Element beanEle, AbstractBeanDefinition bd) { // 获取所有子节点 NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &amp;lt; nl.getLength(); i++) { // 遍历所有子节点 Node node = nl.item(i); // 处理 qualifier 节点 if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, QUALIFIER_ELEMENT)) { parseQualifierElement((Element) node, bd); } } } 遍历所有节点 通过parseQualifierElement方法处理 // BeanDefinitionParserDelegate public void parseQualifierElement(Element ele, AbstractBeanDefinition bd) { // 获取 type 属性 String typeName = ele.getAttribute(TYPE_ATTRIBUTE); // 如果 type 属性为空 则 error if (!StringUtils.hasLength(typeName)) { error(&quot;Tag 'qualifier' must have a 'type' attribute&quot;, ele); return; } this.parseState.push(new QualifierEntry(typeName)); try { // 创建 AutowireCandidateQualifier 对象 AutowireCandidateQualifier qualifier = new AutowireCandidateQualifier(typeName); qualifier.setSource(extractSource(ele)); // 获取 value 属性 String value = ele.getAttribute(VALUE_ATTRIBUTE); if (StringUtils.hasLength(value)) { qualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value); } // 获取当前节点下的所有节点 NodeList nl = ele.getChildNodes(); for (int i = 0; i &amp;lt; nl.getLength(); i++) { // 遍历所有子节点 Node node = nl.item(i); // 处理 attribute 属性 if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) { Element attributeEle = (Element) node; // 获取 key 属性 String attributeName = attributeEle.getAttribute(KEY_ATTRIBUTE); // 获取 value 属性 String attributeValue = attributeEle.getAttribute(VALUE_ATTRIBUTE); // key and value is not null if (StringUtils.hasLength(attributeName) &amp;amp;&amp;amp; StringUtils.hasLength(attributeValue)) { BeanMetadataAttribute attribute = new BeanMetadataAttribute(attributeName, attributeValue); attribute.setSource(extractSource(attributeEle)); qualifier.addMetadataAttribute(attribute); } else { error(&quot;Qualifier 'attribute' tag must have a 'name' and 'value'&quot;, attributeEle); return; } } } bd.addQualifier(qualifier); } finally { this.parseState.pop(); } } 遍历所有节点 把获取到的kv全部放入到AutowireCandidateQualifier对象中去 BeanDefinition对象设置qualifier属性 三、小结 ​ 至此已经创建一了一个完整的AbstractBeanDefinition对象,一个对bean信息的描述对象有了,会转为BeanDefinitionHolder为后续操作作为基础.</summary></entry><entry><title type="html">[断点分析之spring-ioc]-xml标签解析(四)</title><link href="https://onew.me/spring/2020/02/14/debug-spring-4.html" rel="alternate" type="text/html" title="[断点分析之spring-ioc]-xml标签解析(四)" /><published>2020-02-14T14:20:25+08:00</published><updated>2020-02-14T14:20:25+08:00</updated><id>https://onew.me/spring/2020/02/14/debug-spring-4</id><content type="html" xml:base="https://onew.me/spring/2020/02/14/debug-spring-4.html"># 一、前言

​	接上文,分析了spring 把 xml 文件读取到内存中,并生成一个`document`对象,然而离创建`bean`还比较遥远.在xml中定了`bean`该如何创建的规则,而spring也是遵循xml中的标签所描述规则来进行创建`bean`.接下来就是要分析,spring是如何解析这些标签的.



# 二、分析

​	还是常规套路,从下面的测试代码开始.

```java
@Test
	public void testSpringLoadXml(){
		BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBean.xml&quot;));
		final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);
		final String testStr = testBean.getTestStr();
		System.out.println(testStr);
	}
```

​	xml内容如下:

```xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                       https://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;
	&lt;bean id=&quot;myTestBean&quot; class=&quot;com.sjr.test.bean.MyTestBean&quot;/&gt;
&lt;/beans&gt;

```

​	结合xml,就可以让spring创建一个`MyTestBean`对象出来.那么spring是怎么办到的呢?

```java
// XmlBeanDefinitionReader
protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
			throws BeanDefinitionStoreException {

		try {
			// 加载xml
      // 加载xml的时候这里已经讲过了
			Document doc = doLoadDocument(inputSource, resource);
			// 注册bean
			int count = registerBeanDefinitions(doc, resource);
			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource);
			}
			return count;
		}
		catch (BeanDefinitionStoreException ex) {
			throw ex;
		}
		catch (SAXParseException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					&quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);
		}
		catch (SAXException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					&quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);
		}
		catch (ParserConfigurationException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;Parser configuration exception parsing XML from &quot; + resource, ex);
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;IOException parsing XML document from &quot; + resource, ex);
		}
		catch (Throwable ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;Unexpected exception parsing XML document from &quot; + resource, ex);
		}
	}
```

​	看来答案出现在`int count = registerBeanDefinitions(doc, resource);`这句代码里面

## 2.1 registerBeanDefinitions()

```java
//xmlBeanDefinitionReader
/***
* @param doc 通过xml 创建的document对象
* @param resource xml 资源对象
* @return 注册的数量
*/
public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
		// 创建BeanDefinitionDocumentReader 默认是DefaultBeanDefinitionDocumentReader
		BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
		// 获取已经注册的bean的数量,beanDefinitionMap.size()
		int countBefore = getRegistry().getBeanDefinitionCount();
    // 注册xml bean定义
		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
  	// 返回已经注册的数量
		return getRegistry().getBeanDefinitionCount() - countBefore;
	}
```

​	解析xml标签的核心逻辑在于`documentReader.registerBeanDefinitions(doc, createReaderContext(resource));`,逐步分析一下.



## 2.2 createReaderContext(resource)

```java
//xmlBeanDefinitionReader
public XmlReaderContext createReaderContext(Resource resource) {
		return new XmlReaderContext(resource, this.problemReporter, this.eventListener,
				this.sourceExtractor, this, getNamespaceHandlerResolver());
	}
```

​	这个对象相当于是个工具类,里面未封装逻辑代码.封装了一些日志相关的函数,获取resource的函数等.这里值得注意是`getNamespaceHandlerResolver()`这个方法,这个方法返回了一个`NamespaceHandlerResolver`对象,这个对象是用于解析指定名称空间的解析器,如果要自定义标签就得要这个对象来帮忙.



```java
 //xmlBeanDefinitionReader
	public NamespaceHandlerResolver getNamespaceHandlerResolver() {
		// 如果名称空间解析器为空,则创建一个默认的名称空间解析器
    if (this.namespaceHandlerResolver == null) {
			this.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();
		}
		return this.namespaceHandlerResolver;
	}

	/**
	 * Create the default implementation of {@link NamespaceHandlerResolver} used if none is specified.
	 * &lt;p&gt;The default implementation returns an instance of {@link DefaultNamespaceHandlerResolver}.
	 * @see DefaultNamespaceHandlerResolver#DefaultNamespaceHandlerResolver(ClassLoader)
	 */
	protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() {
		// 获取classLoader
    ClassLoader cl = (getResourceLoader() != null ? getResourceLoader().getClassLoader() : getBeanClassLoader());
    // 创建默认的名称空间解析器
		return new DefaultNamespaceHandlerResolver(cl);
	}
```



## 2.3 registerBeanDefinitions()

```java
 // DefaultBeanDefinitionDocumentReader
	// bean
	public static final String BEAN_ELEMENT = BeanDefinitionParserDelegate.BEAN_ELEMENT;

	public static final String NESTED_BEANS_ELEMENT = &quot;beans&quot;;

	public static final String ALIAS_ELEMENT = &quot;alias&quot;;

	public static final String NAME_ATTRIBUTE = &quot;name&quot;;

	public static final String ALIAS_ATTRIBUTE = &quot;alias&quot;;

	public static final String IMPORT_ELEMENT = &quot;import&quot;;

	public static final String RESOURCE_ATTRIBUTE = &quot;resource&quot;;

	public static final String PROFILE_ATTRIBUTE = &quot;profile&quot;;


	@Override
	public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
		this.readerContext = readerContext;
		doRegisterBeanDefinitions(doc.getDocumentElement());
	}

	protected void doRegisterBeanDefinitions(Element root) {
		// Any nested &lt;beans&gt; elements will cause recursion in this method. In
		// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,
		// keep track of the current (parent) delegate, which may be null. Create
		// the new (child) delegate with a reference to the parent for fallback purposes,
		// then ultimately reset this.delegate back to its original (parent) reference.
		// this behavior emulates a stack of delegates without actually necessitating one.
		// root节点进来默认委托为null
		BeanDefinitionParserDelegate parent = this.delegate;
		// 创建委托,用于解析各个标签
    // BeanDefinitionParserDelegate
		this.delegate = createDelegate(getReaderContext(), root, parent);

		// 处理profile属性,用于切换不同环境的配置文件
		if (this.delegate.isDefaultNamespace(root)) {
			// 判断是否含有profile属性
			String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
			// 如果profile属性不为空
			if (StringUtils.hasText(profileSpec)) {
				// 可能会有多个profile属性,使用,;进行分割
				String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
						profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
				// We cannot use Profiles.of(...) since profile expressions are not supported
				// in XML config. See SPR-12458 for details.
				// 如果不是有效的profile 则返回
				if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +
								&quot;] not matching: &quot; + getReaderContext().getResource());
					}
					return;
				}
			}
		}
		// 前置解析器(空逻辑,留给子类去完善)
		preProcessXml(root);
		// 核心逻辑
		parseBeanDefinitions(root, this.delegate);
		// 后置解析器(空逻辑,留给子类去完善)
		postProcessXml(root);

		this.delegate = parent;
	}
```

1. 根节点默认没有父节点为NULL
2. 创建委托用于解析xml标签
3. 判断是否有多个环境配置,并切换配置
4. 开始解析

​	`preProcessXml(root)`方法和`postProcessXm(root)`默认都是空实现,这里是应用的设计模式为 模板模式,增强扩展新,子类需要扩展只需要去实现这两个方法即可.



## 2.4 parseBeanDefinitions

```java
protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
		// 如果根节点使用默认命名空间，执行默认解析
		if (delegate.isDefaultNamespace(root)) {
			// 获取节点下面的子节点
			NodeList nl = root.getChildNodes();
			// 遍历子节点
			for (int i = 0; i &lt; nl.getLength(); i++) {
				Node node = nl.item(i);
				if (node instanceof Element) {
					Element ele = (Element) node;
					if (delegate.isDefaultNamespace(ele)) {
						// 解析默认名称空间元素
						parseDefaultElement(ele, delegate);
					}
					else {
						// 解析自定义名称命名空间
						delegate.parseCustomElement(ele);
					}
				}
			}
		}
		else {
			// 解析自定义名称命名空间
			delegate.parseCustomElement(root);
		}
	}
```

​	这里从判断节点是否是默认的名称命名空间,从而引发了2种不同的逻辑分支.一个是执行spring的内置的解析逻辑,另一个是执行自定义的解析逻辑.

​	spring判断是否是默认的名称空间依据是:如果`namespaceUri`为空并且不等于`http://www.springframework.org/schema/beans`,则判断为非默认名称空间.



# 三、默认解析

```java
// DefaultBeanDefinitionDocumentReader
private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
		// 默认名称空间解析,由此可见spring默认名称命名空间只有4个
		// import alias bean beans
		// import 标签处理.用于加载引用进来的xml
		if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
			importBeanDefinitionResource(ele);
		}
		// alias 标签处理
		else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
			processAliasRegistration(ele);
		}
		// bean 标签处理
		else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
			processBeanDefinition(ele, delegate);
		}
		// beans 标签处理
		else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
			// recurse 递归解析
			doRegisterBeanDefinitions(ele);
		}
	}
```



## 3.1 import标签

```java
// DefaultBeanDefinitionDocumentReader
protected void importBeanDefinitionResource(Element ele) {
		// 获取resource属性,用于加载文件
		String location = ele.getAttribute(RESOURCE_ATTRIBUTE);
		// 如果为空则退出
		if (!StringUtils.hasText(location)) {
			getReaderContext().error(&quot;Resource location must not be empty&quot;, ele);
			return;
		}
		// 解析当前环境中的文件路径
		// Resolve system properties: e.g. &quot;${user.dir}&quot;
		location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);

		Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;&gt;(4);

		// Discover whether the location is an absolute or relative URI
		boolean absoluteLocation = false;
		try {
			absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();
		}
		catch (URISyntaxException ex) {
			// cannot convert to an URI, considering the location relative
			// unless it is the well-known Spring prefix &quot;classpath*:&quot;
		}

		// 判断是绝对路径还是相对路径
		// Absolute or relative?
		if (absoluteLocation) {
			// 绝对路径
			try {
				// 加载resource属性中的xml文件,加载bean定义
				int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from URL location [&quot; + location + &quot;]&quot;);
				}
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(
						&quot;Failed to import bean definitions from URL location [&quot; + location + &quot;]&quot;, ele, ex);
			}
		}
		else {
			// 相对路径
			// No URL -&gt; considering resource location as relative to the current file.
			try {
				int importCount;
				Resource relativeResource = getReaderContext().getResource().createRelative(location);
				// 判断资源文件是否存在
				if (relativeResource.exists()) {
					// 加载文件
					importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);
					actualResources.add(relativeResource);
				}
				else {
					// 转换为绝对路径
					String baseLocation = getReaderContext().getResource().getURL().toString();
					// 加载文件
					importCount = getReaderContext().getReader().loadBeanDefinitions(
							// 计算绝对路径
							StringUtils.applyRelativePath(baseLocation, location), actualResources);
				}
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from relative location [&quot; + location + &quot;]&quot;);
				}
			}
			catch (IOException ex) {
				getReaderContext().error(&quot;Failed to resolve current resource location&quot;, ele, ex);
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(
						&quot;Failed to import bean definitions from relative location [&quot; + location + &quot;]&quot;, ele, ex);
			}
		}
		// 转换为数组
		Resource[] actResArray = actualResources.toArray(new Resource[0]);
		// 释放资源
		getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));
	}

```

1. 判断路径是否为空
2. 如果为相对路径,加载xml文件
3. 如果为绝对路径,判断文件是否存在,存在则加载文件
4. 如果文件不存在,转换为相对路径,加载文件

## 3.2 alias标签

```java
// DefaultBeanDefinitionDocumentReader	
protected void processAliasRegistration(Element ele) {
    // 获取name属性值
		String name = ele.getAttribute(NAME_ATTRIBUTE);
    // 获取alias属性值
		String alias = ele.getAttribute(ALIAS_ATTRIBUTE);
		boolean valid = true;
		// 验证名称是否合法
		if (!StringUtils.hasText(name)) {
			getReaderContext().error(&quot;Name must not be empty&quot;, ele);
			valid = false;
		}
		// 验证别名是否合法
		if (!StringUtils.hasText(alias)) {
			getReaderContext().error(&quot;Alias must not be empty&quot;, ele);
			valid = false;
		}
		// 验证通过映射别名
		if (valid) {
			try {
        // 注册别名
				getReaderContext().getRegistry().registerAlias(name, alias);
			}
			catch (Exception ex) {
				getReaderContext().error(&quot;Failed to register alias '&quot; + alias +
						&quot;' for bean with name '&quot; + name + &quot;'&quot;, ele, ex);
			}
			// 发送事件
			getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));
		}
	}
```

1. 获取name属性值
2. 获取alias属性值
3. 验证alias是否合法
4. 如果合法则进行注册

```java
// DefaultBeanDefinitionDocumentReader
	@Override
	public void registerAlias(String name, String alias) {
		Assert.hasText(name, &quot;'name' must not be empty&quot;);
		Assert.hasText(alias, &quot;'alias' must not be empty&quot;);
		// 加锁 并发控制
		synchronized (this.aliasMap) {
			// 判断 bean 名称是否与别名相同,如果相同则忽略
			if (alias.equals(name)) {
				// 移除别名
				this.aliasMap.remove(alias);
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Alias definition '&quot; + alias + &quot;' ignored since it points to same name&quot;);
				}
			}
			else {
				// 判断别名是否已存在
				String registeredName = this.aliasMap.get(alias);
				if (registeredName != null) {
					// 如果别名对应的bean的名称与name相同则忽略
					if (registeredName.equals(name)) {
						// An existing alias - no need to re-register
						return;
					}
					// 是否允许覆盖,如果不允许则报错
					if (!allowAliasOverriding()) {
						throw new IllegalStateException(&quot;Cannot define alias '&quot; + alias + &quot;' for name '&quot; +
								name + &quot;': It is already registered for name '&quot; + registeredName + &quot;'.&quot;);
					}
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Overriding alias '&quot; + alias + &quot;' definition for registered name '&quot; +
								registeredName + &quot;' with new target name '&quot; + name + &quot;'&quot;);
					}
				}
				//检查是否有循环引用别名 例如:A-B C-B A-C
				checkForAliasCircle(name, alias);
				//映射别名和名称到map中
				this.aliasMap.put(alias, name);
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Alias definition '&quot; + alias + &quot;' registered for name '&quot; + name + &quot;'&quot;);
				}
			}
		}
	}
```

​	这里的逻辑比较简单,循环引用这里有点意思.

```java
// DefaultBeanDefinitionDocumentReader
protected void checkForAliasCircle(String name, String alias) {
  	// 注意这里把 alias 和 name 调换了一下位置
		if (hasAlias(alias, name)) {
			throw new IllegalStateException(&quot;Cannot register alias '&quot; + alias +
					&quot;' for name '&quot; + name + &quot;': Circular reference - '&quot; +
					name + &quot;' is a direct or indirect alias for '&quot; + alias + &quot;' already&quot;);
		}
	}
/**
* 由于调换过参数顺序,所以理解的时候需要调换回来
*/
public boolean hasAlias(String name, String alias) {
		for (Map.Entry&lt;String, String&gt; entry : this.aliasMap.entrySet()) {
			String registeredName = entry.getValue();
			if (registeredName.equals(name)) {
				String registeredAlias = entry.getKey();
				if (registeredAlias.equals(alias) || hasAlias(registeredAlias, alias)) {
					return true;
				}
			}
		}
		return false;
	}

```

​	光看代码估计会比较蒙,来举例看看.

​	准备三对 别名-&gt;名称:

| alias | name |
| ----- | ---- |
| A     | B    |
| B     | C    |
| C     | A    |

1. 检查 A-&gt;B 是否存在循环引用
   - 由于集合是空的,所以不存在循环引用.
2. 检查B-&gt;C是否存在循环引用
   - 遍历集合获取value: B
   - B==B(注意这里的name其实是alias)
   - 获取集合中的key: A 
   - A != C 把 A-&gt;C当作参数进行递归
   - 递归检查不存在循环引用
3. 检查C-A是否存在循环引用
   - 遍历集合获取value: B
   - B != C
   - 遍历集合获取value: C
   - C == C
   - 获取集合中的key: B
   - B != A,把B-&gt;A作为参数递归
   - 遍历集合获取value: B
   - B==B
   - 获取集合中的key: A
   - A == A 停止递归,返回true
   - 存在循环引用

之所以这个逻辑有点绕因为这个参数调换了一下位置,建议用笔画一下就豁达了.LOL :).



## 3.3 bean标签

```java
// DefaultBeanDefinitionDocumentReader
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
		// 解析xml元素
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
		if (bdHolder != null) {
			// 装饰bean
			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
			try {
				// Register the final decorated instance.
				// 注册bean到容器中
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
						bdHolder.getBeanName() + &quot;'&quot;, ele, ex);
			}
			// Send registration event.
			// 发送事件
			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
		}
	}
```

1. 解析xml创建`BeanDefinitionHolder`
2. 如果不为空,进行进行装饰
3. 注册到容器中
4. 发送事件

### 3.3.1 parseBeanDefinitionElement()

```java
// BeanDefinitionParserDelegate
 @Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
		return parseBeanDefinitionElement(ele, null);
	}

	/**
	 * Parses the supplied {@code &lt;bean&gt;} element. May return {@code null}
	 * if there were errors during parse. Errors are reported to the
	 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
	 */
	@Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
		// 获取id
		String id = ele.getAttribute(ID_ATTRIBUTE);
		// 获取名称
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
		// 获取别名,别名可以使用多个
		List&lt;String&gt; aliases = new ArrayList&lt;&gt;();
		// 名称不为空
		if (StringUtils.hasLength(nameAttr)) {
			// 如果有多个名称,使用,;切割
			String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
			aliases.addAll(Arrays.asList(nameArr));
		}
		// bean名称就是id
		String beanName = id;
		// 如果名称为空,并且别名集合不为空,则从别名中获取第一个,作为名称
		if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {
			beanName = aliases.remove(0);
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName +
						&quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;);
			}
		}

		if (containingBean == null) {
			// 检查beanName是否唯一(名称未被使用过)
			checkNameUniqueness(beanName, aliases, ele);
		}
		// 解析标签封装为beanDefinition
		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
		// beanDefinition对象不为空
		if (beanDefinition != null) {
			// beanName为空
			if (!StringUtils.hasText(beanName)) {
				try {
					if (containingBean != null) {
						// 生成bean的 name
						beanName = BeanDefinitionReaderUtils.generateBeanName(
								beanDefinition, this.readerContext.getRegistry(), true);
					}
					else {
            // 生成bean的 name
						beanName = this.readerContext.generateBeanName(beanDefinition);
						// Register an alias for the plain bean class name, if still possible,
						// if the generator returned the class name plus a suffix.
						// This is expected for Spring 1.2/2.0 backwards compatibility.
            // 获取 className
						String beanClassName = beanDefinition.getBeanClassName();
            // 判断bean名称不为空 并且 以类名开头 并且名称没有被使用
						if (beanClassName != null &amp;&amp;
								beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;
								!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
							aliases.add(beanClassName);
						}
					}
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; +
								&quot;using generated bean name [&quot; + beanName + &quot;]&quot;);
					}
				}
				catch (Exception ex) {
					error(ex.getMessage(), ele);
					return null;
				}
			}
			// 别名集合转为数组
			String[] aliasesArray = StringUtils.toStringArray(aliases);
			// 返回BeanDefinitionHolder
			return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
		}

		return null;
	}
```

​	以上代码逻辑不是很复杂,核心逻辑在于通过`AbstractBeanDefinition`转换为`BeanDefinitionHolder`,核心代码`AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);`



# 四、小结

​	由于后面的逻辑比较复杂,打算分两章来写,天色已晚,准备吃饭.</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">一、前言 ​ 接上文,分析了spring 把 xml 文件读取到内存中,并生成一个document对象,然而离创建bean还比较遥远.在xml中定了bean该如何创建的规则,而spring也是遵循xml中的标签所描述规则来进行创建bean.接下来就是要分析,spring是如何解析这些标签的. 二、分析 ​ 还是常规套路,从下面的测试代码开始. @Test public void testSpringLoadXml(){ BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBean.xml&quot;)); final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class); final String testStr = testBean.getTestStr(); System.out.println(testStr); } ​ xml内容如下: &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&amp;gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&amp;gt; &amp;lt;bean id=&quot;myTestBean&quot; class=&quot;com.sjr.test.bean.MyTestBean&quot;/&amp;gt; &amp;lt;/beans&amp;gt; ​ 结合xml,就可以让spring创建一个MyTestBean对象出来.那么spring是怎么办到的呢? // XmlBeanDefinitionReader protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { // 加载xml // 加载xml的时候这里已经讲过了 Document doc = doLoadDocument(inputSource, resource); // 注册bean int count = registerBeanDefinitions(doc, resource); if (logger.isDebugEnabled()) { logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource); } return count; } catch (BeanDefinitionStoreException ex) { throw ex; } catch (SAXParseException ex) { throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex); } catch (SAXException ex) { throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex); } catch (ParserConfigurationException ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Parser configuration exception parsing XML from &quot; + resource, ex); } catch (IOException ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;IOException parsing XML document from &quot; + resource, ex); } catch (Throwable ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Unexpected exception parsing XML document from &quot; + resource, ex); } } ​ 看来答案出现在int count = registerBeanDefinitions(doc, resource);这句代码里面 2.1 registerBeanDefinitions() //xmlBeanDefinitionReader /*** * @param doc 通过xml 创建的document对象 * @param resource xml 资源对象 * @return 注册的数量 */ public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { // 创建BeanDefinitionDocumentReader 默认是DefaultBeanDefinitionDocumentReader BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); // 获取已经注册的bean的数量,beanDefinitionMap.size() int countBefore = getRegistry().getBeanDefinitionCount(); // 注册xml bean定义 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); // 返回已经注册的数量 return getRegistry().getBeanDefinitionCount() - countBefore; } ​ 解析xml标签的核心逻辑在于documentReader.registerBeanDefinitions(doc, createReaderContext(resource));,逐步分析一下. 2.2 createReaderContext(resource) //xmlBeanDefinitionReader public XmlReaderContext createReaderContext(Resource resource) { return new XmlReaderContext(resource, this.problemReporter, this.eventListener, this.sourceExtractor, this, getNamespaceHandlerResolver()); } ​ 这个对象相当于是个工具类,里面未封装逻辑代码.封装了一些日志相关的函数,获取resource的函数等.这里值得注意是getNamespaceHandlerResolver()这个方法,这个方法返回了一个NamespaceHandlerResolver对象,这个对象是用于解析指定名称空间的解析器,如果要自定义标签就得要这个对象来帮忙. //xmlBeanDefinitionReader public NamespaceHandlerResolver getNamespaceHandlerResolver() { // 如果名称空间解析器为空,则创建一个默认的名称空间解析器 if (this.namespaceHandlerResolver == null) { this.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver(); } return this.namespaceHandlerResolver; } /** * Create the default implementation of {@link NamespaceHandlerResolver} used if none is specified. * &amp;lt;p&amp;gt;The default implementation returns an instance of {@link DefaultNamespaceHandlerResolver}. * @see DefaultNamespaceHandlerResolver#DefaultNamespaceHandlerResolver(ClassLoader) */ protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() { // 获取classLoader ClassLoader cl = (getResourceLoader() != null ? getResourceLoader().getClassLoader() : getBeanClassLoader()); // 创建默认的名称空间解析器 return new DefaultNamespaceHandlerResolver(cl); } 2.3 registerBeanDefinitions() // DefaultBeanDefinitionDocumentReader // bean public static final String BEAN_ELEMENT = BeanDefinitionParserDelegate.BEAN_ELEMENT; public static final String NESTED_BEANS_ELEMENT = &quot;beans&quot;; public static final String ALIAS_ELEMENT = &quot;alias&quot;; public static final String NAME_ATTRIBUTE = &quot;name&quot;; public static final String ALIAS_ATTRIBUTE = &quot;alias&quot;; public static final String IMPORT_ELEMENT = &quot;import&quot;; public static final String RESOURCE_ATTRIBUTE = &quot;resource&quot;; public static final String PROFILE_ATTRIBUTE = &quot;profile&quot;; @Override public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) { this.readerContext = readerContext; doRegisterBeanDefinitions(doc.getDocumentElement()); } protected void doRegisterBeanDefinitions(Element root) { // Any nested &amp;lt;beans&amp;gt; elements will cause recursion in this method. In // order to propagate and preserve &amp;lt;beans&amp;gt; default-* attributes correctly, // keep track of the current (parent) delegate, which may be null. Create // the new (child) delegate with a reference to the parent for fallback purposes, // then ultimately reset this.delegate back to its original (parent) reference. // this behavior emulates a stack of delegates without actually necessitating one. // root节点进来默认委托为null BeanDefinitionParserDelegate parent = this.delegate; // 创建委托,用于解析各个标签 // BeanDefinitionParserDelegate this.delegate = createDelegate(getReaderContext(), root, parent); // 处理profile属性,用于切换不同环境的配置文件 if (this.delegate.isDefaultNamespace(root)) { // 判断是否含有profile属性 String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); // 如果profile属性不为空 if (StringUtils.hasText(profileSpec)) { // 可能会有多个profile属性,使用,;进行分割 String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); // We cannot use Profiles.of(...) since profile expressions are not supported // in XML config. See SPR-12458 for details. // 如果不是有效的profile 则返回 if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isDebugEnabled()) { logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + getReaderContext().getResource()); } return; } } } // 前置解析器(空逻辑,留给子类去完善) preProcessXml(root); // 核心逻辑 parseBeanDefinitions(root, this.delegate); // 后置解析器(空逻辑,留给子类去完善) postProcessXml(root); this.delegate = parent; } 根节点默认没有父节点为NULL 创建委托用于解析xml标签 判断是否有多个环境配置,并切换配置 开始解析 ​ preProcessXml(root)方法和postProcessXm(root)默认都是空实现,这里是应用的设计模式为 模板模式,增强扩展新,子类需要扩展只需要去实现这两个方法即可. 2.4 parseBeanDefinitions protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { // 如果根节点使用默认命名空间，执行默认解析 if (delegate.isDefaultNamespace(root)) { // 获取节点下面的子节点 NodeList nl = root.getChildNodes(); // 遍历子节点 for (int i = 0; i &amp;lt; nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) { // 解析默认名称空间元素 parseDefaultElement(ele, delegate); } else { // 解析自定义名称命名空间 delegate.parseCustomElement(ele); } } } } else { // 解析自定义名称命名空间 delegate.parseCustomElement(root); } } ​ 这里从判断节点是否是默认的名称命名空间,从而引发了2种不同的逻辑分支.一个是执行spring的内置的解析逻辑,另一个是执行自定义的解析逻辑. ​ spring判断是否是默认的名称空间依据是:如果namespaceUri为空并且不等于http://www.springframework.org/schema/beans,则判断为非默认名称空间. 三、默认解析 // DefaultBeanDefinitionDocumentReader private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { // 默认名称空间解析,由此可见spring默认名称命名空间只有4个 // import alias bean beans // import 标签处理.用于加载引用进来的xml if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { importBeanDefinitionResource(ele); } // alias 标签处理 else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { processAliasRegistration(ele); } // bean 标签处理 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { processBeanDefinition(ele, delegate); } // beans 标签处理 else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // recurse 递归解析 doRegisterBeanDefinitions(ele); } } 3.1 import标签 // DefaultBeanDefinitionDocumentReader protected void importBeanDefinitionResource(Element ele) { // 获取resource属性,用于加载文件 String location = ele.getAttribute(RESOURCE_ATTRIBUTE); // 如果为空则退出 if (!StringUtils.hasText(location)) { getReaderContext().error(&quot;Resource location must not be empty&quot;, ele); return; } // 解析当前环境中的文件路径 // Resolve system properties: e.g. &quot;${user.dir}&quot; location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location); Set&amp;lt;Resource&amp;gt; actualResources = new LinkedHashSet&amp;lt;&amp;gt;(4); // Discover whether the location is an absolute or relative URI boolean absoluteLocation = false; try { absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute(); } catch (URISyntaxException ex) { // cannot convert to an URI, considering the location relative // unless it is the well-known Spring prefix &quot;classpath*:&quot; } // 判断是绝对路径还是相对路径 // Absolute or relative? if (absoluteLocation) { // 绝对路径 try { // 加载resource属性中的xml文件,加载bean定义 int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources); if (logger.isTraceEnabled()) { logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from URL location [&quot; + location + &quot;]&quot;); } } catch (BeanDefinitionStoreException ex) { getReaderContext().error( &quot;Failed to import bean definitions from URL location [&quot; + location + &quot;]&quot;, ele, ex); } } else { // 相对路径 // No URL -&amp;gt; considering resource location as relative to the current file. try { int importCount; Resource relativeResource = getReaderContext().getResource().createRelative(location); // 判断资源文件是否存在 if (relativeResource.exists()) { // 加载文件 importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource); actualResources.add(relativeResource); } else { // 转换为绝对路径 String baseLocation = getReaderContext().getResource().getURL().toString(); // 加载文件 importCount = getReaderContext().getReader().loadBeanDefinitions( // 计算绝对路径 StringUtils.applyRelativePath(baseLocation, location), actualResources); } if (logger.isTraceEnabled()) { logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from relative location [&quot; + location + &quot;]&quot;); } } catch (IOException ex) { getReaderContext().error(&quot;Failed to resolve current resource location&quot;, ele, ex); } catch (BeanDefinitionStoreException ex) { getReaderContext().error( &quot;Failed to import bean definitions from relative location [&quot; + location + &quot;]&quot;, ele, ex); } } // 转换为数组 Resource[] actResArray = actualResources.toArray(new Resource[0]); // 释放资源 getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele)); } 判断路径是否为空 如果为相对路径,加载xml文件 如果为绝对路径,判断文件是否存在,存在则加载文件 如果文件不存在,转换为相对路径,加载文件 3.2 alias标签 // DefaultBeanDefinitionDocumentReader protected void processAliasRegistration(Element ele) { // 获取name属性值 String name = ele.getAttribute(NAME_ATTRIBUTE); // 获取alias属性值 String alias = ele.getAttribute(ALIAS_ATTRIBUTE); boolean valid = true; // 验证名称是否合法 if (!StringUtils.hasText(name)) { getReaderContext().error(&quot;Name must not be empty&quot;, ele); valid = false; } // 验证别名是否合法 if (!StringUtils.hasText(alias)) { getReaderContext().error(&quot;Alias must not be empty&quot;, ele); valid = false; } // 验证通过映射别名 if (valid) { try { // 注册别名 getReaderContext().getRegistry().registerAlias(name, alias); } catch (Exception ex) { getReaderContext().error(&quot;Failed to register alias '&quot; + alias + &quot;' for bean with name '&quot; + name + &quot;'&quot;, ele, ex); } // 发送事件 getReaderContext().fireAliasRegistered(name, alias, extractSource(ele)); } } 获取name属性值 获取alias属性值 验证alias是否合法 如果合法则进行注册 // DefaultBeanDefinitionDocumentReader @Override public void registerAlias(String name, String alias) { Assert.hasText(name, &quot;'name' must not be empty&quot;); Assert.hasText(alias, &quot;'alias' must not be empty&quot;); // 加锁 并发控制 synchronized (this.aliasMap) { // 判断 bean 名称是否与别名相同,如果相同则忽略 if (alias.equals(name)) { // 移除别名 this.aliasMap.remove(alias); if (logger.isDebugEnabled()) { logger.debug(&quot;Alias definition '&quot; + alias + &quot;' ignored since it points to same name&quot;); } } else { // 判断别名是否已存在 String registeredName = this.aliasMap.get(alias); if (registeredName != null) { // 如果别名对应的bean的名称与name相同则忽略 if (registeredName.equals(name)) { // An existing alias - no need to re-register return; } // 是否允许覆盖,如果不允许则报错 if (!allowAliasOverriding()) { throw new IllegalStateException(&quot;Cannot define alias '&quot; + alias + &quot;' for name '&quot; + name + &quot;': It is already registered for name '&quot; + registeredName + &quot;'.&quot;); } if (logger.isDebugEnabled()) { logger.debug(&quot;Overriding alias '&quot; + alias + &quot;' definition for registered name '&quot; + registeredName + &quot;' with new target name '&quot; + name + &quot;'&quot;); } } //检查是否有循环引用别名 例如:A-B C-B A-C checkForAliasCircle(name, alias); //映射别名和名称到map中 this.aliasMap.put(alias, name); if (logger.isTraceEnabled()) { logger.trace(&quot;Alias definition '&quot; + alias + &quot;' registered for name '&quot; + name + &quot;'&quot;); } } } } ​ 这里的逻辑比较简单,循环引用这里有点意思. // DefaultBeanDefinitionDocumentReader protected void checkForAliasCircle(String name, String alias) { // 注意这里把 alias 和 name 调换了一下位置 if (hasAlias(alias, name)) { throw new IllegalStateException(&quot;Cannot register alias '&quot; + alias + &quot;' for name '&quot; + name + &quot;': Circular reference - '&quot; + name + &quot;' is a direct or indirect alias for '&quot; + alias + &quot;' already&quot;); } } /** * 由于调换过参数顺序,所以理解的时候需要调换回来 */ public boolean hasAlias(String name, String alias) { for (Map.Entry&amp;lt;String, String&amp;gt; entry : this.aliasMap.entrySet()) { String registeredName = entry.getValue(); if (registeredName.equals(name)) { String registeredAlias = entry.getKey(); if (registeredAlias.equals(alias) || hasAlias(registeredAlias, alias)) { return true; } } } return false; } ​ 光看代码估计会比较蒙,来举例看看. ​ 准备三对 别名-&amp;gt;名称: alias name A B B C C A 检查 A-&amp;gt;B 是否存在循环引用 由于集合是空的,所以不存在循环引用. 检查B-&amp;gt;C是否存在循环引用 遍历集合获取value: B B==B(注意这里的name其实是alias) 获取集合中的key: A A != C 把 A-&amp;gt;C当作参数进行递归 递归检查不存在循环引用 检查C-A是否存在循环引用 遍历集合获取value: B B != C 遍历集合获取value: C C == C 获取集合中的key: B B != A,把B-&amp;gt;A作为参数递归 遍历集合获取value: B B==B 获取集合中的key: A A == A 停止递归,返回true 存在循环引用 之所以这个逻辑有点绕因为这个参数调换了一下位置,建议用笔画一下就豁达了.LOL :). 3.3 bean标签 // DefaultBeanDefinitionDocumentReader protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // 解析xml元素 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { // 装饰bean bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. // 注册bean到容器中 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(&quot;Failed to register bean definition with name '&quot; + bdHolder.getBeanName() + &quot;'&quot;, ele, ex); } // Send registration event. // 发送事件 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } 解析xml创建BeanDefinitionHolder 如果不为空,进行进行装饰 注册到容器中 发送事件 3.3.1 parseBeanDefinitionElement() // BeanDefinitionParserDelegate @Nullable public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { return parseBeanDefinitionElement(ele, null); } /** * Parses the supplied {@code &amp;lt;bean&amp;gt;} element. May return {@code null} * if there were errors during parse. Errors are reported to the * {@link org.springframework.beans.factory.parsing.ProblemReporter}. */ @Nullable public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) { // 获取id String id = ele.getAttribute(ID_ATTRIBUTE); // 获取名称 String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); // 获取别名,别名可以使用多个 List&amp;lt;String&amp;gt; aliases = new ArrayList&amp;lt;&amp;gt;(); // 名称不为空 if (StringUtils.hasLength(nameAttr)) { // 如果有多个名称,使用,;切割 String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } // bean名称就是id String beanName = id; // 如果名称为空,并且别名集合不为空,则从别名中获取第一个,作为名称 if (!StringUtils.hasText(beanName) &amp;amp;&amp;amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isTraceEnabled()) { logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName + &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;); } } if (containingBean == null) { // 检查beanName是否唯一(名称未被使用过) checkNameUniqueness(beanName, aliases, ele); } // 解析标签封装为beanDefinition AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); // beanDefinition对象不为空 if (beanDefinition != null) { // beanName为空 if (!StringUtils.hasText(beanName)) { try { if (containingBean != null) { // 生成bean的 name beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { // 生成bean的 name beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. // 获取 className String beanClassName = beanDefinition.getBeanClassName(); // 判断bean名称不为空 并且 以类名开头 并且名称没有被使用 if (beanClassName != null &amp;amp;&amp;amp; beanName.startsWith(beanClassName) &amp;amp;&amp;amp; beanName.length() &amp;gt; beanClassName.length() &amp;amp;&amp;amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { aliases.add(beanClassName); } } if (logger.isTraceEnabled()) { logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } // 别名集合转为数组 String[] aliasesArray = StringUtils.toStringArray(aliases); // 返回BeanDefinitionHolder return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } return null; } ​ 以上代码逻辑不是很复杂,核心逻辑在于通过AbstractBeanDefinition转换为BeanDefinitionHolder,核心代码AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); 四、小结 ​ 由于后面的逻辑比较复杂,打算分两章来写,天色已晚,准备吃饭.</summary></entry><entry><title type="html">[断点分析之spring-ioc]-xml文件解析(三)</title><link href="https://onew.me/spring/2020/02/05/debug-spring-3.html" rel="alternate" type="text/html" title="[断点分析之spring-ioc]-xml文件解析(三)" /><published>2020-02-05T22:20:25+08:00</published><updated>2020-02-05T22:20:25+08:00</updated><id>https://onew.me/spring/2020/02/05/debug-spring-3</id><content type="html" xml:base="https://onew.me/spring/2020/02/05/debug-spring-3.html"># 一、前言

​	前面资源文件加载搞定了,来看看 spring 是如何把 xml 文件变成 bean 的吧.



# 二、分析

​	还是从4句代码看起.

````java
@Test
	public void testSpringLoadXml(){
    // 加载xml
		BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBean.xml&quot;));
    // 获取bean
		final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);
		final String testStr = testBean.getTestStr();
		System.out.println(testStr);
	}
````

​	从解析xml 到 获取bean都是从`XmlBeanFactory`中操作的,那么就来看看`XmlBeanFactory`里面有啥.

```java
public class XmlBeanFactory extends DefaultListableBeanFactory {

	private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);


	/**
	 * 构造函数
	 */
	public XmlBeanFactory(Resource resource) throws BeansException {
		this(resource, null);
	}

	/**
	 * 构造函数
	 * 指定 父BeanFactory
	 */
	public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
		super(parentBeanFactory);
    // 核心代码 A
		this.reader.loadBeanDefinitions(resource);
	}

}

```

​	可以看到核心代码在A处,A处用`XmlBeanDefinitionReader`进行读取文件,继续跟下去.

```java
@Override
	public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
		// 把classPathsResource转换为EncodedResource,默认字符编码为空
		return loadBeanDefinitions(new EncodedResource(resource));
	}

	public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
		//加载资源,资源不能为空
		Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Loading XML bean definitions from &quot; + encodedResource);
		}
		//判断当前线程是否加载过资源,如果没有则创建一个set来保存encodedResource
		Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();
		if (currentResources == null) {
			currentResources = new HashSet&lt;&gt;(4);
			this.resourcesCurrentlyBeingLoaded.set(currentResources);
		}
		//判断是否有已近添加过相同的encodedResource
		if (!currentResources.add(encodedResource)) {
			throw new BeanDefinitionStoreException(
					&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);
		}
		try {
			//获取xml文件流
			InputStream inputStream = encodedResource.getResource().getInputStream();
			try {
				InputSource inputSource = new InputSource(inputStream);
				//如果编码不为空,则设置文件编码
				if (encodedResource.getEncoding() != null) {
					inputSource.setEncoding(encodedResource.getEncoding());
				}
				//加载bean
        // B
				return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
			}
			finally {
				inputStream.close();
			}
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(
					&quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);
		}
		finally {
			currentResources.remove(encodedResource);
			if (currentResources.isEmpty()) {
				this.resourcesCurrentlyBeingLoaded.remove();
			}
		}
	}
```

​	以上代码在前面分析加载文件的时候已经看过了,不过这次的重点是在B处,继续跟下去.

```java
protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
			throws BeanDefinitionStoreException {

		try {
			// 加载xml
			// C
			Document doc = doLoadDocument(inputSource, resource);
			// 注册bean
			// D
			int count = registerBeanDefinitions(doc, resource);
			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource);
			}
			return count;
		}
		catch (BeanDefinitionStoreException ex) {
			throw ex;
		}
		catch (SAXParseException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					&quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);
		}
		catch (SAXException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					&quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);
		}
		catch (ParserConfigurationException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;Parser configuration exception parsing XML from &quot; + resource, ex);
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;IOException parsing XML document from &quot; + resource, ex);
		}
		catch (Throwable ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;Unexpected exception parsing XML document from &quot; + resource, ex);
		}
	}
```

​	可以看到加载xml的地方是在C处,跟下去看看spring 有没有对加载xml文件做什么特殊处理.

```java
protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception {
		return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,
				getValidationModeForResource(resource), isNamespaceAware());
	}
```

​	`doLoadDocument`方法并未对xml进行处理,而是委托`DocumentLoader`进行处理,而`DocumentLoader`又是个接口,这里使用的是它的默认实现`DefaultDocumentLoader`.

​	在`DocumentLoader`接口中只有一个方法.

```java
public interface DocumentLoader {

	/**
	 * @param inputSource xml 文件
	 * @param entityResolver 实体解析对象
	 * @param errorHandler 错误处理器
	 * @param validationMode 验证模式
	 * @param namespaceAware 是否自动感知名称空间
	 */
	Document loadDocument(
			InputSource inputSource, EntityResolver entityResolver,
			ErrorHandler errorHandler, int validationMode, boolean namespaceAware)
			throws Exception;
}

```

​	参数说明:

 - InputSource

   这个是指xml文件,这个没有什么好说的

- EntityResolver

  用于加载约束文件,这个约束文件就是xml的dtd和xsd.dtd和xsd是用于校验xml内容

  是否合法.而这个解析器跟前面ResourceLoader一样,最后都是用来查找文件,无论是

  在本地文件系统,还是在远程主机上.

- ErrorHandler

  用于处理加载xml过程中出现的异常,一般是记录日志

- validationMode

  用于指定验证模式,验证模式有四种:

  1. VALIDATION_NONE

     禁用验证

  2. VALIDATION_AUTO

     自动检测验证,默认值

  3. VALIDATION_DTD

     采用DTD验证

  4. VALIDATION_XSD

     采用XSD验证

- namespaceAware

  命名空间支持。如果要提供对 XML 名称空间的支持，则需要值为true

## 2.1 EntityResolver

​	`EntityResolver` 是通过 `getEntityResolver`方法获取的,`EntityResolver`也是个接口,用于解析dtd,xsd文件.

```java
public interface EntityResolver {

    public abstract InputSource resolveEntity (String publicId,
                                               String systemId)
        throws SAXException, IOException;

}
```

​	至于这两个参数,是什么意思,可以百度一下.

## 2.2 getEntityResolver() 方法

```java
protected EntityResolver getEntityResolver() {
		// 如果解析器为空
		if (this.entityResolver == null) {
			// Determine default EntityResolver to use.
			// 获取资源加载器
			ResourceLoader resourceLoader = getResourceLoader();
			if (resourceLoader != null) {
				// 如果资源加载器不为空,则使用资源实体解析器
				this.entityResolver = new ResourceEntityResolver(resourceLoader);
			}
			else {
				// 如果为空,则委托其他的解析器
				// 默认的为 BeansDtdResolver 和 PluggableSchemaResolver
				this.entityResolver = new DelegatingEntityResolver(getBeanClassLoader());
			}
		}
		return this.entityResolver;
	}
```

​	以上代码通过多次判断,要么返回`ResourceEntityResolver`要么返回`DelegatingEntityResolver`.这两个解析器是个什么关系?

​	![images](https://gitee.com/oneww/onew_image/raw/master/ResourceEntityResolver.png)	

​	可以看到 `ResourceEntityResolver`是继承`DelegatingEntityResolver`,而`DelegatingEntityResolver`实现了`EntityResolver`接口.

```java
public class ResourceEntityResolver extends DelegatingEntityResolver {

	private static final Log logger = LogFactory.getLog(ResourceEntityResolver.class);

	private final ResourceLoader resourceLoader;


	/**
	 * Create a ResourceEntityResolver for the specified ResourceLoader
	 * (usually, an ApplicationContext).
	 * @param resourceLoader the ResourceLoader (or ApplicationContext)
	 * to load XML entity includes with
	 */
	public ResourceEntityResolver(ResourceLoader resourceLoader) {
		super(resourceLoader.getClassLoader());
		this.resourceLoader = resourceLoader;
	}


	@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId)
			throws SAXException, IOException {
		// 调用父类 DelegatingEntityResolver::resolveEntity 获取xsd或者dtd,都是从本地的classpath路径下加载文件
		InputSource source = super.resolveEntity(publicId, systemId);

		//如果 DelegatingEntityResolver::resolveEntity 本地未能加载到xsd或者dtd文件
		if (source == null &amp;&amp; systemId != null) {
			String resourcePath = null;
			try {
				// 使用UTF-8 解码
				String decodedSystemId = URLDecoder.decode(systemId, &quot;UTF-8&quot;);
				// 转为URL
				String givenUrl = new URL(decodedSystemId).toString();
				// 解析文件资源的相对路径（相对于系统根路径）
				String systemRootUrl = new File(&quot;&quot;).toURI().toURL().toString();
				// Try relative to resource base if currently in system root.
				if (givenUrl.startsWith(systemRootUrl)) {
					resourcePath = givenUrl.substring(systemRootUrl.length());
				}
			}
			catch (Exception ex) {
				// Typically a MalformedURLException or AccessControlException.
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Could not resolve XML entity [&quot; + systemId + &quot;] against system root URL&quot;, ex);
				}
				// No URL (or no resolvable URL) -&gt; try relative to resource base.
				resourcePath = systemId;
			}
			if (resourcePath != null) {
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Trying to locate XML entity [&quot; + systemId + &quot;] as resource [&quot; + resourcePath + &quot;]&quot;);
				}
				// 再次尝试从classpath路径下加载文件
				Resource resource = this.resourceLoader.getResource(resourcePath);
				source = new InputSource(resource.getInputStream());
				source.setPublicId(publicId);
				source.setSystemId(systemId);
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Found XML entity [&quot; + systemId + &quot;]: &quot; + resource);
				}
			}//实在没有办法了,从网络上进行加载
			else if (systemId.endsWith(DTD_SUFFIX) || systemId.endsWith(XSD_SUFFIX)) {
				// External dtd/xsd lookup via https even for canonical http declaration
				String url = systemId;
				if (url.startsWith(&quot;http:&quot;)) {
					url = &quot;https:&quot; + url.substring(5);
				}
				try {
					//通过url http加载资源,网络情况不好的情况下很容易挂
					source = new InputSource(new URL(url).openStream());
					source.setPublicId(publicId);
					source.setSystemId(systemId);
				}
				catch (IOException ex) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Could not resolve XML entity [&quot; + systemId + &quot;] through URL [&quot; + url + &quot;]&quot;, ex);
					}
					// Fall back to the parser's default behavior.
					source = null;
				}
			}
		}

		return source;
	}

}

```

​	大致逻辑如下:

1. 调用父解析器,进行解析.如果能加载到文件,则返回.

 	2. 尝试从classpath路径进行加载
 	3. 尝试从网络上进行加载
 	4. 加载成功 返回 InputSource 对象 否则 返回 NULL

逻辑并不复杂,这里涉及到父解析器`DelegatingEntityResolver`.

```java
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.beans.factory.xml;

import java.io.IOException;

import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * {@link EntityResolver} implementation that delegates to a {@link BeansDtdResolver}
 * and a {@link PluggableSchemaResolver} for DTDs and XML schemas, respectively.
 *
 * @author Rob Harrop
 * @author Juergen Hoeller
 * @author Rick Evans
 * @since 2.0
 * @see BeansDtdResolver
 * @see PluggableSchemaResolver
 */
public class DelegatingEntityResolver implements EntityResolver {

	/** Suffix for DTD files. */
  // 后缀常量
	public static final String DTD_SUFFIX = &quot;.dtd&quot;;

	/** Suffix for schema definition files. */
  // 后缀常量
	public static final String XSD_SUFFIX = &quot;.xsd&quot;;

	// dtd 解析器
	private final EntityResolver dtdResolver;
	// xsd 解析器
	private final EntityResolver schemaResolver;


	
	public DelegatingEntityResolver(@Nullable ClassLoader classLoader) {
		this.dtdResolver = new BeansDtdResolver();
		this.schemaResolver = new PluggableSchemaResolver(classLoader);
	}

	
	public DelegatingEntityResolver(EntityResolver dtdResolver, EntityResolver schemaResolver) {
		Assert.notNull(dtdResolver, &quot;'dtdResolver' is required&quot;);
		Assert.notNull(schemaResolver, &quot;'schemaResolver' is required&quot;);
		this.dtdResolver = dtdResolver;
		this.schemaResolver = schemaResolver;
	}


	@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId)
			throws SAXException, IOException {
		//通过后缀去获取资源路径
		if (systemId != null) {
			// DTD 模式
			if (systemId.endsWith(DTD_SUFFIX)) {
				// 默认为 BeansDtdResolver
				return this.dtdResolver.resolveEntity(publicId, systemId);
			}
			// XSD 模式
			else if (systemId.endsWith(XSD_SUFFIX)) {
				// 默认为 PluggableSchemaResolver
				return this.schemaResolver.resolveEntity(publicId, systemId);
			}
		}

		// Fall back to the parser's default behavior.
		return null;
	}


	@Override
	public String toString() {
		return &quot;EntityResolver delegating &quot; + XSD_SUFFIX + &quot; to &quot; + this.schemaResolver +
				&quot; and &quot; + DTD_SUFFIX + &quot; to &quot; + this.dtdResolver;
	}

}

```

​	`DelegatingEntityResolver`中的`resolveEntity`方法并没有真正的进行逻辑处理,而是委托`dtdResolver`和

`schemaResolver`进行处理,这两个解析器一个负责DTD,另外一个负责XSD.

​	`dtdResolver` 默认为:`BeansDtdResolver`

​	`schemaResolver`默认为:`PluggableSchemaResolver`



## 2.3 BeansDtdResolver

```java
public class BeansDtdResolver implements EntityResolver {
	// DTD 后缀常量
	private static final String DTD_EXTENSION = &quot;.dtd&quot;;
	// DTD 名称
	private static final String DTD_NAME = &quot;spring-beans&quot;;

	private static final Log logger = LogFactory.getLog(BeansDtdResolver.class);


	@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws IOException {
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Trying to resolve XML entity with public ID [&quot; + publicId +
					&quot;] and system ID [&quot; + systemId + &quot;]&quot;);
		}
		// 判断后缀是否是 DTD,并且systemId 不能为空
		if (systemId != null &amp;&amp; systemId.endsWith(DTD_EXTENSION)) {
      // 分隔符
			int lastPathSeparator = systemId.lastIndexOf('/');
			int dtdNameStart = systemId.indexOf(DTD_NAME, lastPathSeparator);
			// systemId url 中 必须包含 spring-beans
			if (dtdNameStart != -1) {
				// 并且dtd文件名
				String dtdFile = DTD_NAME + DTD_EXTENSION;
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Trying to locate [&quot; + dtdFile + &quot;] in Spring jar on classpath&quot;);
				}
				try {
					// 加载classpath路径下的spring-beans.dtd文件
					Resource resource = new ClassPathResource(dtdFile, getClass());
					InputSource source = new InputSource(resource.getInputStream());
					// 设置publicId
					source.setPublicId(publicId);
					// 设置systemId
					source.setSystemId(systemId);
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Found beans DTD [&quot; + systemId + &quot;] in classpath: &quot; + dtdFile);
					}
					return source;
				}
				catch (FileNotFoundException ex) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Could not resolve beans DTD [&quot; + systemId + &quot;]: not found in classpath&quot;, ex);
					}
				}
			}
		}

		// Fall back to the parser's default behavior.
		return null;
	}


	@Override
	public String toString() {
		return &quot;EntityResolver for spring-beans DTD&quot;;
	}

}

```

 `BeansDtdResolver` 逻辑为,从classpath下加载文件名为`spring-beans.dtd`的dtd文件



## 2.4 PluggableSchemaResolver

```java
public class PluggableSchemaResolver implements EntityResolver {

	/**
	 * The location of the file that defines schema mappings.
	 * Can be present in multiple JAR files.
	 */
	public static final String DEFAULT_SCHEMA_MAPPINGS_LOCATION = &quot;META-INF/spring.schemas&quot;;


	private static final Log logger = LogFactory.getLog(PluggableSchemaResolver.class);

	@Nullable
	private final ClassLoader classLoader;

	private final String schemaMappingsLocation;

	/** Stores the mapping of schema URL -&gt; local schema path. */
	@Nullable
	private volatile Map&lt;String, String&gt; schemaMappings;


	
	public PluggableSchemaResolver(@Nullable ClassLoader classLoader) {
		this.classLoader = classLoader;
		this.schemaMappingsLocation = DEFAULT_SCHEMA_MAPPINGS_LOCATION;
	}

	public PluggableSchemaResolver(@Nullable ClassLoader classLoader, String schemaMappingsLocation) {
		Assert.hasText(schemaMappingsLocation, &quot;'schemaMappingsLocation' must not be empty&quot;);
		this.classLoader = classLoader;
		this.schemaMappingsLocation = schemaMappingsLocation;
	}

	/***
	 * 先把xsd文件下载到本地,在进行加载
	 * **/
	@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws IOException {
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Trying to resolve XML entity with public id [&quot; + publicId +
					&quot;] and system id [&quot; + systemId + &quot;]&quot;);
		}
		// systemId url 不能为空
		if (systemId != null) {
			// 从缓存中加载xsd文件
			// 判断缓存中是否有xsd文件
			// 缓存中的xsd文件都是从网络中加载
			String resourceLocation = getSchemaMappings().get(systemId);
			if (resourceLocation == null &amp;&amp; systemId.startsWith(&quot;https:&quot;)) {
				// Retrieve canonical http schema mapping even for https declaration
				// 如果https 未找到约束文件 则尝试从http 获取缓存
				resourceLocation = getSchemaMappings().get(&quot;http:&quot; + systemId.substring(6));
			}
			//如果缓存命中
			if (resourceLocation != null) {
				//从classpath路径中加载xsd文件
				Resource resource = new ClassPathResource(resourceLocation, this.classLoader);
				try {
					InputSource source = new InputSource(resource.getInputStream());
					// 设置publicId
					source.setPublicId(publicId);
					// 设置systemId
					source.setSystemId(systemId);
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Found XML schema [&quot; + systemId + &quot;] in classpath: &quot; + resourceLocation);
					}
					return source;
				}
				catch (FileNotFoundException ex) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Could not find XML schema [&quot; + systemId + &quot;]: &quot; + resource, ex);
					}
				}
			}
		}

		// Fall back to the parser's default behavior.
		return null;
	}

	/**
	 * Load the specified schema mappings lazily.
	 */
	private Map&lt;String, String&gt; getSchemaMappings() {
		Map&lt;String, String&gt; schemaMappings = this.schemaMappings;
		if (schemaMappings == null) {
			// 单利模式 同步
			synchronized (this) {
				schemaMappings = this.schemaMappings;
				// 双重检查
				if (schemaMappings == null) {
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Loading schema mappings from [&quot; + this.schemaMappingsLocation + &quot;]&quot;);
					}
					try {
						// 加载clsspath路径下的 META-INF/spring.schemas
						Properties mappings =
								PropertiesLoaderUtils.loadAllProperties(this.schemaMappingsLocation, this.classLoader);
						if (logger.isTraceEnabled()) {
							logger.trace(&quot;Loaded schema mappings: &quot; + mappings);
						}
						// 创建线程安全的的hashMap
						schemaMappings = new ConcurrentHashMap&lt;&gt;(mappings.size());
						// properties 转 hashMap
						CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings);
						// 赋值
						this.schemaMappings = schemaMappings;
					}
					catch (IOException ex) {
						throw new IllegalStateException(
								&quot;Unable to load schema mappings from location [&quot; + this.schemaMappingsLocation + &quot;]&quot;, ex);
					}
				}
			}
		}
		return schemaMappings;
	}


	@Override
	public String toString() {
		return &quot;EntityResolver using schema mappings &quot; + getSchemaMappings();
	}

}

```

​	`PluggableSchemaResolver`大体逻辑如下:

	1. 先根据classpath路径下的` META-INF/spring.schemas`文件创建一个缓存`schemaMappings`
 	2. 从`schemaMappings`获取指定`systemId`的xsd文件路径,如果未获取到返回null
 	3. 根据xsd路径加载xsd文件返回 `InputSource` 对象



## 2.5 getValidationModeForResource()

```java
protected int getValidationModeForResource(Resource resource) {
		// 获取验证模式,默认为自动
		int validationModeToUse = getValidationMode();
		// 如果手动指定验证模式则使用指定的验证模式
		if (validationModeToUse != VALIDATION_AUTO) {
			return validationModeToUse;
		}
		// 非手动指定验证模式,自动检测验证模式
		int detectedMode = detectValidationMode(resource);
		if (detectedMode != VALIDATION_AUTO) {
			return detectedMode;
		}
		// Hmm, we didn't get a clear indication... Let's assume XSD,
		// since apparently no DTD declaration has been found up until
		// detection stopped (before finding the document's root tag).
		// 以上都未获取验证模式,则使用xsd验证模式
		return VALIDATION_XSD;
	}
```



## 2.6 loadDocument()

```java
@Override
	public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
			ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {
		// 解析xml常用套路
		DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);
		}
		// 解析xml常用套路
		DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
		return builder.parse(inputSource);
	}

	/**
	 * Create the {@link DocumentBuilderFactory} instance.
	 * @param validationMode the type of validation: {@link XmlValidationModeDetector#VALIDATION_DTD DTD}
	 * or {@link XmlValidationModeDetector#VALIDATION_XSD XSD})
	 * @param namespaceAware whether the returned factory is to provide support for XML namespaces
	 * @return the JAXP DocumentBuilderFactory
	 * @throws ParserConfigurationException if we failed to build a proper DocumentBuilderFactory
	 */
	protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware)
			throws ParserConfigurationException {

		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		// 设置命名空间支持
		factory.setNamespaceAware(namespaceAware);
		// 非禁用验证模式
		if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) {
			// 开启校验
			factory.setValidating(true);
			// 如果为XSD
			if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {
				// Enforce namespace aware for XSD...
				// XSD 模式下，强制设置命名空间支持
				factory.setNamespaceAware(true);
				try {
					// 设置 SCHEMA_LANGUAGE_ATTRIBUTE
					factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);
				}
				catch (IllegalArgumentException ex) {
					ParserConfigurationException pcex = new ParserConfigurationException(
							&quot;Unable to validate using XSD: Your JAXP provider [&quot; + factory +
							&quot;] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? &quot; +
							&quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;);
					pcex.initCause(ex);
					throw pcex;
				}
			}
		}

		return factory;
	}

```



# 三、小结

​	xml 加载并创建为 `Document` 对象,接下来就是 解析并创建为bean.</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">一、前言 ​ 前面资源文件加载搞定了,来看看 spring 是如何把 xml 文件变成 bean 的吧. 二、分析 ​ 还是从4句代码看起. @Test public void testSpringLoadXml(){ // 加载xml BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;com/sjr/test/bean/MyTestBean.xml&quot;)); // 获取bean final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class); final String testStr = testBean.getTestStr(); System.out.println(testStr); } ​ 从解析xml 到 获取bean都是从XmlBeanFactory中操作的,那么就来看看XmlBeanFactory里面有啥. public class XmlBeanFactory extends DefaultListableBeanFactory { private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this); /** * 构造函数 */ public XmlBeanFactory(Resource resource) throws BeansException { this(resource, null); } /** * 构造函数 * 指定 父BeanFactory */ public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException { super(parentBeanFactory); // 核心代码 A this.reader.loadBeanDefinitions(resource); } } ​ 可以看到核心代码在A处,A处用XmlBeanDefinitionReader进行读取文件,继续跟下去. @Override public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException { // 把classPathsResource转换为EncodedResource,默认字符编码为空 return loadBeanDefinitions(new EncodedResource(resource)); } public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException { //加载资源,资源不能为空 Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); if (logger.isTraceEnabled()) { logger.trace(&quot;Loading XML bean definitions from &quot; + encodedResource); } //判断当前线程是否加载过资源,如果没有则创建一个set来保存encodedResource Set&amp;lt;EncodedResource&amp;gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) { currentResources = new HashSet&amp;lt;&amp;gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); } //判断是否有已近添加过相同的encodedResource if (!currentResources.add(encodedResource)) { throw new BeanDefinitionStoreException( &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;); } try { //获取xml文件流 InputStream inputStream = encodedResource.getResource().getInputStream(); try { InputSource inputSource = new InputSource(inputStream); //如果编码不为空,则设置文件编码 if (encodedResource.getEncoding() != null) { inputSource.setEncoding(encodedResource.getEncoding()); } //加载bean // B return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); } finally { inputStream.close(); } } catch (IOException ex) { throw new BeanDefinitionStoreException( &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex); } finally { currentResources.remove(encodedResource); if (currentResources.isEmpty()) { this.resourcesCurrentlyBeingLoaded.remove(); } } } ​ 以上代码在前面分析加载文件的时候已经看过了,不过这次的重点是在B处,继续跟下去. protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { // 加载xml // C Document doc = doLoadDocument(inputSource, resource); // 注册bean // D int count = registerBeanDefinitions(doc, resource); if (logger.isDebugEnabled()) { logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource); } return count; } catch (BeanDefinitionStoreException ex) { throw ex; } catch (SAXParseException ex) { throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex); } catch (SAXException ex) { throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex); } catch (ParserConfigurationException ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Parser configuration exception parsing XML from &quot; + resource, ex); } catch (IOException ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;IOException parsing XML document from &quot; + resource, ex); } catch (Throwable ex) { throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Unexpected exception parsing XML document from &quot; + resource, ex); } } ​ 可以看到加载xml的地方是在C处,跟下去看看spring 有没有对加载xml文件做什么特殊处理. protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception { return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware()); } ​ doLoadDocument方法并未对xml进行处理,而是委托DocumentLoader进行处理,而DocumentLoader又是个接口,这里使用的是它的默认实现DefaultDocumentLoader. ​ 在DocumentLoader接口中只有一个方法. public interface DocumentLoader { /** * @param inputSource xml 文件 * @param entityResolver 实体解析对象 * @param errorHandler 错误处理器 * @param validationMode 验证模式 * @param namespaceAware 是否自动感知名称空间 */ Document loadDocument( InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception; } ​ 参数说明: InputSource 这个是指xml文件,这个没有什么好说的 EntityResolver 用于加载约束文件,这个约束文件就是xml的dtd和xsd.dtd和xsd是用于校验xml内容 是否合法.而这个解析器跟前面ResourceLoader一样,最后都是用来查找文件,无论是 在本地文件系统,还是在远程主机上. ErrorHandler 用于处理加载xml过程中出现的异常,一般是记录日志 validationMode 用于指定验证模式,验证模式有四种: VALIDATION_NONE 禁用验证 VALIDATION_AUTO 自动检测验证,默认值 VALIDATION_DTD 采用DTD验证 VALIDATION_XSD 采用XSD验证 namespaceAware 命名空间支持。如果要提供对 XML 名称空间的支持，则需要值为true 2.1 EntityResolver ​ EntityResolver 是通过 getEntityResolver方法获取的,EntityResolver也是个接口,用于解析dtd,xsd文件. public interface EntityResolver { public abstract InputSource resolveEntity (String publicId, String systemId) throws SAXException, IOException; } ​ 至于这两个参数,是什么意思,可以百度一下. 2.2 getEntityResolver() 方法 protected EntityResolver getEntityResolver() { // 如果解析器为空 if (this.entityResolver == null) { // Determine default EntityResolver to use. // 获取资源加载器 ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader != null) { // 如果资源加载器不为空,则使用资源实体解析器 this.entityResolver = new ResourceEntityResolver(resourceLoader); } else { // 如果为空,则委托其他的解析器 // 默认的为 BeansDtdResolver 和 PluggableSchemaResolver this.entityResolver = new DelegatingEntityResolver(getBeanClassLoader()); } } return this.entityResolver; } ​ 以上代码通过多次判断,要么返回ResourceEntityResolver要么返回DelegatingEntityResolver.这两个解析器是个什么关系? ​ ​ 可以看到 ResourceEntityResolver是继承DelegatingEntityResolver,而DelegatingEntityResolver实现了EntityResolver接口. public class ResourceEntityResolver extends DelegatingEntityResolver { private static final Log logger = LogFactory.getLog(ResourceEntityResolver.class); private final ResourceLoader resourceLoader; /** * Create a ResourceEntityResolver for the specified ResourceLoader * (usually, an ApplicationContext). * @param resourceLoader the ResourceLoader (or ApplicationContext) * to load XML entity includes with */ public ResourceEntityResolver(ResourceLoader resourceLoader) { super(resourceLoader.getClassLoader()); this.resourceLoader = resourceLoader; } @Override @Nullable public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws SAXException, IOException { // 调用父类 DelegatingEntityResolver::resolveEntity 获取xsd或者dtd,都是从本地的classpath路径下加载文件 InputSource source = super.resolveEntity(publicId, systemId); //如果 DelegatingEntityResolver::resolveEntity 本地未能加载到xsd或者dtd文件 if (source == null &amp;amp;&amp;amp; systemId != null) { String resourcePath = null; try { // 使用UTF-8 解码 String decodedSystemId = URLDecoder.decode(systemId, &quot;UTF-8&quot;); // 转为URL String givenUrl = new URL(decodedSystemId).toString(); // 解析文件资源的相对路径（相对于系统根路径） String systemRootUrl = new File(&quot;&quot;).toURI().toURL().toString(); // Try relative to resource base if currently in system root. if (givenUrl.startsWith(systemRootUrl)) { resourcePath = givenUrl.substring(systemRootUrl.length()); } } catch (Exception ex) { // Typically a MalformedURLException or AccessControlException. if (logger.isDebugEnabled()) { logger.debug(&quot;Could not resolve XML entity [&quot; + systemId + &quot;] against system root URL&quot;, ex); } // No URL (or no resolvable URL) -&amp;gt; try relative to resource base. resourcePath = systemId; } if (resourcePath != null) { if (logger.isTraceEnabled()) { logger.trace(&quot;Trying to locate XML entity [&quot; + systemId + &quot;] as resource [&quot; + resourcePath + &quot;]&quot;); } // 再次尝试从classpath路径下加载文件 Resource resource = this.resourceLoader.getResource(resourcePath); source = new InputSource(resource.getInputStream()); source.setPublicId(publicId); source.setSystemId(systemId); if (logger.isDebugEnabled()) { logger.debug(&quot;Found XML entity [&quot; + systemId + &quot;]: &quot; + resource); } }//实在没有办法了,从网络上进行加载 else if (systemId.endsWith(DTD_SUFFIX) || systemId.endsWith(XSD_SUFFIX)) { // External dtd/xsd lookup via https even for canonical http declaration String url = systemId; if (url.startsWith(&quot;http:&quot;)) { url = &quot;https:&quot; + url.substring(5); } try { //通过url http加载资源,网络情况不好的情况下很容易挂 source = new InputSource(new URL(url).openStream()); source.setPublicId(publicId); source.setSystemId(systemId); } catch (IOException ex) { if (logger.isDebugEnabled()) { logger.debug(&quot;Could not resolve XML entity [&quot; + systemId + &quot;] through URL [&quot; + url + &quot;]&quot;, ex); } // Fall back to the parser's default behavior. source = null; } } } return source; } } ​ 大致逻辑如下: 调用父解析器,进行解析.如果能加载到文件,则返回. 2. 尝试从classpath路径进行加载 3. 尝试从网络上进行加载 4. 加载成功 返回 InputSource 对象 否则 返回 NULL 逻辑并不复杂,这里涉及到父解析器DelegatingEntityResolver. /* * Copyright 2002-2019 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.springframework.beans.factory.xml; import java.io.IOException; import org.xml.sax.EntityResolver; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.springframework.lang.Nullable; import org.springframework.util.Assert; /** * {@link EntityResolver} implementation that delegates to a {@link BeansDtdResolver} * and a {@link PluggableSchemaResolver} for DTDs and XML schemas, respectively. * * @author Rob Harrop * @author Juergen Hoeller * @author Rick Evans * @since 2.0 * @see BeansDtdResolver * @see PluggableSchemaResolver */ public class DelegatingEntityResolver implements EntityResolver { /** Suffix for DTD files. */ // 后缀常量 public static final String DTD_SUFFIX = &quot;.dtd&quot;; /** Suffix for schema definition files. */ // 后缀常量 public static final String XSD_SUFFIX = &quot;.xsd&quot;; // dtd 解析器 private final EntityResolver dtdResolver; // xsd 解析器 private final EntityResolver schemaResolver; public DelegatingEntityResolver(@Nullable ClassLoader classLoader) { this.dtdResolver = new BeansDtdResolver(); this.schemaResolver = new PluggableSchemaResolver(classLoader); } public DelegatingEntityResolver(EntityResolver dtdResolver, EntityResolver schemaResolver) { Assert.notNull(dtdResolver, &quot;'dtdResolver' is required&quot;); Assert.notNull(schemaResolver, &quot;'schemaResolver' is required&quot;); this.dtdResolver = dtdResolver; this.schemaResolver = schemaResolver; } @Override @Nullable public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws SAXException, IOException { //通过后缀去获取资源路径 if (systemId != null) { // DTD 模式 if (systemId.endsWith(DTD_SUFFIX)) { // 默认为 BeansDtdResolver return this.dtdResolver.resolveEntity(publicId, systemId); } // XSD 模式 else if (systemId.endsWith(XSD_SUFFIX)) { // 默认为 PluggableSchemaResolver return this.schemaResolver.resolveEntity(publicId, systemId); } } // Fall back to the parser's default behavior. return null; } @Override public String toString() { return &quot;EntityResolver delegating &quot; + XSD_SUFFIX + &quot; to &quot; + this.schemaResolver + &quot; and &quot; + DTD_SUFFIX + &quot; to &quot; + this.dtdResolver; } } ​ DelegatingEntityResolver中的resolveEntity方法并没有真正的进行逻辑处理,而是委托dtdResolver和 schemaResolver进行处理,这两个解析器一个负责DTD,另外一个负责XSD. ​ dtdResolver 默认为:BeansDtdResolver ​ schemaResolver默认为:PluggableSchemaResolver 2.3 BeansDtdResolver public class BeansDtdResolver implements EntityResolver { // DTD 后缀常量 private static final String DTD_EXTENSION = &quot;.dtd&quot;; // DTD 名称 private static final String DTD_NAME = &quot;spring-beans&quot;; private static final Log logger = LogFactory.getLog(BeansDtdResolver.class); @Override @Nullable public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws IOException { if (logger.isTraceEnabled()) { logger.trace(&quot;Trying to resolve XML entity with public ID [&quot; + publicId + &quot;] and system ID [&quot; + systemId + &quot;]&quot;); } // 判断后缀是否是 DTD,并且systemId 不能为空 if (systemId != null &amp;amp;&amp;amp; systemId.endsWith(DTD_EXTENSION)) { // 分隔符 int lastPathSeparator = systemId.lastIndexOf('/'); int dtdNameStart = systemId.indexOf(DTD_NAME, lastPathSeparator); // systemId url 中 必须包含 spring-beans if (dtdNameStart != -1) { // 并且dtd文件名 String dtdFile = DTD_NAME + DTD_EXTENSION; if (logger.isTraceEnabled()) { logger.trace(&quot;Trying to locate [&quot; + dtdFile + &quot;] in Spring jar on classpath&quot;); } try { // 加载classpath路径下的spring-beans.dtd文件 Resource resource = new ClassPathResource(dtdFile, getClass()); InputSource source = new InputSource(resource.getInputStream()); // 设置publicId source.setPublicId(publicId); // 设置systemId source.setSystemId(systemId); if (logger.isTraceEnabled()) { logger.trace(&quot;Found beans DTD [&quot; + systemId + &quot;] in classpath: &quot; + dtdFile); } return source; } catch (FileNotFoundException ex) { if (logger.isDebugEnabled()) { logger.debug(&quot;Could not resolve beans DTD [&quot; + systemId + &quot;]: not found in classpath&quot;, ex); } } } } // Fall back to the parser's default behavior. return null; } @Override public String toString() { return &quot;EntityResolver for spring-beans DTD&quot;; } } BeansDtdResolver 逻辑为,从classpath下加载文件名为spring-beans.dtd的dtd文件 2.4 PluggableSchemaResolver public class PluggableSchemaResolver implements EntityResolver { /** * The location of the file that defines schema mappings. * Can be present in multiple JAR files. */ public static final String DEFAULT_SCHEMA_MAPPINGS_LOCATION = &quot;META-INF/spring.schemas&quot;; private static final Log logger = LogFactory.getLog(PluggableSchemaResolver.class); @Nullable private final ClassLoader classLoader; private final String schemaMappingsLocation; /** Stores the mapping of schema URL -&amp;gt; local schema path. */ @Nullable private volatile Map&amp;lt;String, String&amp;gt; schemaMappings; public PluggableSchemaResolver(@Nullable ClassLoader classLoader) { this.classLoader = classLoader; this.schemaMappingsLocation = DEFAULT_SCHEMA_MAPPINGS_LOCATION; } public PluggableSchemaResolver(@Nullable ClassLoader classLoader, String schemaMappingsLocation) { Assert.hasText(schemaMappingsLocation, &quot;'schemaMappingsLocation' must not be empty&quot;); this.classLoader = classLoader; this.schemaMappingsLocation = schemaMappingsLocation; } /*** * 先把xsd文件下载到本地,在进行加载 * **/ @Override @Nullable public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws IOException { if (logger.isTraceEnabled()) { logger.trace(&quot;Trying to resolve XML entity with public id [&quot; + publicId + &quot;] and system id [&quot; + systemId + &quot;]&quot;); } // systemId url 不能为空 if (systemId != null) { // 从缓存中加载xsd文件 // 判断缓存中是否有xsd文件 // 缓存中的xsd文件都是从网络中加载 String resourceLocation = getSchemaMappings().get(systemId); if (resourceLocation == null &amp;amp;&amp;amp; systemId.startsWith(&quot;https:&quot;)) { // Retrieve canonical http schema mapping even for https declaration // 如果https 未找到约束文件 则尝试从http 获取缓存 resourceLocation = getSchemaMappings().get(&quot;http:&quot; + systemId.substring(6)); } //如果缓存命中 if (resourceLocation != null) { //从classpath路径中加载xsd文件 Resource resource = new ClassPathResource(resourceLocation, this.classLoader); try { InputSource source = new InputSource(resource.getInputStream()); // 设置publicId source.setPublicId(publicId); // 设置systemId source.setSystemId(systemId); if (logger.isTraceEnabled()) { logger.trace(&quot;Found XML schema [&quot; + systemId + &quot;] in classpath: &quot; + resourceLocation); } return source; } catch (FileNotFoundException ex) { if (logger.isDebugEnabled()) { logger.debug(&quot;Could not find XML schema [&quot; + systemId + &quot;]: &quot; + resource, ex); } } } } // Fall back to the parser's default behavior. return null; } /** * Load the specified schema mappings lazily. */ private Map&amp;lt;String, String&amp;gt; getSchemaMappings() { Map&amp;lt;String, String&amp;gt; schemaMappings = this.schemaMappings; if (schemaMappings == null) { // 单利模式 同步 synchronized (this) { schemaMappings = this.schemaMappings; // 双重检查 if (schemaMappings == null) { if (logger.isTraceEnabled()) { logger.trace(&quot;Loading schema mappings from [&quot; + this.schemaMappingsLocation + &quot;]&quot;); } try { // 加载clsspath路径下的 META-INF/spring.schemas Properties mappings = PropertiesLoaderUtils.loadAllProperties(this.schemaMappingsLocation, this.classLoader); if (logger.isTraceEnabled()) { logger.trace(&quot;Loaded schema mappings: &quot; + mappings); } // 创建线程安全的的hashMap schemaMappings = new ConcurrentHashMap&amp;lt;&amp;gt;(mappings.size()); // properties 转 hashMap CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings); // 赋值 this.schemaMappings = schemaMappings; } catch (IOException ex) { throw new IllegalStateException( &quot;Unable to load schema mappings from location [&quot; + this.schemaMappingsLocation + &quot;]&quot;, ex); } } } } return schemaMappings; } @Override public String toString() { return &quot;EntityResolver using schema mappings &quot; + getSchemaMappings(); } } ​ PluggableSchemaResolver大体逻辑如下: 1. 先根据classpath路径下的` META-INF/spring.schemas`文件创建一个缓存`schemaMappings` 2. 从`schemaMappings`获取指定`systemId`的xsd文件路径,如果未获取到返回null 3. 根据xsd路径加载xsd文件返回 `InputSource` 对象 2.5 getValidationModeForResource() protected int getValidationModeForResource(Resource resource) { // 获取验证模式,默认为自动 int validationModeToUse = getValidationMode(); // 如果手动指定验证模式则使用指定的验证模式 if (validationModeToUse != VALIDATION_AUTO) { return validationModeToUse; } // 非手动指定验证模式,自动检测验证模式 int detectedMode = detectValidationMode(resource); if (detectedMode != VALIDATION_AUTO) { return detectedMode; } // Hmm, we didn't get a clear indication... Let's assume XSD, // since apparently no DTD declaration has been found up until // detection stopped (before finding the document's root tag). // 以上都未获取验证模式,则使用xsd验证模式 return VALIDATION_XSD; } 2.6 loadDocument() @Override public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception { // 解析xml常用套路 DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware); if (logger.isTraceEnabled()) { logger.trace(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;); } // 解析xml常用套路 DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler); return builder.parse(inputSource); } /** * Create the {@link DocumentBuilderFactory} instance. * @param validationMode the type of validation: {@link XmlValidationModeDetector#VALIDATION_DTD DTD} * or {@link XmlValidationModeDetector#VALIDATION_XSD XSD}) * @param namespaceAware whether the returned factory is to provide support for XML namespaces * @return the JAXP DocumentBuilderFactory * @throws ParserConfigurationException if we failed to build a proper DocumentBuilderFactory */ protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware) throws ParserConfigurationException { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // 设置命名空间支持 factory.setNamespaceAware(namespaceAware); // 非禁用验证模式 if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) { // 开启校验 factory.setValidating(true); // 如果为XSD if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) { // Enforce namespace aware for XSD... // XSD 模式下，强制设置命名空间支持 factory.setNamespaceAware(true); try { // 设置 SCHEMA_LANGUAGE_ATTRIBUTE factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE); } catch (IllegalArgumentException ex) { ParserConfigurationException pcex = new ParserConfigurationException( &quot;Unable to validate using XSD: Your JAXP provider [&quot; + factory + &quot;] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? &quot; + &quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;); pcex.initCause(ex); throw pcex; } } } return factory; } 三、小结 ​ xml 加载并创建为 Document 对象,接下来就是 解析并创建为bean.</summary></entry><entry><title type="html">[断点分析之spring-ioc]-资源加载ResourceLoader(二)</title><link href="https://onew.me/spring/2020/02/04/debug-spring-2.html" rel="alternate" type="text/html" title="[断点分析之spring-ioc]-资源加载ResourceLoader(二)" /><published>2020-02-04T09:20:25+08:00</published><updated>2020-02-04T09:20:25+08:00</updated><id>https://onew.me/spring/2020/02/04/debug-spring-2</id><content type="html" xml:base="https://onew.me/spring/2020/02/04/debug-spring-2.html"># 一、前言

​	资源统一抽象为`Resource`对象.可曾记得在 spring 配置文件中的这种写法:`classpath:com/sjr/test/bean/MyTestBean.xml`,那么这种写法的意思是从classpath路径下加载xml,那么spring是如何定位到文件的?

​	上面这种写法相当于是个协议,在spring中默认支持9种文件协议.

- URL_PROTOCOL_FILE

  从文件系统中加载文件

- URL_PROTOCOL_JAR

  从jar包中加载文件

- URL_PROTOCOL_WAR

  从war包中加载文件

- URL_PROTOCOL_ZIP

  从zip中加载文件

- URL_PROTOCOL_WSJAR

  从wsjar中加载文件

- URL_PROTOCOL_VFSZIP

  从vfszip中加载文件

- URL_PROTOCOL_VFSFILE

  从vfsfile中加载文件

- URL_PROTOCOL_VFS

  从vfs中加载文件



# 二、分析

​	这个故事要从一段代码开始

```java
@Test
	public void testSpringResourceLoader(){
		DefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader(this.getClass().getClassLoader());
		BeanFactory factory = new XmlBeanFactory(defaultResourceLoader.getResource(&quot;classpath:com/sjr/test/bean/MyTestBean.xml&quot;));
		final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);
		final String testStr = testBean.getTestStr();
		System.out.println(testStr);
	}
```

​	之前的代码,我们是直接使用的`ClassPathResource`来加载文件,这里使用的`DefaultResourceLoader`对象来加载文件.那`DefaultResourceLoader`有什么用处呢?

1. 自动检测文件该如何加载

 	2. 简化文件加载操作流程

## 2.1 DefaultResourceLoader 

​	`DefaultResourceLoader` 是`ResourceLoader`的默认实现.

![images](https://gitee.com/oneww/onew_image/raw/master/DefaultResourceLoader.png)

上图可以看到 `DefaultResourceLoader` 还有3个子类进行了功能的扩展.先看看`ResourceLoader`这个接口.



## 2.2 ResourceLoader

```java

public interface ResourceLoader {

	/**
	 *  classpath: 前缀常量
	 * */
	String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;


	/**
	 * 通过 路径 获取 Resource 对象
	 */
	Resource getResource(String location);

	/**
	 * 获取类加载器
	 */
	@Nullable
	ClassLoader getClassLoader();

}

```

​	从代码可以看出,该接口只有2个方法,一个是通过路径获取 `Resource` 对象,另外一个是获取类加载器.那么在来看看 `DefaultResourceLoader` 的默认实现代码吧.

## 2.3 DefaultResourceLoader 具体实现

```java

public class DefaultResourceLoader implements ResourceLoader {

	@Nullable
	private ClassLoader classLoader;
	// 协议解析器 set
	private final Set&lt;ProtocolResolver&gt; protocolResolvers = new LinkedHashSet&lt;&gt;(4);
	// 缓存
	private final Map&lt;Class&lt;?&gt;, Map&lt;Resource, ?&gt;&gt; resourceCaches = new ConcurrentHashMap&lt;&gt;(4);


	/**
	 * 使用默认构造器,默认构造器中使用默认的类加载器
	 */
	public DefaultResourceLoader() {
		this.classLoader = ClassUtils.getDefaultClassLoader();
	}

	/**
	 * 使用指定的类加载器
	 */
	public DefaultResourceLoader(@Nullable ClassLoader classLoader) {
		this.classLoader = classLoader;
	}


	/**
	 * 设置类加载器
	 */
	public void setClassLoader(@Nullable ClassLoader classLoader) {
		this.classLoader = classLoader;
	}

	/**
	 * 获取类加载器
	 */
	@Override
	@Nullable
	public ClassLoader getClassLoader() {
		return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());
	}

	/**
	 * 添加协议解析器
	 */
	public void addProtocolResolver(ProtocolResolver resolver) {
		Assert.notNull(resolver, &quot;ProtocolResolver must not be null&quot;);
		this.protocolResolvers.add(resolver);
	}

	/**
	 * 获取协议解析器集合
	 */
	public Collection&lt;ProtocolResolver&gt; getProtocolResolvers() {
		return this.protocolResolvers;
	}

	/**
	 * 获取资源缓存
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T&gt; Map&lt;Resource, T&gt; getResourceCache(Class&lt;T&gt; valueType) {
		return (Map&lt;Resource, T&gt;) this.resourceCaches.computeIfAbsent(valueType, key -&gt; new ConcurrentHashMap&lt;&gt;());
	}

	/**
	 * 清除所有资源缓存
	 */
	public void clearResourceCaches() {
		this.resourceCaches.clear();
	}

	/**
	 * 获取资源
	 * **/
	@Override
	public Resource getResource(String location) {
		Assert.notNull(location, &quot;Location must not be null&quot;);
		// 遍历所有协议解析器
		for (ProtocolResolver protocolResolver : getProtocolResolvers()) {
			// 解析资源
			Resource resource = protocolResolver.resolve(location, this);
			// 如果资源解析到则返回 resource 对象
			if (resource != null) {
				return resource;
			}
		}
		// 判断是否是/开头
		if (location.startsWith(&quot;/&quot;)) {
			// 获取classpath上下文中的资源
			return getResourceByPath(location);
		}
		// 判断是否是classpath:开头路径,如果是则从classpath中获取资源
		else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
			return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
		}
		else {
			try {
				// 尝试把路径转化为url
				// Try to parse the location as a URL...
				URL url = new URL(location);
				// 判断是文件资源 还是url资源
				return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));
			}
			catch (MalformedURLException ex) {
				// No URL -&gt; resolve as resource path.
				// 非url 尝试从 classpath 上下文中获取资源
				return getResourceByPath(location);
			}
		}
	}

	/**
	 * 通过路径获取 Resource 对象
	 * 从 classPath 中加载文件
	 */
	protected Resource getResourceByPath(String path) {
		return new ClassPathContextResource(path, getClassLoader());
	}


	protected static class ClassPathContextResource extends ClassPathResource implements ContextResource {

		public ClassPathContextResource(String path, @Nullable ClassLoader classLoader) {
			super(path, classLoader);
		}

		@Override
		public String getPathWithinContext() {
			return getPath();
		}
		
    /**
    * 创建相对路径的 Resource 对象
    */
		@Override
		public Resource createRelative(String relativePath) {
			String pathToUse = StringUtils.applyRelativePath(getPath(), relativePath);
			return new ClassPathContextResource(pathToUse, getClassLoader());
		}
	}

}

```

​	以上代码的逻辑比较简单明了,核心逻辑在 `getResource` 这个方法中.

```java
	public Resource getResource(String location) {
		Assert.notNull(location, &quot;Location must not be null&quot;);
		// 遍历所有协议解析器
		for (ProtocolResolver protocolResolver : getProtocolResolvers()) {
			// 解析资源
			Resource resource = protocolResolver.resolve(location, this);
			// 如果资源解析到则返回 resource 对象
			if (resource != null) {
				return resource;
			}
		}
		// 判断是否是/开头
		if (location.startsWith(&quot;/&quot;)) {
			// 获取classpath上下文中的资源
			return getResourceByPath(location);
		}
		// 判断是否是classpath:开头路径,如果是则从classpath中获取资源
		else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
			return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
		}
		else {
			try {
				// 尝试把路径转化为url
				// Try to parse the location as a URL...
				URL url = new URL(location);
				// 判断是文件资源 还是url资源
				return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));
			}
			catch (MalformedURLException ex) {
				// No URL -&gt; resolve as resource path.
				// 非url 尝试从 classpath 上下文中获取资源
				return getResourceByPath(location);
			}
		}
	}
```

​	逻辑流程为以下几步:

  1. 判断是否设置了 协议解析器,如果设置了,则遍历所有的协议解析,

     并解析文件,如果解析成功则返回 Resource 对象否则执行第二步.

		2. 判断路径是否是 `/ ` 开头,若是则从classPath 加载文件,调用 

     `getResourceByPath`方法,返回 `Resource` 对象

		3. 判断是否是 `classpath:` 开头,若是则从 classPath 加载文件
		
		4. 若是以上几步都失败,则尝试把路径转为URL,如果成功则返回

     `FileUrlResource` 或 `UrlResource` 对象

		5. 最后挣扎以下,从classPath 加载文件



## 2.4 FileUrlResource

​	开篇说道 spring 默认支持 9中协议(如果把 classPath 也算上的话),那么除了 常用的 classPath 以外,其他的怎么使用呢?其他的笔者本人都没用过多少,就来看看 file 协议吧.

```java

	@Test
	public void testSpringResourceLoaderForFileProtocol(){
		DefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader(this.getClass().getClassLoader());
		BeanFactory factory = new XmlBeanFactory(defaultResourceLoader.getResource(&quot;file:///src/test/resources/com/sjr/test/bean/MyTestBean.xml&quot;));
		final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);
		final String testStr = testBean.getTestStr();
		System.out.println(testStr);
	}
```

​	相当于是个绝对路径了.其他协议可以查查资料.



# 三、自定义文件协议解析器

​	在`DefaultResourceLoader` 中的核心代码中有段遍历解析器的代码,来瞧瞧.

```java
		// 遍历所有协议解析器
		for (ProtocolResolver protocolResolver : getProtocolResolvers()) {
			// 解析资源
			Resource resource = protocolResolver.resolve(location, this);
			// 如果资源解析到则返回 resource 对象
			if (resource != null) {
				return resource;
			}
		}
```

​	通过这段代码,可以实现自定义文件协议解析器的逻辑,方便扩展.`ProtocolResolver`是个接口,里面就一个方法,非常简单.

```java
@FunctionalInterface
public interface ProtocolResolver {

	/**
	 * 解析
	 */
	@Nullable
	Resource resolve(String location, ResourceLoader resourceLoader);

}

```

​	该接口也是个函数接口(可以使用Lambda表达式).来实现一个协议试一试.

```java
// 实现ProtocolResolver 接口 自定义解析逻辑
public class SjrProtocolResolver implements ProtocolResolver {

	@Override
	public Resource resolve(String location, ResourceLoader resourceLoader) {
		if(resourceLoader == null){
			return null;
		}
		if(location == null || !location.startsWith(&quot;sjr&quot;)){
			return null;
		}
		final int index = location.indexOf(&quot;sjr:&quot;);
		return resourceLoader.getResource(location.substring(index + 4));
	}
}
```

```java
@Test
	public void testSpringProtocolResolverOfAdv(){
		DefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader(this.getClass().getClassLoader());
		defaultResourceLoader.addProtocolResolver(new SjrProtocolResolver());
		BeanFactory factory = new XmlBeanFactory(defaultResourceLoader.getResource(&quot;sjr:com/sjr/test/bean/MyTestBean.xml&quot;));
		final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class);
		final String testStr = testBean.getTestStr();
		System.out.println(testStr);
	}
```

​	这样就完成了自定义协议的解析.

​	`DefaultResourceLoader` 还有三个子类:

- ServletContextResourceLoader

  返回`ServletContextResource`,从`ServletContext`获取资源.

- FileSystemResourceLoader

  返回`FileSystemContextResource` ,从文件系统中获取资源,

   其本质上是`FileSystemResource`,实现了`ContextResource`接口

- ClassRelativeResourceLoader

  返回`ClassRelativeContextResource` ,从classPath获取资源,

  其本质上是`ClassPathResource`,实现了`ContextResource`接口

  这三个子类,都是做的简单扩展,逻辑简单,有兴趣可以去看看.



# 四、小结

​	文件是加载到,那么spring 是怎么解析xml文件的呢?</content><author><name>{&quot;nick&quot;=&gt;&quot;onew&quot;, &quot;link&quot;=&gt;&quot;https://onew.me&quot;}</name></author><category term="spring" /><category term="spring" /><category term="java" /><summary type="html">一、前言 ​ 资源统一抽象为Resource对象.可曾记得在 spring 配置文件中的这种写法:classpath:com/sjr/test/bean/MyTestBean.xml,那么这种写法的意思是从classpath路径下加载xml,那么spring是如何定位到文件的? ​ 上面这种写法相当于是个协议,在spring中默认支持9种文件协议. URL_PROTOCOL_FILE 从文件系统中加载文件 URL_PROTOCOL_JAR 从jar包中加载文件 URL_PROTOCOL_WAR 从war包中加载文件 URL_PROTOCOL_ZIP 从zip中加载文件 URL_PROTOCOL_WSJAR 从wsjar中加载文件 URL_PROTOCOL_VFSZIP 从vfszip中加载文件 URL_PROTOCOL_VFSFILE 从vfsfile中加载文件 URL_PROTOCOL_VFS 从vfs中加载文件 二、分析 ​ 这个故事要从一段代码开始 @Test public void testSpringResourceLoader(){ DefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader(this.getClass().getClassLoader()); BeanFactory factory = new XmlBeanFactory(defaultResourceLoader.getResource(&quot;classpath:com/sjr/test/bean/MyTestBean.xml&quot;)); final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class); final String testStr = testBean.getTestStr(); System.out.println(testStr); } ​ 之前的代码,我们是直接使用的ClassPathResource来加载文件,这里使用的DefaultResourceLoader对象来加载文件.那DefaultResourceLoader有什么用处呢? 自动检测文件该如何加载 2. 简化文件加载操作流程 2.1 DefaultResourceLoader ​ DefaultResourceLoader 是ResourceLoader的默认实现. 上图可以看到 DefaultResourceLoader 还有3个子类进行了功能的扩展.先看看ResourceLoader这个接口. 2.2 ResourceLoader public interface ResourceLoader { /** * classpath: 前缀常量 * */ String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX; /** * 通过 路径 获取 Resource 对象 */ Resource getResource(String location); /** * 获取类加载器 */ @Nullable ClassLoader getClassLoader(); } ​ 从代码可以看出,该接口只有2个方法,一个是通过路径获取 Resource 对象,另外一个是获取类加载器.那么在来看看 DefaultResourceLoader 的默认实现代码吧. 2.3 DefaultResourceLoader 具体实现 public class DefaultResourceLoader implements ResourceLoader { @Nullable private ClassLoader classLoader; // 协议解析器 set private final Set&amp;lt;ProtocolResolver&amp;gt; protocolResolvers = new LinkedHashSet&amp;lt;&amp;gt;(4); // 缓存 private final Map&amp;lt;Class&amp;lt;?&amp;gt;, Map&amp;lt;Resource, ?&amp;gt;&amp;gt; resourceCaches = new ConcurrentHashMap&amp;lt;&amp;gt;(4); /** * 使用默认构造器,默认构造器中使用默认的类加载器 */ public DefaultResourceLoader() { this.classLoader = ClassUtils.getDefaultClassLoader(); } /** * 使用指定的类加载器 */ public DefaultResourceLoader(@Nullable ClassLoader classLoader) { this.classLoader = classLoader; } /** * 设置类加载器 */ public void setClassLoader(@Nullable ClassLoader classLoader) { this.classLoader = classLoader; } /** * 获取类加载器 */ @Override @Nullable public ClassLoader getClassLoader() { return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader()); } /** * 添加协议解析器 */ public void addProtocolResolver(ProtocolResolver resolver) { Assert.notNull(resolver, &quot;ProtocolResolver must not be null&quot;); this.protocolResolvers.add(resolver); } /** * 获取协议解析器集合 */ public Collection&amp;lt;ProtocolResolver&amp;gt; getProtocolResolvers() { return this.protocolResolvers; } /** * 获取资源缓存 */ @SuppressWarnings(&quot;unchecked&quot;) public &amp;lt;T&amp;gt; Map&amp;lt;Resource, T&amp;gt; getResourceCache(Class&amp;lt;T&amp;gt; valueType) { return (Map&amp;lt;Resource, T&amp;gt;) this.resourceCaches.computeIfAbsent(valueType, key -&amp;gt; new ConcurrentHashMap&amp;lt;&amp;gt;()); } /** * 清除所有资源缓存 */ public void clearResourceCaches() { this.resourceCaches.clear(); } /** * 获取资源 * **/ @Override public Resource getResource(String location) { Assert.notNull(location, &quot;Location must not be null&quot;); // 遍历所有协议解析器 for (ProtocolResolver protocolResolver : getProtocolResolvers()) { // 解析资源 Resource resource = protocolResolver.resolve(location, this); // 如果资源解析到则返回 resource 对象 if (resource != null) { return resource; } } // 判断是否是/开头 if (location.startsWith(&quot;/&quot;)) { // 获取classpath上下文中的资源 return getResourceByPath(location); } // 判断是否是classpath:开头路径,如果是则从classpath中获取资源 else if (location.startsWith(CLASSPATH_URL_PREFIX)) { return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); } else { try { // 尝试把路径转化为url // Try to parse the location as a URL... URL url = new URL(location); // 判断是文件资源 还是url资源 return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url)); } catch (MalformedURLException ex) { // No URL -&amp;gt; resolve as resource path. // 非url 尝试从 classpath 上下文中获取资源 return getResourceByPath(location); } } } /** * 通过路径获取 Resource 对象 * 从 classPath 中加载文件 */ protected Resource getResourceByPath(String path) { return new ClassPathContextResource(path, getClassLoader()); } protected static class ClassPathContextResource extends ClassPathResource implements ContextResource { public ClassPathContextResource(String path, @Nullable ClassLoader classLoader) { super(path, classLoader); } @Override public String getPathWithinContext() { return getPath(); } /** * 创建相对路径的 Resource 对象 */ @Override public Resource createRelative(String relativePath) { String pathToUse = StringUtils.applyRelativePath(getPath(), relativePath); return new ClassPathContextResource(pathToUse, getClassLoader()); } } } ​ 以上代码的逻辑比较简单明了,核心逻辑在 getResource 这个方法中. public Resource getResource(String location) { Assert.notNull(location, &quot;Location must not be null&quot;); // 遍历所有协议解析器 for (ProtocolResolver protocolResolver : getProtocolResolvers()) { // 解析资源 Resource resource = protocolResolver.resolve(location, this); // 如果资源解析到则返回 resource 对象 if (resource != null) { return resource; } } // 判断是否是/开头 if (location.startsWith(&quot;/&quot;)) { // 获取classpath上下文中的资源 return getResourceByPath(location); } // 判断是否是classpath:开头路径,如果是则从classpath中获取资源 else if (location.startsWith(CLASSPATH_URL_PREFIX)) { return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); } else { try { // 尝试把路径转化为url // Try to parse the location as a URL... URL url = new URL(location); // 判断是文件资源 还是url资源 return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url)); } catch (MalformedURLException ex) { // No URL -&amp;gt; resolve as resource path. // 非url 尝试从 classpath 上下文中获取资源 return getResourceByPath(location); } } } ​ 逻辑流程为以下几步: 判断是否设置了 协议解析器,如果设置了,则遍历所有的协议解析, 并解析文件,如果解析成功则返回 Resource 对象否则执行第二步. 判断路径是否是 / 开头,若是则从classPath 加载文件,调用 getResourceByPath方法,返回 Resource 对象 判断是否是 classpath: 开头,若是则从 classPath 加载文件 若是以上几步都失败,则尝试把路径转为URL,如果成功则返回 FileUrlResource 或 UrlResource 对象 最后挣扎以下,从classPath 加载文件 2.4 FileUrlResource ​ 开篇说道 spring 默认支持 9中协议(如果把 classPath 也算上的话),那么除了 常用的 classPath 以外,其他的怎么使用呢?其他的笔者本人都没用过多少,就来看看 file 协议吧. @Test public void testSpringResourceLoaderForFileProtocol(){ DefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader(this.getClass().getClassLoader()); BeanFactory factory = new XmlBeanFactory(defaultResourceLoader.getResource(&quot;file:///src/test/resources/com/sjr/test/bean/MyTestBean.xml&quot;)); final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class); final String testStr = testBean.getTestStr(); System.out.println(testStr); } ​ 相当于是个绝对路径了.其他协议可以查查资料. 三、自定义文件协议解析器 ​ 在DefaultResourceLoader 中的核心代码中有段遍历解析器的代码,来瞧瞧. // 遍历所有协议解析器 for (ProtocolResolver protocolResolver : getProtocolResolvers()) { // 解析资源 Resource resource = protocolResolver.resolve(location, this); // 如果资源解析到则返回 resource 对象 if (resource != null) { return resource; } } ​ 通过这段代码,可以实现自定义文件协议解析器的逻辑,方便扩展.ProtocolResolver是个接口,里面就一个方法,非常简单. @FunctionalInterface public interface ProtocolResolver { /** * 解析 */ @Nullable Resource resolve(String location, ResourceLoader resourceLoader); } ​ 该接口也是个函数接口(可以使用Lambda表达式).来实现一个协议试一试. // 实现ProtocolResolver 接口 自定义解析逻辑 public class SjrProtocolResolver implements ProtocolResolver { @Override public Resource resolve(String location, ResourceLoader resourceLoader) { if(resourceLoader == null){ return null; } if(location == null || !location.startsWith(&quot;sjr&quot;)){ return null; } final int index = location.indexOf(&quot;sjr:&quot;); return resourceLoader.getResource(location.substring(index + 4)); } } @Test public void testSpringProtocolResolverOfAdv(){ DefaultResourceLoader defaultResourceLoader = new DefaultResourceLoader(this.getClass().getClassLoader()); defaultResourceLoader.addProtocolResolver(new SjrProtocolResolver()); BeanFactory factory = new XmlBeanFactory(defaultResourceLoader.getResource(&quot;sjr:com/sjr/test/bean/MyTestBean.xml&quot;)); final MyTestBean testBean = factory.getBean(&quot;myTestBean&quot;,MyTestBean.class); final String testStr = testBean.getTestStr(); System.out.println(testStr); } ​ 这样就完成了自定义协议的解析. ​ DefaultResourceLoader 还有三个子类: ServletContextResourceLoader 返回ServletContextResource,从ServletContext获取资源. FileSystemResourceLoader 返回FileSystemContextResource ,从文件系统中获取资源, 其本质上是FileSystemResource,实现了ContextResource接口 ClassRelativeResourceLoader 返回ClassRelativeContextResource ,从classPath获取资源, 其本质上是ClassPathResource,实现了ContextResource接口 这三个子类,都是做的简单扩展,逻辑简单,有兴趣可以去看看. 四、小结 ​ 文件是加载到,那么spring 是怎么解析xml文件的呢?</summary></entry></feed>